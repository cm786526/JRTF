// Copyright 2011 National Instruments
// License: NATIONAL INSTRUMENTS SOFTWARE LICENSE AGREEMENT
//   Refer to "MHDDK License Agreement.pdf" in the root of this distribution.

// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// This file is autogenerated!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!

#ifndef ___tAO_ipp___
#define ___tAO_ipp___

#ifndef ___tAO_h___
#include "tAO.h"
#endif

#ifndef ___nNIMXRegistermap_tStatus2Ptr_ipp___
#define ___nNIMXRegistermap_tStatus2Ptr_ipp___

typedef nMDBG::tStatus2 nNIMXRegisterMap120_tStatus2;


namespace nNIMXRegisterMap120 {
namespace {

typedef nNIMXRegisterMap120_tStatus2 tStatus2;

inline void setStatus(tStatus2* s, tStatus newStatus)
{
   if (s) s->setCode(newStatus);
}

inline tStatus* toPALStatusPtr(tStatus2* s)
{
   return s ? s->operator tStatus*() : ((tStatus*)NULL);
}

inline tBoolean statusIsFatal(tStatus2* s)
{
   return s && s->isFatal();
}

} // unnamed namespace
} // namespace nNIMXRegisterMap120

#endif // ___nNIMXRegistermap_tStatus2Ptr_ipp___


inline void tAO::tReg8IODirect32::write(
   tBusSpaceReference addrSpace,
   u32 offset,
   u8 value,
   nMDBG::tStatus2* s)
{
   if (s && s->isFatal()) return;
   addrSpace.write8(offset, value);
}
inline u8 tAO::tReg8IODirect32::read(
   tBusSpaceReference addrSpace,
   u32 offset,
   nMDBG::tStatus2* s)
{
   u8 value = (u8)~0;
   if (s && s->isFatal()) return value;
   value = (u8)addrSpace.read8(offset);
   return value;
}

inline void tAO::tReg32IODirect32::write(
   tBusSpaceReference addrSpace,
   u32 offset,
   u32 value,
   nMDBG::tStatus2* s)
{
   if (s && s->isFatal()) return;
   addrSpace.write32(offset, value);
}

inline u32 tAO::tReg32IODirect32::read(
   tBusSpaceReference addrSpace,
   u32 offset,
   nMDBG::tStatus2* s)
{
   u32 value = (u32)~0;
   if (s && s->isFatal()) return value;
   value = addrSpace.read32(offset);
   return value;
}

inline tBusSpaceReference tAO::getBusSpaceReference(void) const
{
   return _addrSpace;
}

inline void tAO::setAddressOffset(u32 value, nMDBG::tStatus2* s)
{
   if (s && s->isFatal()) return;
   _addressOffset = value;
}
inline u32 tAO::getAddressOffset(nMDBG::tStatus2* s)
{
   if (s && s->isFatal()) return 0UL;
   return _addressOffset;
}
inline tBoolean tAO::isDirty(tId id, nMDBG::tStatus2* s)
{
   if (s && s->isFatal()) return kFalse;
   u32 regId = id&0x01FFFFFF;
   if (regId > kMaxRegisterId) {
      nNIMXRegisterMap120::setStatus(s, kStatusBadSelector);
      return kFalse;
   }

   return _dirtyVector[regId];
}

inline void tAO::markDirty(tId id, nMDBG::tStatus2* s)
{
   if (s && s->isFatal()) return;
   u32 regId = id&0x01FFFFFF;

   if (regId > kMaxRegisterId) {
      nNIMXRegisterMap120::setStatus(s, kStatusBadSelector);
      return;
   }

   _dirtyVector[regId] = 1;
}

inline void tAO::markClean(tId id, nMDBG::tStatus2* s)
{
   if (s && s->isFatal()) return;
   u32 regId = id&0x01FFFFFF;

   if (regId > kMaxRegisterId) {
      nNIMXRegisterMap120::setStatus(s, kStatusBadSelector);
      return;
   }

   _dirtyVector[regId] = 0;
}

inline void tAO::markDirty(nMDBG::tStatus2* s)
{
   if (s && s->isFatal()) return;
   unsigned int i;
   for (i = 0; i < sizeof(_dirtyVector)/sizeof(_dirtyVector[0]); i++) {
      _dirtyVector[i] = 1;
   }
}

inline void tAO::markClean(nMDBG::tStatus2* s)
{
   if (s && s->isFatal()) return;
   for (unsigned int i = 0; i < sizeof(_dirtyVector)/sizeof(_dirtyVector[0]); i++) {
      _dirtyVector[i] = 0;
   }
}

inline tAO::tAO_DacShadow_t::tAO_DacShadow_t(u32 offset, u32 id)
 : kOffset(offset),
   kId(id)
{
   _softCopy = u32(0x0);
}

inline tAO::tAO_DacShadow_t::tAO_DacShadow_t()
 : kOffset((u32)~0),
   kId((u32)~0)
{
   _softCopy = u32(0x0);
}

inline void tAO::tAO_DacShadow_t::initialize(u32 offset, u32 id)
{
   u32* mutableOffset = const_cast<u32*>(&this->kOffset);
   u32* mutableId     = const_cast<u32*>(&this->kId);
   *mutableOffset = offset;
   *mutableId = id;
}

inline tAO::tAO_DacShadow_t::tRegisterMap* tAO::tAO_DacShadow_t::registerMap(void)
{
   return _regMap;
}

inline void tAO::tAO_DacShadow_t::setRegisterMap(tRegisterMap* pRegMap)
{
   _regMap = pRegMap;
}

inline tAO::tAO_DacShadow_t& tAO::tAO_DacShadow_t::setRegister(u32 fieldValue, nMDBG::tStatus2* s)
{
   if (s && s->isFatal()) return *this;
   _softCopy = fieldValue;
   return *this;
}

inline u32 tAO::tAO_DacShadow_t::getRegister(nMDBG::tStatus2*) const
{
   return _softCopy;
}

inline void tAO::tAO_DacShadow_t::refresh(nMDBG::tStatus2* s)
{
   _softCopy = tIOStrategy::read(_regMap->getBusSpaceReference(), kOffset + _regMap->getAddressOffset(s), s);
}

inline u32 tAO::tAO_DacShadow_t::readRegister(nMDBG::tStatus2* s)
{
   refresh(s);
   return _softCopy;
}

inline tAO::tAO_DacShadow_t& tAO::tAO_DacShadow_t::setAO_DacShadow_Bitfield(u32 fieldValue, nMDBG::tStatus2* s)
{
   if (s && s->isFatal()) return *this;
   u32 newValue;   newValue = (_softCopy & 0x0) | ((u32(fieldValue) << 0x0) & ~0x0);
   setRegister(newValue, s);
   return *this;
}

inline u32 tAO::tAO_DacShadow_t::getAO_DacShadow_Bitfield(nMDBG::tStatus2*) const
{
   return u32((_softCopy & ~0x0) >> 0x0);
}

inline u32 tAO::tAO_DacShadow_t::readAO_DacShadow_Bitfield(nMDBG::tStatus2* s)
{
   refresh(s);
   return getAO_DacShadow_Bitfield(s);
}

inline tAO::tAO_Direct_Data_t::tAO_Direct_Data_t(u32 offset, u32 id)
 : kOffset(offset),
   kId(id)
{
}

inline tAO::tAO_Direct_Data_t::tAO_Direct_Data_t()
 : kOffset((u32)~0),
   kId((u32)~0)
{
}

inline void tAO::tAO_Direct_Data_t::initialize(u32 offset, u32 id)
{
   u32* mutableOffset = const_cast<u32*>(&this->kOffset);
   u32* mutableId     = const_cast<u32*>(&this->kId);
   *mutableOffset = offset;
   *mutableId = id;
}

inline tAO::tAO_Direct_Data_t::tRegisterMap* tAO::tAO_Direct_Data_t::registerMap(void)
{
   return _regMap;
}

inline void tAO::tAO_Direct_Data_t::setRegisterMap(tRegisterMap* pRegMap)
{
   _regMap = pRegMap;
}

inline void tAO::tAO_Direct_Data_t::writeRegister(u32 fieldValue, nMDBG::tStatus2* s)
{
   if (s && s->isFatal()) return;
   tIOStrategy::write(_regMap->getBusSpaceReference(), kOffset + _regMap->getAddressOffset(s), fieldValue, s);
}

inline void tAO::tAO_Direct_Data_t::writeAO_Direct_Data_Bitfield(u32 fieldValue, nMDBG::tStatus2* s)
{
   writeRegister((u32(fieldValue) << 0x0) & ~0x0,s);
}
inline tAO::tAO_Order_Config_Data_Register::tAO_Order_Config_Data_Register()
{
}

inline tAO::tAO_Order_Config_Data_Register::tRegisterMap* tAO::tAO_Order_Config_Data_Register::registerMap(void)
{
   return _regMap;
}

inline void tAO::tAO_Order_Config_Data_Register::setRegisterMap(tRegisterMap* pRegMap)
{
   _regMap = pRegMap;
}

inline void tAO::tAO_Order_Config_Data_Register::writeRegister(u32 fieldValue, nMDBG::tStatus2* s)
{
   if (s && s->isFatal()) return;
   tIOStrategy::write(_regMap->getBusSpaceReference(), kOffset + _regMap->getAddressOffset(s), fieldValue, s);
}

inline void tAO::tAO_Order_Config_Data_Register::writeAO_Waveform_Bitfield_Order(u32 fieldValue, nMDBG::tStatus2* s)
{
   writeRegister((u32(fieldValue) << 0x0) & ~0xfffffff0,s);
}
inline tAO::tAO_Config_Control_Register::tAO_Config_Control_Register()
{
}

inline tAO::tAO_Config_Control_Register::tRegisterMap* tAO::tAO_Config_Control_Register::registerMap(void)
{
   return _regMap;
}

inline void tAO::tAO_Config_Control_Register::setRegisterMap(tRegisterMap* pRegMap)
{
   _regMap = pRegMap;
}

inline void tAO::tAO_Config_Control_Register::writeRegister(u32 fieldValue, nMDBG::tStatus2* s)
{
   if (s && s->isFatal()) return;
   tIOStrategy::write(_regMap->getBusSpaceReference(), kOffset + _regMap->getAddressOffset(s), fieldValue, s);
}

inline void tAO::tAO_Config_Control_Register::writeAO_Waveform_Order_Clear(u32 fieldValue, nMDBG::tStatus2* s)
{
   writeRegister((u32(fieldValue) << 0x0) & ~0xfffffffe,s);
}
inline tAO::tAO_Trigger_Select_Register::tAO_Trigger_Select_Register()
{
   _softCopy = u32(0x0);
}

inline tAO::tAO_Trigger_Select_Register::tRegisterMap* tAO::tAO_Trigger_Select_Register::registerMap(void)
{
   return _regMap;
}

inline void tAO::tAO_Trigger_Select_Register::setRegisterMap(tRegisterMap* pRegMap)
{
   _regMap = pRegMap;
}

inline tBoolean tAO::tAO_Trigger_Select_Register::isDirty(nMDBG::tStatus2* s)
{
   return _regMap->isDirty((tAO::tId)kId, s);
}

inline void tAO::tAO_Trigger_Select_Register::markDirty(nMDBG::tStatus2* s)
{
   _regMap->markDirty((tAO::tId)kId, s);
}

inline void tAO::tAO_Trigger_Select_Register::markClean(nMDBG::tStatus2* s)
{
   _regMap->markClean((tAO::tId)kId, s);
}

inline tAO::tAO_Trigger_Select_Register& tAO::tAO_Trigger_Select_Register::setRegister(u32 fieldValue, nMDBG::tStatus2* s)
{
   if (s && s->isFatal()) return *this;
   if (_softCopy != fieldValue) {
      _softCopy = fieldValue;
      markDirty(s);
   }
   return *this;
}

inline u32 tAO::tAO_Trigger_Select_Register::getRegister(nMDBG::tStatus2*) const
{
   return _softCopy;
}

inline void tAO::tAO_Trigger_Select_Register::flush(nMDBG::tStatus2* s, tBoolean force)
{
   if (s && s->isFatal()) return;
   if (force || isDirty(s)) {
      tIOStrategy::write(_regMap->getBusSpaceReference(), kOffset + _regMap->getAddressOffset(s), _softCopy, s);
      _softCopy &= u32(0xffffffff);
      _softCopy |= u32(0x0);
      markClean(s);
   }
}

inline void tAO::tAO_Trigger_Select_Register::writeRegister(u32 fieldValue, nMDBG::tStatus2* s, tBoolean force)
{
   if (s && s->isFatal()) return;
   force = force || (_softCopy != fieldValue);
   _softCopy = fieldValue;
   flush(s, force);
}

inline u32 tAO::tAO_Trigger_Select_Register::readRegister(nMDBG::tStatus2*)
{
   return _softCopy;
}


inline tAO::tAO_Trigger_Select_Register& tAO::tAO_Trigger_Select_Register::setAO_External_Gate_Enable(u32 fieldValue, nMDBG::tStatus2* s)
{
   if (s && s->isFatal()) return *this;
   u32 newValue;   newValue = (_softCopy & 0xfffffeff) | ((u32(fieldValue) << 0x8) & ~0xfffffeff);
   setRegister(newValue, s);
   return *this;
}

inline u32 tAO::tAO_Trigger_Select_Register::getAO_External_Gate_Enable(nMDBG::tStatus2*) const
{
   return u32((_softCopy & ~0xfffffeff) >> 0x8);
}

inline void tAO::tAO_Trigger_Select_Register::writeAO_External_Gate_Enable(u32 fieldValue, nMDBG::tStatus2* s, tBoolean force)
{
   setAO_External_Gate_Enable(fieldValue, s);
   flush(s, force);
}
inline u32 tAO::tAO_Trigger_Select_Register::readAO_External_Gate_Enable(nMDBG::tStatus2* s)
{
   return getAO_External_Gate_Enable(s);
}

inline tAO::tAO_Trigger_Select_Register& tAO::tAO_Trigger_Select_Register::setAO_External_Gate_Polarity(u32 fieldValue, nMDBG::tStatus2* s)
{
   if (s && s->isFatal()) return *this;
   u32 newValue;   newValue = (_softCopy & 0xfffffdff) | ((u32(fieldValue) << 0x9) & ~0xfffffdff);
   setRegister(newValue, s);
   return *this;
}

inline u32 tAO::tAO_Trigger_Select_Register::getAO_External_Gate_Polarity(nMDBG::tStatus2*) const
{
   return u32((_softCopy & ~0xfffffdff) >> 0x9);
}

inline void tAO::tAO_Trigger_Select_Register::writeAO_External_Gate_Polarity(u32 fieldValue, nMDBG::tStatus2* s, tBoolean force)
{
   setAO_External_Gate_Polarity(fieldValue, s);
   flush(s, force);
}
inline u32 tAO::tAO_Trigger_Select_Register::readAO_External_Gate_Polarity(nMDBG::tStatus2* s)
{
   return getAO_External_Gate_Polarity(s);
}

inline tAO::tAO_Trigger_Select_Register& tAO::tAO_Trigger_Select_Register::setAO_External_Gate_Select(nAO::tAO_External_Gate_Select_t fieldValue, nMDBG::tStatus2* s)
{
   if (s && s->isFatal()) return *this;
   u32 newValue;   newValue = (_softCopy & 0xffff03ff) | ((u32(fieldValue) << 0xa) & ~0xffff03ff);
   setRegister(newValue, s);
   return *this;
}

inline nAO::tAO_External_Gate_Select_t tAO::tAO_Trigger_Select_Register::getAO_External_Gate_Select(nMDBG::tStatus2*) const
{
   return nAO::tAO_External_Gate_Select_t((_softCopy & ~0xffff03ff) >> 0xa);
}

inline void tAO::tAO_Trigger_Select_Register::writeAO_External_Gate_Select(nAO::tAO_External_Gate_Select_t fieldValue, nMDBG::tStatus2* s, tBoolean force)
{
   setAO_External_Gate_Select(fieldValue, s);
   flush(s, force);
}
inline nAO::tAO_External_Gate_Select_t tAO::tAO_Trigger_Select_Register::readAO_External_Gate_Select(nMDBG::tStatus2* s)
{
   return getAO_External_Gate_Select(s);
}

inline tAO::tAO_Trigger_Select_Register& tAO::tAO_Trigger_Select_Register::setAO_START1_Edge(u32 fieldValue, nMDBG::tStatus2* s)
{
   if (s && s->isFatal()) return *this;
   u32 newValue;   newValue = (_softCopy & 0xfffeffff) | ((u32(fieldValue) << 0x10) & ~0xfffeffff);
   setRegister(newValue, s);
   return *this;
}

inline u32 tAO::tAO_Trigger_Select_Register::getAO_START1_Edge(nMDBG::tStatus2*) const
{
   return u32((_softCopy & ~0xfffeffff) >> 0x10);
}

inline void tAO::tAO_Trigger_Select_Register::writeAO_START1_Edge(u32 fieldValue, nMDBG::tStatus2* s, tBoolean force)
{
   setAO_START1_Edge(fieldValue, s);
   flush(s, force);
}
inline u32 tAO::tAO_Trigger_Select_Register::readAO_START1_Edge(nMDBG::tStatus2* s)
{
   return getAO_START1_Edge(s);
}

inline tAO::tAO_Trigger_Select_Register& tAO::tAO_Trigger_Select_Register::setAO_START1_Polarity(nAO::tAO_Polarity_t fieldValue, nMDBG::tStatus2* s)
{
   if (s && s->isFatal()) return *this;
   u32 newValue;   newValue = (_softCopy & 0xfffdffff) | ((u32(fieldValue) << 0x11) & ~0xfffdffff);
   setRegister(newValue, s);
   return *this;
}

inline nAO::tAO_Polarity_t tAO::tAO_Trigger_Select_Register::getAO_START1_Polarity(nMDBG::tStatus2*) const
{
   return nAO::tAO_Polarity_t((_softCopy & ~0xfffdffff) >> 0x11);
}

inline void tAO::tAO_Trigger_Select_Register::writeAO_START1_Polarity(nAO::tAO_Polarity_t fieldValue, nMDBG::tStatus2* s, tBoolean force)
{
   setAO_START1_Polarity(fieldValue, s);
   flush(s, force);
}
inline nAO::tAO_Polarity_t tAO::tAO_Trigger_Select_Register::readAO_START1_Polarity(nMDBG::tStatus2* s)
{
   return getAO_START1_Polarity(s);
}

inline tAO::tAO_Trigger_Select_Register& tAO::tAO_Trigger_Select_Register::setAO_START1_Select(nAO::tAO_START1_Select_t fieldValue, nMDBG::tStatus2* s)
{
   if (s && s->isFatal()) return *this;
   u32 newValue;   newValue = (_softCopy & 0xff03ffff) | ((u32(fieldValue) << 0x12) & ~0xff03ffff);
   setRegister(newValue, s);
   return *this;
}

inline nAO::tAO_START1_Select_t tAO::tAO_Trigger_Select_Register::getAO_START1_Select(nMDBG::tStatus2*) const
{
   return nAO::tAO_START1_Select_t((_softCopy & ~0xff03ffff) >> 0x12);
}

inline void tAO::tAO_Trigger_Select_Register::writeAO_START1_Select(nAO::tAO_START1_Select_t fieldValue, nMDBG::tStatus2* s, tBoolean force)
{
   setAO_START1_Select(fieldValue, s);
   flush(s, force);
}
inline nAO::tAO_START1_Select_t tAO::tAO_Trigger_Select_Register::readAO_START1_Select(nMDBG::tStatus2* s)
{
   return getAO_START1_Select(s);
}

inline tAO::tAO_Trigger_Select_Register& tAO::tAO_Trigger_Select_Register::setAO_UPDATE_Source_Polarity(nAO::tAO_Polarity_t fieldValue, nMDBG::tStatus2* s)
{
   if (s && s->isFatal()) return *this;
   u32 newValue;   newValue = (_softCopy & 0xfdffffff) | ((u32(fieldValue) << 0x19) & ~0xfdffffff);
   setRegister(newValue, s);
   return *this;
}

inline nAO::tAO_Polarity_t tAO::tAO_Trigger_Select_Register::getAO_UPDATE_Source_Polarity(nMDBG::tStatus2*) const
{
   return nAO::tAO_Polarity_t((_softCopy & ~0xfdffffff) >> 0x19);
}

inline void tAO::tAO_Trigger_Select_Register::writeAO_UPDATE_Source_Polarity(nAO::tAO_Polarity_t fieldValue, nMDBG::tStatus2* s, tBoolean force)
{
   setAO_UPDATE_Source_Polarity(fieldValue, s);
   flush(s, force);
}
inline nAO::tAO_Polarity_t tAO::tAO_Trigger_Select_Register::readAO_UPDATE_Source_Polarity(nMDBG::tStatus2* s)
{
   return getAO_UPDATE_Source_Polarity(s);
}

inline tAO::tAO_Trigger_Select_Register& tAO::tAO_Trigger_Select_Register::setAO_UPDATE_Source_Select(nAO::tAO_UPDATE_Source_Select_t fieldValue, nMDBG::tStatus2* s)
{
   if (s && s->isFatal()) return *this;
   u32 newValue;   newValue = (_softCopy & 0x3ffffff) | ((u32(fieldValue) << 0x1a) & ~0x3ffffff);
   setRegister(newValue, s);
   return *this;
}

inline nAO::tAO_UPDATE_Source_Select_t tAO::tAO_Trigger_Select_Register::getAO_UPDATE_Source_Select(nMDBG::tStatus2*) const
{
   return nAO::tAO_UPDATE_Source_Select_t((_softCopy & ~0x3ffffff) >> 0x1a);
}

inline void tAO::tAO_Trigger_Select_Register::writeAO_UPDATE_Source_Select(nAO::tAO_UPDATE_Source_Select_t fieldValue, nMDBG::tStatus2* s, tBoolean force)
{
   setAO_UPDATE_Source_Select(fieldValue, s);
   flush(s, force);
}
inline nAO::tAO_UPDATE_Source_Select_t tAO::tAO_Trigger_Select_Register::readAO_UPDATE_Source_Select(nMDBG::tStatus2* s)
{
   return getAO_UPDATE_Source_Select(s);
}

inline tAO::tAO_Config_Bank_t::tAO_Config_Bank_t(u32 offset, u32 id)
 : kOffset(offset),
   kId(id)
{
   _softCopy = u8(0x0);
}

inline tAO::tAO_Config_Bank_t::tAO_Config_Bank_t()
 : kOffset((u32)~0),
   kId((u32)~0)
{
   _softCopy = u8(0x0);
}

inline void tAO::tAO_Config_Bank_t::initialize(u32 offset, u32 id)
{
   u32* mutableOffset = const_cast<u32*>(&this->kOffset);
   u32* mutableId     = const_cast<u32*>(&this->kId);
   *mutableOffset = offset;
   *mutableId = id;
}

inline tAO::tAO_Config_Bank_t::tRegisterMap* tAO::tAO_Config_Bank_t::registerMap(void)
{
   return _regMap;
}

inline void tAO::tAO_Config_Bank_t::setRegisterMap(tRegisterMap* pRegMap)
{
   _regMap = pRegMap;
}

inline tBoolean tAO::tAO_Config_Bank_t::isDirty(nMDBG::tStatus2* s)
{
   return _regMap->isDirty((tAO::tId)kId, s);
}

inline void tAO::tAO_Config_Bank_t::markDirty(nMDBG::tStatus2* s)
{
   _regMap->markDirty((tAO::tId)kId, s);
}

inline void tAO::tAO_Config_Bank_t::markClean(nMDBG::tStatus2* s)
{
   _regMap->markClean((tAO::tId)kId, s);
}

inline tAO::tAO_Config_Bank_t& tAO::tAO_Config_Bank_t::setRegister(u8 fieldValue, nMDBG::tStatus2* s)
{
   if (s && s->isFatal()) return *this;
   if (_softCopy != fieldValue) {
      _softCopy = fieldValue;
      markDirty(s);
   }
   return *this;
}

inline u8 tAO::tAO_Config_Bank_t::getRegister(nMDBG::tStatus2*) const
{
   return _softCopy;
}

inline void tAO::tAO_Config_Bank_t::flush(nMDBG::tStatus2* s, tBoolean force)
{
   if (s && s->isFatal()) return;
   if (force || isDirty(s)) {
      tIOStrategy::write(_regMap->getBusSpaceReference(), kOffset + _regMap->getAddressOffset(s), _softCopy, s);
      _softCopy &= u8(0xff);
      _softCopy |= u8(0x0);
      markClean(s);
   }
}

inline void tAO::tAO_Config_Bank_t::writeRegister(u8 fieldValue, nMDBG::tStatus2* s, tBoolean force)
{
   if (s && s->isFatal()) return;
   force = force || (_softCopy != fieldValue);
   _softCopy = fieldValue;
   flush(s, force);
}

inline u8 tAO::tAO_Config_Bank_t::readRegister(nMDBG::tStatus2*)
{
   return _softCopy;
}


inline tAO::tAO_Config_Bank_t& tAO::tAO_Config_Bank_t::setAO_Offset(u8 fieldValue, nMDBG::tStatus2* s)
{
   if (s && s->isFatal()) return *this;
   u8 newValue;   newValue = (_softCopy & 0xf8) | ((u8(fieldValue) << 0x0) & ~0xf8);
   setRegister(newValue, s);
   return *this;
}

inline u8 tAO::tAO_Config_Bank_t::getAO_Offset(nMDBG::tStatus2*) const
{
   return u8((_softCopy & ~0xf8) >> 0x0);
}

inline void tAO::tAO_Config_Bank_t::writeAO_Offset(u8 fieldValue, nMDBG::tStatus2* s, tBoolean force)
{
   setAO_Offset(fieldValue, s);
   flush(s, force);
}
inline u8 tAO::tAO_Config_Bank_t::readAO_Offset(nMDBG::tStatus2* s)
{
   return getAO_Offset(s);
}

inline tAO::tAO_Config_Bank_t& tAO::tAO_Config_Bank_t::setAO_Reference(u8 fieldValue, nMDBG::tStatus2* s)
{
   if (s && s->isFatal()) return *this;
   u8 newValue;   newValue = (_softCopy & 0xc7) | ((u8(fieldValue) << 0x3) & ~0xc7);
   setRegister(newValue, s);
   return *this;
}

inline u8 tAO::tAO_Config_Bank_t::getAO_Reference(nMDBG::tStatus2*) const
{
   return u8((_softCopy & ~0xc7) >> 0x3);
}

inline void tAO::tAO_Config_Bank_t::writeAO_Reference(u8 fieldValue, nMDBG::tStatus2* s, tBoolean force)
{
   setAO_Reference(fieldValue, s);
   flush(s, force);
}
inline u8 tAO::tAO_Config_Bank_t::readAO_Reference(nMDBG::tStatus2* s)
{
   return getAO_Reference(s);
}

inline tAO::tAO_Config_Bank_t& tAO::tAO_Config_Bank_t::setAO_Update_Mode(nAO::tAO_Update_Mode_t fieldValue, nMDBG::tStatus2* s)
{
   if (s && s->isFatal()) return *this;
   u8 newValue;   newValue = (_softCopy & 0xbf) | ((u8(fieldValue) << 0x6) & ~0xbf);
   setRegister(newValue, s);
   return *this;
}

inline nAO::tAO_Update_Mode_t tAO::tAO_Config_Bank_t::getAO_Update_Mode(nMDBG::tStatus2*) const
{
   return nAO::tAO_Update_Mode_t((_softCopy & ~0xbf) >> 0x6);
}

inline void tAO::tAO_Config_Bank_t::writeAO_Update_Mode(nAO::tAO_Update_Mode_t fieldValue, nMDBG::tStatus2* s, tBoolean force)
{
   setAO_Update_Mode(fieldValue, s);
   flush(s, force);
}
inline nAO::tAO_Update_Mode_t tAO::tAO_Config_Bank_t::readAO_Update_Mode(nMDBG::tStatus2* s)
{
   return getAO_Update_Mode(s);
}

inline tAO::tAO_Config_Bank_t& tAO::tAO_Config_Bank_t::setAO_Bipolar(nAO::tAO_Bipolar_t fieldValue, nMDBG::tStatus2* s)
{
   if (s && s->isFatal()) return *this;
   u8 newValue;   newValue = (_softCopy & 0x7f) | ((u8(fieldValue) << 0x7) & ~0x7f);
   setRegister(newValue, s);
   return *this;
}

inline nAO::tAO_Bipolar_t tAO::tAO_Config_Bank_t::getAO_Bipolar(nMDBG::tStatus2*) const
{
   return nAO::tAO_Bipolar_t((_softCopy & ~0x7f) >> 0x7);
}

inline void tAO::tAO_Config_Bank_t::writeAO_Bipolar(nAO::tAO_Bipolar_t fieldValue, nMDBG::tStatus2* s, tBoolean force)
{
   setAO_Bipolar(fieldValue, s);
   flush(s, force);
}
inline nAO::tAO_Bipolar_t tAO::tAO_Config_Bank_t::readAO_Bipolar(nMDBG::tStatus2* s)
{
   return getAO_Bipolar(s);
}

inline tAO::tAO_FIFO_Data_Register::tAO_FIFO_Data_Register()
{
}

inline tAO::tAO_FIFO_Data_Register::tRegisterMap* tAO::tAO_FIFO_Data_Register::registerMap(void)
{
   return _regMap;
}

inline void tAO::tAO_FIFO_Data_Register::setRegisterMap(tRegisterMap* pRegMap)
{
   _regMap = pRegMap;
}

inline void tAO::tAO_FIFO_Data_Register::writeRegister(u32 fieldValue, nMDBG::tStatus2* s)
{
   if (s && s->isFatal()) return;
   tIOStrategy::write(_regMap->getBusSpaceReference(), kOffset + _regMap->getAddressOffset(s), fieldValue, s);
}

inline void tAO::tAO_FIFO_Data_Register::writeAO_FIFO_Data(u32 fieldValue, nMDBG::tStatus2* s)
{
   writeRegister((u32(fieldValue) << 0x0) & ~0x0,s);
}
inline tAO::tAO_FIFO_Status_Register::tAO_FIFO_Status_Register()
{
   _softCopy = u32(0x0);
}

inline tAO::tAO_FIFO_Status_Register::tRegisterMap* tAO::tAO_FIFO_Status_Register::registerMap(void)
{
   return _regMap;
}

inline void tAO::tAO_FIFO_Status_Register::setRegisterMap(tRegisterMap* pRegMap)
{
   _regMap = pRegMap;
}

inline tAO::tAO_FIFO_Status_Register& tAO::tAO_FIFO_Status_Register::setRegister(u32 fieldValue, nMDBG::tStatus2* s)
{
   if (s && s->isFatal()) return *this;
   _softCopy = fieldValue;
   return *this;
}

inline u32 tAO::tAO_FIFO_Status_Register::getRegister(nMDBG::tStatus2*) const
{
   return _softCopy;
}

inline void tAO::tAO_FIFO_Status_Register::refresh(nMDBG::tStatus2* s)
{
   _softCopy = tIOStrategy::read(_regMap->getBusSpaceReference(), kOffset + _regMap->getAddressOffset(s), s);
}

inline u32 tAO::tAO_FIFO_Status_Register::readRegister(nMDBG::tStatus2* s)
{
   refresh(s);
   return _softCopy;
}

inline tAO::tAO_FIFO_Status_Register& tAO::tAO_FIFO_Status_Register::setAO_FIFO_Status(u32 fieldValue, nMDBG::tStatus2* s)
{
   if (s && s->isFatal()) return *this;
   u32 newValue;   newValue = (_softCopy & 0x0) | ((u32(fieldValue) << 0x0) & ~0x0);
   setRegister(newValue, s);
   return *this;
}

inline u32 tAO::tAO_FIFO_Status_Register::getAO_FIFO_Status(nMDBG::tStatus2*) const
{
   return u32((_softCopy & ~0x0) >> 0x0);
}

inline u32 tAO::tAO_FIFO_Status_Register::readAO_FIFO_Status(nMDBG::tStatus2* s)
{
   refresh(s);
   return getAO_FIFO_Status(s);
}

#endif


// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// This file is autogenerated!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!

