// Copyright 2011 National Instruments
// License: NATIONAL INSTRUMENTS SOFTWARE LICENSE AGREEMENT
//   Refer to "MHDDK License Agreement.pdf" in the root of this distribution.

// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// This file is autogenerated!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!

#ifndef ___tCHInCh_h___
#define ___tCHInCh_h___

// includes
#include "osiTypes.h"
#include "osiBus.h"
#include "tDMAController.h"


#ifndef ___tCHInChValues_h___
#include "tCHInChValues.h"
#endif

#ifndef nNIMXRegisterMap120_mBuildFieldId

// Algorithm:
//    Move lowermost 5 bits (4 through 0) of field id to uppermost 5 bits (31
//          through 27)
//    Move bit 5 of field id to bit 26
//    Move bit 6 of field id to bit 25
//    OR in the register id (which is allowed the remaining bits)
//
// Why not move the lowermost 7 bits directly to the uppermost 7 bits? Because
// we originally moved only the lowermost 5, and for backwards compatibility,
// we can't change where those 5 bits end up.
//
// For future expansion purposes, the bits beyond the first 5 are put in reverse
// order in the resulting combined id.
#define nNIMXRegisterMap120_mBuildFieldId(fieldId, regId) \
   ( \
     ((fieldId) << 27) | \
     ((((fieldId) >> 5) & 0x1) << 26) | \
     ((((fieldId) >> 6) & 0x1) << 25) | \
     (regId) \
   )

#endif

#ifndef nNIMXRegisterMap120_mExtractFieldId

// Algorithm: (basically the reverse of mBuildFieldId)
//    Move uppermost 5 bits (31 through 27) to lowermost 5 bits (4 through 0)
//    Move 26th bit to bit 5 (right-shifting by (26 - 5) is like right-shifting
//          by 26 then left-shifting by 5, but it's more efficient)
//    Move 25th bit to bit 6
#define nNIMXRegisterMap120_mExtractFieldId(id) \
   (unsigned int) \
   ( \
     (((id) >> 27) & 0x1F) | \
     (((id) & (0x1 << 26)) >> (26 - 5)) | \
     (((id) & (0x1 << 25)) >> (25 - 6)) \
   )

#endif

class tCHInCh
{
public:
   tDMAController AI_DMAChannel;
   tDMAController Counter0DmaChannel;
   tDMAController Counter1DmaChannel;
   tDMAController Counter2DmaChannel;
   tDMAController Counter3DmaChannel;
   tDMAController DI_DMAChannel;
   tDMAController AO_DMAChannel;
   tDMAController DO_DMAChannel;

   //---------------------------------------------------------------------------
   // IO Strategies
   //---------------------------------------------------------------------------
   class tReg32IODirect32
   {
   public:
      inline void write(
         tBusSpaceReference addrSpace,
         u32 offset,
         u32 value,
         nMDBG::tStatus2* statusChain = NULL);

      inline u32 read(
         tBusSpaceReference addrSpace,
         u32 offset,
         nMDBG::tStatus2* statusChain = NULL);
   };

   //---------------------------------------------------------------------------
   // CHInCh_Identification_Register
   //---------------------------------------------------------------------------
   class tCHInCh_Identification_Register : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tCHInCh tRegisterMap;

      enum {
         kOffset = 0x0,
         kId     = 0
      };
      tCHInCh_Identification_Register();


      typedef enum {
         kRegisterId                          = 0,
         kIDId                             = 1,
         kMaxFieldId                          = 1
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Register Accessors (Compile-time selectable)
      inline tCHInCh_Identification_Register& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void refresh(nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tCHInCh_Identification_Register& setID(nCHInCh::tCHInCh_Signature_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nCHInCh::tCHInCh_Signature_t getID(nMDBG::tStatus2* statusChain = NULL) const;

      inline nCHInCh::tCHInCh_Signature_t readID(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tCHInCh_Identification_Register(const tCHInCh_Identification_Register&);
      tCHInCh_Identification_Register& operator=(const tCHInCh_Identification_Register&);

   };

   //---------------------------------------------------------------------------
   // IO_Port_Resource_Description_Register
   //---------------------------------------------------------------------------
   class tIO_Port_Resource_Description_Register : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tCHInCh tRegisterMap;

      enum {
         kOffset = 0x10,
         kId     = 1
      };
      tIO_Port_Resource_Description_Register();


      typedef enum {
         kRegisterId                          = 0,
         kIOMPSId                          = 3,
         kMaxFieldId                          = 3
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Register Accessors (Compile-time selectable)
      inline tIO_Port_Resource_Description_Register& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void refresh(nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tIO_Port_Resource_Description_Register& setIOMPS(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getIOMPS(nMDBG::tStatus2* statusChain = NULL) const;

      inline u32 readIOMPS(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tIO_Port_Resource_Description_Register(const tIO_Port_Resource_Description_Register&);
      tIO_Port_Resource_Description_Register& operator=(const tIO_Port_Resource_Description_Register&);

   };

   //---------------------------------------------------------------------------
   // Interrupt_Mask_Register
   //---------------------------------------------------------------------------
   class tInterrupt_Mask_Register : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tCHInCh tRegisterMap;

      enum {
         kOffset = 0x5c,
         kId     = 2
      };
      tInterrupt_Mask_Register();


      typedef enum {
         kRegisterId                          = 0,
         kClear_SMIO_FIFO_IntId            = 3,
         kSet_SMIO_FIFO_IntId              = 4,
         kClear_STC3_IntId                 = 5,
         kSet_STC3_IntId                   = 6,
         kClear_CPU_IntId                  = 14,
         kSet_CPU_IntId                    = 15,
         kMaxFieldId                          = 15
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Dirty Tracking
      inline tBoolean isDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markClean(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tInterrupt_Mask_Register& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL, tBoolean force = kTrue);

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kTrue);

      inline void refresh(nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tInterrupt_Mask_Register& setClear_SMIO_FIFO_Int(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getClear_SMIO_FIFO_Int(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeClear_SMIO_FIFO_Int(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kTrue);

      inline u32 readClear_SMIO_FIFO_Int(nMDBG::tStatus2* statusChain = NULL);

      inline tInterrupt_Mask_Register& setSet_SMIO_FIFO_Int(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getSet_SMIO_FIFO_Int(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeSet_SMIO_FIFO_Int(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kTrue);

      inline u32 readSet_SMIO_FIFO_Int(nMDBG::tStatus2* statusChain = NULL);

      inline tInterrupt_Mask_Register& setClear_STC3_Int(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getClear_STC3_Int(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeClear_STC3_Int(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kTrue);

      inline u32 readClear_STC3_Int(nMDBG::tStatus2* statusChain = NULL);

      inline tInterrupt_Mask_Register& setSet_STC3_Int(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getSet_STC3_Int(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeSet_STC3_Int(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kTrue);

      inline u32 readSet_STC3_Int(nMDBG::tStatus2* statusChain = NULL);

      inline tInterrupt_Mask_Register& setClear_CPU_Int(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getClear_CPU_Int(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeClear_CPU_Int(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kTrue);

      inline u32 readClear_CPU_Int(nMDBG::tStatus2* statusChain = NULL);

      inline tInterrupt_Mask_Register& setSet_CPU_Int(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getSet_CPU_Int(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeSet_CPU_Int(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kTrue);

      inline u32 readSet_CPU_Int(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tInterrupt_Mask_Register(const tInterrupt_Mask_Register&);
      tInterrupt_Mask_Register& operator=(const tInterrupt_Mask_Register&);

   };

   //---------------------------------------------------------------------------
   // Interrupt_Status_Register
   //---------------------------------------------------------------------------
   class tInterrupt_Status_Register : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tCHInCh tRegisterMap;

      enum {
         kOffset = 0x60,
         kId     = 3
      };
      tInterrupt_Status_Register();


      typedef enum {
         kRegisterId                          = 0,
         kSMIO_FIFO_IntId                  = 2,
         kSTC3_IntId                       = 4,
         kDMAId                            = 10,
         kExternalId                       = 11,
         kAdditional_IntId                 = 12,
         kIntId                            = 13,
         kMaxFieldId                          = 13
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Register Accessors (Compile-time selectable)

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline u32 readSMIO_FIFO_Int(nMDBG::tStatus2* statusChain = NULL);

      inline u32 readSTC3_Int(nMDBG::tStatus2* statusChain = NULL);

      inline u32 readDMA(nMDBG::tStatus2* statusChain = NULL);

      inline u32 readExternal(nMDBG::tStatus2* statusChain = NULL);

      inline u32 readAdditional_Int(nMDBG::tStatus2* statusChain = NULL);

      inline u32 readInt(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      tRegisterMap* _regMap;

      // Usage guidelines
      tInterrupt_Status_Register(const tInterrupt_Status_Register&);
      tInterrupt_Status_Register& operator=(const tInterrupt_Status_Register&);

   };

   //---------------------------------------------------------------------------
   // Volatile_Interrupt_Status_Register
   //---------------------------------------------------------------------------
   class tVolatile_Interrupt_Status_Register : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tCHInCh tRegisterMap;

      enum {
         kOffset = 0x68,
         kId     = 4
      };
      tVolatile_Interrupt_Status_Register();


      typedef enum {
         kRegisterId                          = 0,
         kVol_SMIO_FIFO_IntId              = 2,
         kVol_STC3_IntId                   = 4,
         kVol_DMAId                        = 10,
         kVol_ExternalId                   = 11,
         kVol_Additional_IntId             = 12,
         kVol_IntId                        = 13,
         kMaxFieldId                          = 13
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Register Accessors (Compile-time selectable)

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline u32 readVol_SMIO_FIFO_Int(nMDBG::tStatus2* statusChain = NULL);

      inline u32 readVol_STC3_Int(nMDBG::tStatus2* statusChain = NULL);

      inline u32 readVol_DMA(nMDBG::tStatus2* statusChain = NULL);

      inline u32 readVol_External(nMDBG::tStatus2* statusChain = NULL);

      inline u32 readVol_Additional_Int(nMDBG::tStatus2* statusChain = NULL);

      inline u32 readVol_Int(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      tRegisterMap* _regMap;

      // Usage guidelines
      tVolatile_Interrupt_Status_Register(const tVolatile_Interrupt_Status_Register&);
      tVolatile_Interrupt_Status_Register& operator=(const tVolatile_Interrupt_Status_Register&);

   };

   //---------------------------------------------------------------------------
   // Host_Bus_Resource_Control_Register
   //---------------------------------------------------------------------------
   class tHost_Bus_Resource_Control_Register : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tCHInCh tRegisterMap;

      enum {
         kOffset = 0xa4,
         kId     = 5
      };
      tHost_Bus_Resource_Control_Register();


      typedef enum {
         kRegisterId                          = 0,
         kDMA_MA64Id                       = 4,
         kDMA_LA64Id                       = 5,
         kIO_Master_EnableId               = 11,
         kMaxFieldId                          = 11
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Dirty Tracking
      inline tBoolean isDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markClean(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tHost_Bus_Resource_Control_Register& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL, tBoolean force = kTrue);

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kTrue);

      inline void refresh(nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tHost_Bus_Resource_Control_Register& setDMA_MA64(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getDMA_MA64(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeDMA_MA64(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kTrue);

      inline u32 readDMA_MA64(nMDBG::tStatus2* statusChain = NULL);

      inline tHost_Bus_Resource_Control_Register& setDMA_LA64(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getDMA_LA64(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeDMA_LA64(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kTrue);

      inline u32 readDMA_LA64(nMDBG::tStatus2* statusChain = NULL);

      inline tHost_Bus_Resource_Control_Register& setIO_Master_Enable(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getIO_Master_Enable(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeIO_Master_Enable(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kTrue);

      inline u32 readIO_Master_Enable(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tHost_Bus_Resource_Control_Register(const tHost_Bus_Resource_Control_Register&);
      tHost_Bus_Resource_Control_Register& operator=(const tHost_Bus_Resource_Control_Register&);

   };

   //---------------------------------------------------------------------------
   // EEPROM_Window_Register
   //---------------------------------------------------------------------------
   class tEEPROM_Window_Register : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tCHInCh tRegisterMap;

      enum {
         kOffset = 0xc0,
         kId     = 6
      };
      tEEPROM_Window_Register();


      typedef enum {
         kRegisterId                          = 0,
         kEEPROM_Window_FieldId            = 1,
         kMaxFieldId                          = 1
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Register Accessors (Compile-time selectable)

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline void writeEEPROM_Window_Field(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readEEPROM_Window_Field(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      tRegisterMap* _regMap;

      // Usage guidelines
      tEEPROM_Window_Register(const tEEPROM_Window_Register&);
      tEEPROM_Window_Register& operator=(const tEEPROM_Window_Register&);

   };

   //---------------------------------------------------------------------------
   // Simultaneous_Window_Register
   //---------------------------------------------------------------------------
   class tSimultaneous_Window_Register : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tCHInCh tRegisterMap;

      enum {
         kOffset = 0xc4,
         kId     = 7
      };
      tSimultaneous_Window_Register();


      typedef enum {
         kRegisterId                          = 0,
         kSimultaneous_Window_FieldId      = 1,
         kMaxFieldId                          = 1
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Register Accessors (Compile-time selectable)

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline void writeSimultaneous_Window_Field(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readSimultaneous_Window_Field(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      tRegisterMap* _regMap;

      // Usage guidelines
      tSimultaneous_Window_Register(const tSimultaneous_Window_Register&);
      tSimultaneous_Window_Register& operator=(const tSimultaneous_Window_Register&);

   };

   //---------------------------------------------------------------------------
   // Window_Control_Register
   //---------------------------------------------------------------------------
   class tWindow_Control_Register : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tCHInCh tRegisterMap;

      enum {
         kOffset = 0xe0,
         kId     = 8
      };
      tWindow_Control_Register();


      typedef enum {
         kRegisterId                          = 0,
         kWindow_Control_FieldId           = 1,
         kMaxFieldId                          = 1
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Register Accessors (Compile-time selectable)

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline void writeWindow_Control_Field(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readWindow_Control_Field(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      tRegisterMap* _regMap;

      // Usage guidelines
      tWindow_Control_Register(const tWindow_Control_Register&);
      tWindow_Control_Register& operator=(const tWindow_Control_Register&);

   };

   //---------------------------------------------------------------------------
   // Scrap_Register_t
   //---------------------------------------------------------------------------
   class tScrap_Register_t : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tCHInCh tRegisterMap;

      const u32 kOffset;
      const u32 kId;

      tScrap_Register_t(u32 offset, u32 id);
      tScrap_Register_t();
      void initialize(u32 offset, u32 id);


      typedef enum {
         kRegisterId                          = 0,
         kSDATAId                          = 1,
         kMaxFieldId                          = 1
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Dirty Tracking
      inline tBoolean isDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markClean(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tScrap_Register_t& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL, tBoolean force = kTrue);

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kTrue);

      inline void refresh(nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tScrap_Register_t& setSDATA(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getSDATA(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeSDATA(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kTrue);

      inline u32 readSDATA(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tScrap_Register_t(const tScrap_Register_t&);
      tScrap_Register_t& operator=(const tScrap_Register_t&);

   };

   //---------------------------------------------------------------------------
   // Configuration_Register
   //---------------------------------------------------------------------------
   class tConfiguration_Register : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tCHInCh tRegisterMap;

      enum {
         kOffset = 0x514,
         kId     = 10
      };
      tConfiguration_Register();


      typedef enum {
         kRegisterId                          = 0,
         kConfiguration_ValueId            = 1,
         kMaxFieldId                          = 1
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Register Accessors (Compile-time selectable)

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline void writeConfiguration_Value(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readConfiguration_Value(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      tRegisterMap* _regMap;

      // Usage guidelines
      tConfiguration_Register(const tConfiguration_Register&);
      tConfiguration_Register& operator=(const tConfiguration_Register&);

   };

   //---------------------------------------------------------------------------
   // EEPROM_Register_0
   //---------------------------------------------------------------------------
   class tEEPROM_Register_0 : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tCHInCh tRegisterMap;

      enum {
         kOffset = 0x580,
         kId     = 11
      };
      tEEPROM_Register_0();


      typedef enum {
         kRegisterId                          = 0,
         kEEPROM_Register_0_ValueId        = 1,
         kMaxFieldId                          = 1
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Register Accessors (Compile-time selectable)

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline void writeEEPROM_Register_0_Value(nCHInCh::tEEPROM_Register_0_Value_t fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline nCHInCh::tEEPROM_Register_0_Value_t readEEPROM_Register_0_Value(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      tRegisterMap* _regMap;

      // Usage guidelines
      tEEPROM_Register_0(const tEEPROM_Register_0&);
      tEEPROM_Register_0& operator=(const tEEPROM_Register_0&);

   };

   //---------------------------------------------------------------------------
   // EEPROM_Register_1
   //---------------------------------------------------------------------------
   class tEEPROM_Register_1 : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tCHInCh tRegisterMap;

      enum {
         kOffset = 0x584,
         kId     = 12
      };
      tEEPROM_Register_1();


      typedef enum {
         kRegisterId                          = 0,
         kEEPROM_Register_1_ValueId        = 1,
         kMaxFieldId                          = 1
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Register Accessors (Compile-time selectable)

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline void writeEEPROM_Register_1_Value(nCHInCh::tEEPROM_Register_1_Value_t fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline nCHInCh::tEEPROM_Register_1_Value_t readEEPROM_Register_1_Value(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      tRegisterMap* _regMap;

      // Usage guidelines
      tEEPROM_Register_1(const tEEPROM_Register_1&);
      tEEPROM_Register_1& operator=(const tEEPROM_Register_1&);

   };

   //---------------------------------------------------------------------------
   // EEPROM_Register_2
   //---------------------------------------------------------------------------
   class tEEPROM_Register_2 : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tCHInCh tRegisterMap;

      enum {
         kOffset = 0x58c,
         kId     = 13
      };
      tEEPROM_Register_2();


      typedef enum {
         kRegisterId                          = 0,
         kEEPROM_Register_2_ValueId        = 1,
         kMaxFieldId                          = 1
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Register Accessors (Compile-time selectable)

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline void writeEEPROM_Register_2_Value(nCHInCh::tEEPROM_Register_2_Value_t fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline nCHInCh::tEEPROM_Register_2_Value_t readEEPROM_Register_2_Value(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      tRegisterMap* _regMap;

      // Usage guidelines
      tEEPROM_Register_2(const tEEPROM_Register_2&);
      tEEPROM_Register_2& operator=(const tEEPROM_Register_2&);

   };

   //---------------------------------------------------------------------------
   // SMIO_Register_0
   //---------------------------------------------------------------------------
   class tSMIO_Register_0 : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tCHInCh tRegisterMap;

      enum {
         kOffset = 0x590,
         kId     = 14
      };
      tSMIO_Register_0();


      typedef enum {
         kRegisterId                          = 0,
         kSMIO_Register_0_ValueId          = 1,
         kMaxFieldId                          = 1
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Register Accessors (Compile-time selectable)

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline void writeSMIO_Register_0_Value(nCHInCh::tSMIO_Register_0_Value_t fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline nCHInCh::tSMIO_Register_0_Value_t readSMIO_Register_0_Value(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      tRegisterMap* _regMap;

      // Usage guidelines
      tSMIO_Register_0(const tSMIO_Register_0&);
      tSMIO_Register_0& operator=(const tSMIO_Register_0&);

   };

   //---------------------------------------------------------------------------
   // SMIO_Register_1
   //---------------------------------------------------------------------------
   class tSMIO_Register_1 : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tCHInCh tRegisterMap;

      enum {
         kOffset = 0x594,
         kId     = 15
      };
      tSMIO_Register_1();


      typedef enum {
         kRegisterId                          = 0,
         kSMIO_Register_1_ValueId          = 1,
         kMaxFieldId                          = 1
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Register Accessors (Compile-time selectable)

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline void writeSMIO_Register_1_Value(nCHInCh::tSMIO_Register_1_Value_t fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline nCHInCh::tSMIO_Register_1_Value_t readSMIO_Register_1_Value(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      tRegisterMap* _regMap;

      // Usage guidelines
      tSMIO_Register_1(const tSMIO_Register_1&);
      tSMIO_Register_1& operator=(const tSMIO_Register_1&);

   };

   //---------------------------------------------------------------------------
   // SMIO_Register_2
   //---------------------------------------------------------------------------
   class tSMIO_Register_2 : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tCHInCh tRegisterMap;

      enum {
         kOffset = 0x598,
         kId     = 16
      };
      tSMIO_Register_2();


      typedef enum {
         kRegisterId                          = 0,
         kSMIO_Register_2_ValueId          = 1,
         kMaxFieldId                          = 1
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Register Accessors (Compile-time selectable)

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline void writeSMIO_Register_2_Value(nCHInCh::tSMIO_Register_2_Value_t fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline nCHInCh::tSMIO_Register_2_Value_t readSMIO_Register_2_Value(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      tRegisterMap* _regMap;

      // Usage guidelines
      tSMIO_Register_2(const tSMIO_Register_2&);
      tSMIO_Register_2& operator=(const tSMIO_Register_2&);

   };

   //---------------------------------------------------------------------------
   // SMIO_Register_3
   //---------------------------------------------------------------------------
   class tSMIO_Register_3 : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tCHInCh tRegisterMap;

      enum {
         kOffset = 0x59c,
         kId     = 17
      };
      tSMIO_Register_3();


      typedef enum {
         kRegisterId                          = 0,
         kSMIO_Register_3_ValueId          = 1,
         kMaxFieldId                          = 1
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Register Accessors (Compile-time selectable)

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline void writeSMIO_Register_3_Value(nCHInCh::tSMIO_Register_3_Value_t fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline nCHInCh::tSMIO_Register_3_Value_t readSMIO_Register_3_Value(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      tRegisterMap* _regMap;

      // Usage guidelines
      tSMIO_Register_3(const tSMIO_Register_3&);
      tSMIO_Register_3& operator=(const tSMIO_Register_3&);

   };

   //---------------------------------------------------------------------------
   // PCI_SubSystem_ID_Access_Register
   //---------------------------------------------------------------------------
   class tPCI_SubSystem_ID_Access_Register : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tCHInCh tRegisterMap;

      enum {
         kOffset = 0x10ac,
         kId     = 18
      };
      tPCI_SubSystem_ID_Access_Register();


      typedef enum {
         kRegisterId                          = 0,
         kSubSystem_Vendor_IDId            = 1,
         kSubSystem_Product_IDId           = 2,
         kMaxFieldId                          = 2
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Register Accessors (Compile-time selectable)
      inline tPCI_SubSystem_ID_Access_Register& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void refresh(nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tPCI_SubSystem_ID_Access_Register& setSubSystem_Vendor_ID(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getSubSystem_Vendor_ID(nMDBG::tStatus2* statusChain = NULL) const;

      inline u32 readSubSystem_Vendor_ID(nMDBG::tStatus2* statusChain = NULL);

      inline tPCI_SubSystem_ID_Access_Register& setSubSystem_Product_ID(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getSubSystem_Product_ID(nMDBG::tStatus2* statusChain = NULL) const;

      inline u32 readSubSystem_Product_ID(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tPCI_SubSystem_ID_Access_Register(const tPCI_SubSystem_ID_Access_Register&);
      tPCI_SubSystem_ID_Access_Register& operator=(const tPCI_SubSystem_ID_Access_Register&);

   };

   //----------------------------------------
   // Register Array Sizes
   //----------------------------------------
   enum {
      kScrap_RegisterArraySize = 1
   };

   //---------------------------------------------------------------------------
   // CHInCh_Identification_Register
   //---------------------------------------------------------------------------
   tCHInCh_Identification_Register CHInCh_Identification_Register;

   //---------------------------------------------------------------------------
   // IO_Port_Resource_Description_Register
   //---------------------------------------------------------------------------
   tIO_Port_Resource_Description_Register IO_Port_Resource_Description_Register;

   //---------------------------------------------------------------------------
   // Interrupt_Mask_Register
   //---------------------------------------------------------------------------
   tInterrupt_Mask_Register Interrupt_Mask_Register;

   //---------------------------------------------------------------------------
   // Interrupt_Status_Register
   //---------------------------------------------------------------------------
   tInterrupt_Status_Register Interrupt_Status_Register;

   //---------------------------------------------------------------------------
   // Volatile_Interrupt_Status_Register
   //---------------------------------------------------------------------------
   tVolatile_Interrupt_Status_Register Volatile_Interrupt_Status_Register;

   //---------------------------------------------------------------------------
   // Host_Bus_Resource_Control_Register
   //---------------------------------------------------------------------------
   tHost_Bus_Resource_Control_Register Host_Bus_Resource_Control_Register;

   //---------------------------------------------------------------------------
   // EEPROM_Window_Register
   //---------------------------------------------------------------------------
   tEEPROM_Window_Register EEPROM_Window_Register;

   //---------------------------------------------------------------------------
   // Simultaneous_Window_Register
   //---------------------------------------------------------------------------
   tSimultaneous_Window_Register Simultaneous_Window_Register;

   //---------------------------------------------------------------------------
   // Window_Control_Register
   //---------------------------------------------------------------------------
   tWindow_Control_Register Window_Control_Register;

   //---------------------------------------------------------------------------
   // Scrap_Register
   //---------------------------------------------------------------------------
   tScrap_Register_t Scrap_Register[kScrap_RegisterArraySize];

   //---------------------------------------------------------------------------
   // Configuration_Register
   //---------------------------------------------------------------------------
   tConfiguration_Register Configuration_Register;

   //---------------------------------------------------------------------------
   // EEPROM_Register_0
   //---------------------------------------------------------------------------
   tEEPROM_Register_0 EEPROM_Register_0;

   //---------------------------------------------------------------------------
   // EEPROM_Register_1
   //---------------------------------------------------------------------------
   tEEPROM_Register_1 EEPROM_Register_1;

   //---------------------------------------------------------------------------
   // EEPROM_Register_2
   //---------------------------------------------------------------------------
   tEEPROM_Register_2 EEPROM_Register_2;

   //---------------------------------------------------------------------------
   // SMIO_Register_0
   //---------------------------------------------------------------------------
   tSMIO_Register_0 SMIO_Register_0;

   //---------------------------------------------------------------------------
   // SMIO_Register_1
   //---------------------------------------------------------------------------
   tSMIO_Register_1 SMIO_Register_1;

   //---------------------------------------------------------------------------
   // SMIO_Register_2
   //---------------------------------------------------------------------------
   tSMIO_Register_2 SMIO_Register_2;

   //---------------------------------------------------------------------------
   // SMIO_Register_3
   //---------------------------------------------------------------------------
   tSMIO_Register_3 SMIO_Register_3;

   //---------------------------------------------------------------------------
   // PCI_SubSystem_ID_Access_Register
   //---------------------------------------------------------------------------
   tPCI_SubSystem_ID_Access_Register PCI_SubSystem_ID_Access_Register;

   //---------------------------------------------------------------------------
   // Register Groups
   //---------------------------------------------------------------------------

   //----------------------------------------
   // Register/Field Ids
   //----------------------------------------
   typedef enum {
      kCHInCh_Identification_RegisterId   = 0,
      kIDId                             = nNIMXRegisterMap120_mBuildFieldId(tCHInCh_Identification_Register::kIDId, kCHInCh_Identification_RegisterId),

      kIO_Port_Resource_Description_RegisterId          = 1,
      kIOMPSId                          = nNIMXRegisterMap120_mBuildFieldId(tIO_Port_Resource_Description_Register::kIOMPSId, kIO_Port_Resource_Description_RegisterId),

      kInterrupt_Mask_RegisterId        = 2,
      kClear_SMIO_FIFO_IntId            = nNIMXRegisterMap120_mBuildFieldId(tInterrupt_Mask_Register::kClear_SMIO_FIFO_IntId, kInterrupt_Mask_RegisterId),
      kSet_SMIO_FIFO_IntId              = nNIMXRegisterMap120_mBuildFieldId(tInterrupt_Mask_Register::kSet_SMIO_FIFO_IntId, kInterrupt_Mask_RegisterId),
      kClear_STC3_IntId                 = nNIMXRegisterMap120_mBuildFieldId(tInterrupt_Mask_Register::kClear_STC3_IntId, kInterrupt_Mask_RegisterId),
      kSet_STC3_IntId                   = nNIMXRegisterMap120_mBuildFieldId(tInterrupt_Mask_Register::kSet_STC3_IntId, kInterrupt_Mask_RegisterId),
      kClear_CPU_IntId                  = nNIMXRegisterMap120_mBuildFieldId(tInterrupt_Mask_Register::kClear_CPU_IntId, kInterrupt_Mask_RegisterId),
      kSet_CPU_IntId                    = nNIMXRegisterMap120_mBuildFieldId(tInterrupt_Mask_Register::kSet_CPU_IntId, kInterrupt_Mask_RegisterId),

      kInterrupt_Status_RegisterId      = 3,
      kSMIO_FIFO_IntId                  = nNIMXRegisterMap120_mBuildFieldId(tInterrupt_Status_Register::kSMIO_FIFO_IntId, kInterrupt_Status_RegisterId),
      kSTC3_IntId                       = nNIMXRegisterMap120_mBuildFieldId(tInterrupt_Status_Register::kSTC3_IntId, kInterrupt_Status_RegisterId),
      kDMAId                            = nNIMXRegisterMap120_mBuildFieldId(tInterrupt_Status_Register::kDMAId, kInterrupt_Status_RegisterId),
      kExternalId                       = nNIMXRegisterMap120_mBuildFieldId(tInterrupt_Status_Register::kExternalId, kInterrupt_Status_RegisterId),
      kAdditional_IntId                 = nNIMXRegisterMap120_mBuildFieldId(tInterrupt_Status_Register::kAdditional_IntId, kInterrupt_Status_RegisterId),
      kIntId                            = nNIMXRegisterMap120_mBuildFieldId(tInterrupt_Status_Register::kIntId, kInterrupt_Status_RegisterId),

      kVolatile_Interrupt_Status_RegisterId       = 4,
      kVol_SMIO_FIFO_IntId              = nNIMXRegisterMap120_mBuildFieldId(tVolatile_Interrupt_Status_Register::kVol_SMIO_FIFO_IntId, kVolatile_Interrupt_Status_RegisterId),
      kVol_STC3_IntId                   = nNIMXRegisterMap120_mBuildFieldId(tVolatile_Interrupt_Status_Register::kVol_STC3_IntId, kVolatile_Interrupt_Status_RegisterId),
      kVol_DMAId                        = nNIMXRegisterMap120_mBuildFieldId(tVolatile_Interrupt_Status_Register::kVol_DMAId, kVolatile_Interrupt_Status_RegisterId),
      kVol_ExternalId                   = nNIMXRegisterMap120_mBuildFieldId(tVolatile_Interrupt_Status_Register::kVol_ExternalId, kVolatile_Interrupt_Status_RegisterId),
      kVol_Additional_IntId             = nNIMXRegisterMap120_mBuildFieldId(tVolatile_Interrupt_Status_Register::kVol_Additional_IntId, kVolatile_Interrupt_Status_RegisterId),
      kVol_IntId                        = nNIMXRegisterMap120_mBuildFieldId(tVolatile_Interrupt_Status_Register::kVol_IntId, kVolatile_Interrupt_Status_RegisterId),

      kHost_Bus_Resource_Control_RegisterId       = 5,
      kDMA_MA64Id                       = nNIMXRegisterMap120_mBuildFieldId(tHost_Bus_Resource_Control_Register::kDMA_MA64Id, kHost_Bus_Resource_Control_RegisterId),
      kDMA_LA64Id                       = nNIMXRegisterMap120_mBuildFieldId(tHost_Bus_Resource_Control_Register::kDMA_LA64Id, kHost_Bus_Resource_Control_RegisterId),
      kIO_Master_EnableId               = nNIMXRegisterMap120_mBuildFieldId(tHost_Bus_Resource_Control_Register::kIO_Master_EnableId, kHost_Bus_Resource_Control_RegisterId),

      kEEPROM_Window_RegisterId         = 6,
      kEEPROM_Window_FieldId            = nNIMXRegisterMap120_mBuildFieldId(tEEPROM_Window_Register::kEEPROM_Window_FieldId, kEEPROM_Window_RegisterId),

      kSimultaneous_Window_RegisterId   = 7,
      kSimultaneous_Window_FieldId      = nNIMXRegisterMap120_mBuildFieldId(tSimultaneous_Window_Register::kSimultaneous_Window_FieldId, kSimultaneous_Window_RegisterId),

      kWindow_Control_RegisterId        = 8,
      kWindow_Control_FieldId           = nNIMXRegisterMap120_mBuildFieldId(tWindow_Control_Register::kWindow_Control_FieldId, kWindow_Control_RegisterId),

      kScrap_Register0Id                = 9,
      kScrap0SDATAId                    = nNIMXRegisterMap120_mBuildFieldId(tScrap_Register_t::kSDATAId, kScrap_Register0Id),

      kConfiguration_RegisterId         = 10,
      kConfiguration_ValueId            = nNIMXRegisterMap120_mBuildFieldId(tConfiguration_Register::kConfiguration_ValueId, kConfiguration_RegisterId),

      kEEPROM_Register_0Id              = 11,
      kEEPROM_Register_0_ValueId        = nNIMXRegisterMap120_mBuildFieldId(tEEPROM_Register_0::kEEPROM_Register_0_ValueId, kEEPROM_Register_0Id),

      kEEPROM_Register_1Id              = 12,
      kEEPROM_Register_1_ValueId        = nNIMXRegisterMap120_mBuildFieldId(tEEPROM_Register_1::kEEPROM_Register_1_ValueId, kEEPROM_Register_1Id),

      kEEPROM_Register_2Id              = 13,
      kEEPROM_Register_2_ValueId        = nNIMXRegisterMap120_mBuildFieldId(tEEPROM_Register_2::kEEPROM_Register_2_ValueId, kEEPROM_Register_2Id),

      kSMIO_Register_0Id                = 14,
      kSMIO_Register_0_ValueId          = nNIMXRegisterMap120_mBuildFieldId(tSMIO_Register_0::kSMIO_Register_0_ValueId, kSMIO_Register_0Id),

      kSMIO_Register_1Id                = 15,
      kSMIO_Register_1_ValueId          = nNIMXRegisterMap120_mBuildFieldId(tSMIO_Register_1::kSMIO_Register_1_ValueId, kSMIO_Register_1Id),

      kSMIO_Register_2Id                = 16,
      kSMIO_Register_2_ValueId          = nNIMXRegisterMap120_mBuildFieldId(tSMIO_Register_2::kSMIO_Register_2_ValueId, kSMIO_Register_2Id),

      kSMIO_Register_3Id                = 17,
      kSMIO_Register_3_ValueId          = nNIMXRegisterMap120_mBuildFieldId(tSMIO_Register_3::kSMIO_Register_3_ValueId, kSMIO_Register_3Id),

      kPCI_SubSystem_ID_Access_RegisterId     = 18,
      kSubSystem_Vendor_IDId            = nNIMXRegisterMap120_mBuildFieldId(tPCI_SubSystem_ID_Access_Register::kSubSystem_Vendor_IDId, kPCI_SubSystem_ID_Access_RegisterId),
      kSubSystem_Product_IDId           = nNIMXRegisterMap120_mBuildFieldId(tPCI_SubSystem_ID_Access_Register::kSubSystem_Product_IDId, kPCI_SubSystem_ID_Access_RegisterId),


      kMaxRegisterId = 18

   } tId;

   tCHInCh(tBusSpaceReference addrSpace, nMDBG::tStatus2* statusChain = NULL);
   tCHInCh();
   void initialize(tBusSpaceReference addrSpace, u32 addressOffset, nMDBG::tStatus2* statusChain = NULL);
   void reset(nMDBG::tStatus2* statusChain = NULL);
   virtual ~tCHInCh();

   inline tBusSpaceReference getBusSpaceReference(void) const;

   inline void setAddressOffset(u32 value, nMDBG::tStatus2* statusChain = NULL);
   inline u32  getAddressOffset(nMDBG::tStatus2* statusChain = NULL);
   inline tBoolean isDirty(tId id, nMDBG::tStatus2* statusChain = NULL);
   inline void markDirty(tId id, nMDBG::tStatus2* statusChain = NULL);
   inline void markClean(tId id, nMDBG::tStatus2* statusChain = NULL);

   inline void markDirty(nMDBG::tStatus2* statusChain = NULL);
   inline void markClean(nMDBG::tStatus2* statusChain = NULL);

private:
   void _initialize(nMDBG::tStatus2* statusChain = NULL);
   tBusSpaceReference _addrSpace;
   u32 _addressOffset;
   u8 _dirtyVector[19];

};

#ifndef ___tCHInCh_ipp___
#ifndef ___tCHInCh_h_no_inline___
#include "tCHInCh.ipp"
#endif

#endif

#endif


// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// This file is autogenerated!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!

