// Copyright 2011 National Instruments
// License: NATIONAL INSTRUMENTS SOFTWARE LICENSE AGREEMENT
//   Refer to "MHDDK License Agreement.pdf" in the root of this distribution.

// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// This file is autogenerated!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!

#ifndef ___tCounter_h___
#define ___tCounter_h___

// includes
#include "osiTypes.h"
#include "osiBus.h"
#include "tCounterValues.h"


#ifndef ___tCounterValues_h___
#include "tCounterValues.h"
#endif

#ifndef nNIMXRegisterMap120_mBuildFieldId

// Algorithm:
//    Move lowermost 5 bits (4 through 0) of field id to uppermost 5 bits (31
//          through 27)
//    Move bit 5 of field id to bit 26
//    Move bit 6 of field id to bit 25
//    OR in the register id (which is allowed the remaining bits)
//
// Why not move the lowermost 7 bits directly to the uppermost 7 bits? Because
// we originally moved only the lowermost 5, and for backwards compatibility,
// we can't change where those 5 bits end up.
//
// For future expansion purposes, the bits beyond the first 5 are put in reverse
// order in the resulting combined id.
#define nNIMXRegisterMap120_mBuildFieldId(fieldId, regId) \
   ( \
     ((fieldId) << 27) | \
     ((((fieldId) >> 5) & 0x1) << 26) | \
     ((((fieldId) >> 6) & 0x1) << 25) | \
     (regId) \
   )

#endif

#ifndef nNIMXRegisterMap120_mExtractFieldId

// Algorithm: (basically the reverse of mBuildFieldId)
//    Move uppermost 5 bits (31 through 27) to lowermost 5 bits (4 through 0)
//    Move 26th bit to bit 5 (right-shifting by (26 - 5) is like right-shifting
//          by 26 then left-shifting by 5, but it's more efficient)
//    Move 25th bit to bit 6
#define nNIMXRegisterMap120_mExtractFieldId(id) \
   (unsigned int) \
   ( \
     (((id) >> 27) & 0x1F) | \
     (((id) & (0x1 << 26)) >> (26 - 5)) | \
     (((id) & (0x1 << 25)) >> (25 - 6)) \
   )

#endif

class tCounter
{
public:
   //---------------------------------------------------------------------------
   // IO Strategies
   //---------------------------------------------------------------------------
   class tReg16IODirect32
   {
   public:
      inline void write(
         tBusSpaceReference addrSpace,
         u32 offset,
         u16 value,
         nMDBG::tStatus2* statusChain = NULL);

      inline u16 read(
         tBusSpaceReference addrSpace,
         u32 offset,
         nMDBG::tStatus2* statusChain = NULL);
   };

   class tReg32IODirect32
   {
   public:
      inline void write(
         tBusSpaceReference addrSpace,
         u32 offset,
         u32 value,
         nMDBG::tStatus2* statusChain = NULL);

      inline u32 read(
         tBusSpaceReference addrSpace,
         u32 offset,
         nMDBG::tStatus2* statusChain = NULL);
   };

   //---------------------------------------------------------------------------
   // Gi_Command_Register
   //---------------------------------------------------------------------------
   class tGi_Command_Register : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tCounter tRegisterMap;

      enum {
         kOffset = 0x0,
         kId     = 0
      };
      tGi_Command_Register();


      typedef enum {
         kRegisterId                          = 0,
         kGi_ArmId                         = 1,
         kGi_LoadId                        = 3,
         kGi_DisarmId                      = 5,
         kGi_WrLoadRegsFromFifoId          = 7,
         kGi_Bank_Switch_StartId           = 9,
         kGi_Arm_Paired_CounterId          = 11,
         kGi_ResetId                       = 12,
         kGi_Disarm_Paired_CounterId       = 13,
         kMaxFieldId                          = 13
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Dirty Tracking
      inline tBoolean isDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markClean(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tGi_Command_Register& setRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline void writeRegister(u16 value, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u16 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tGi_Command_Register& setGi_Arm(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getGi_Arm(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeGi_Arm(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u16 readGi_Arm(nMDBG::tStatus2* statusChain = NULL);

      inline tGi_Command_Register& setGi_Load(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getGi_Load(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeGi_Load(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u16 readGi_Load(nMDBG::tStatus2* statusChain = NULL);

      inline tGi_Command_Register& setGi_Disarm(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getGi_Disarm(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeGi_Disarm(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u16 readGi_Disarm(nMDBG::tStatus2* statusChain = NULL);

      inline tGi_Command_Register& setGi_WrLoadRegsFromFifo(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getGi_WrLoadRegsFromFifo(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeGi_WrLoadRegsFromFifo(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u16 readGi_WrLoadRegsFromFifo(nMDBG::tStatus2* statusChain = NULL);

      inline tGi_Command_Register& setGi_Bank_Switch_Start(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getGi_Bank_Switch_Start(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeGi_Bank_Switch_Start(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u16 readGi_Bank_Switch_Start(nMDBG::tStatus2* statusChain = NULL);

      inline tGi_Command_Register& setGi_Arm_Paired_Counter(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getGi_Arm_Paired_Counter(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeGi_Arm_Paired_Counter(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u16 readGi_Arm_Paired_Counter(nMDBG::tStatus2* statusChain = NULL);

      inline tGi_Command_Register& setGi_Reset(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getGi_Reset(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeGi_Reset(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u16 readGi_Reset(nMDBG::tStatus2* statusChain = NULL);

      inline tGi_Command_Register& setGi_Disarm_Paired_Counter(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getGi_Disarm_Paired_Counter(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeGi_Disarm_Paired_Counter(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u16 readGi_Disarm_Paired_Counter(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u16 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tGi_Command_Register(const tGi_Command_Register&);
      tGi_Command_Register& operator=(const tGi_Command_Register&);

   };

   //---------------------------------------------------------------------------
   // Gi_Mode_Register
   //---------------------------------------------------------------------------
   class tGi_Mode_Register : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tCounter tRegisterMap;

      enum {
         kOffset = 0x2,
         kId     = 1
      };
      tGi_Mode_Register();


      typedef enum {
         kRegisterId                          = 0,
         kGi_Gating_ModeId                 = 1,
         kGi_Gate_On_Both_EdgesId          = 2,
         kGi_Trigger_Mode_For_Edge_GateId  = 3,
         kGi_Stop_ModeId                   = 4,
         kGi_Load_Source_SelectId          = 5,
         kGi_Output_ModeId                 = 6,
         kGi_Counting_OnceId               = 7,
         kGi_Loading_On_TCId               = 8,
         kGi_ForceSourceEqualToTimebaseId  = 9,
         kGi_Loading_On_GateId             = 10,
         kGi_Reload_Source_SwitchingId     = 11,
         kMaxFieldId                          = 11
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Dirty Tracking
      inline tBoolean isDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markClean(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tGi_Mode_Register& setRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline void writeRegister(u16 value, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u16 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tGi_Mode_Register& setGi_Gating_Mode(nCounter::tGi_GatingMode_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nCounter::tGi_GatingMode_t getGi_Gating_Mode(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeGi_Gating_Mode(nCounter::tGi_GatingMode_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nCounter::tGi_GatingMode_t readGi_Gating_Mode(nMDBG::tStatus2* statusChain = NULL);

      inline tGi_Mode_Register& setGi_Gate_On_Both_Edges(nCounter::tGi_Disabled_Enabled_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nCounter::tGi_Disabled_Enabled_t getGi_Gate_On_Both_Edges(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeGi_Gate_On_Both_Edges(nCounter::tGi_Disabled_Enabled_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nCounter::tGi_Disabled_Enabled_t readGi_Gate_On_Both_Edges(nMDBG::tStatus2* statusChain = NULL);

      inline tGi_Mode_Register& setGi_Trigger_Mode_For_Edge_Gate(nCounter::tGi_Trigger_Mode_For_Edge_Gate_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nCounter::tGi_Trigger_Mode_For_Edge_Gate_t getGi_Trigger_Mode_For_Edge_Gate(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeGi_Trigger_Mode_For_Edge_Gate(nCounter::tGi_Trigger_Mode_For_Edge_Gate_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nCounter::tGi_Trigger_Mode_For_Edge_Gate_t readGi_Trigger_Mode_For_Edge_Gate(nMDBG::tStatus2* statusChain = NULL);

      inline tGi_Mode_Register& setGi_Stop_Mode(nCounter::tGi_Stop_Mode_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nCounter::tGi_Stop_Mode_t getGi_Stop_Mode(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeGi_Stop_Mode(nCounter::tGi_Stop_Mode_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nCounter::tGi_Stop_Mode_t readGi_Stop_Mode(nMDBG::tStatus2* statusChain = NULL);

      inline tGi_Mode_Register& setGi_Load_Source_Select(nCounter::tGi_Load_Source_Select_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nCounter::tGi_Load_Source_Select_t getGi_Load_Source_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeGi_Load_Source_Select(nCounter::tGi_Load_Source_Select_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nCounter::tGi_Load_Source_Select_t readGi_Load_Source_Select(nMDBG::tStatus2* statusChain = NULL);

      inline tGi_Mode_Register& setGi_Output_Mode(nCounter::tGi_Output_Mode_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nCounter::tGi_Output_Mode_t getGi_Output_Mode(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeGi_Output_Mode(nCounter::tGi_Output_Mode_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nCounter::tGi_Output_Mode_t readGi_Output_Mode(nMDBG::tStatus2* statusChain = NULL);

      inline tGi_Mode_Register& setGi_Counting_Once(nCounter::tGi_Counting_Once_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nCounter::tGi_Counting_Once_t getGi_Counting_Once(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeGi_Counting_Once(nCounter::tGi_Counting_Once_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nCounter::tGi_Counting_Once_t readGi_Counting_Once(nMDBG::tStatus2* statusChain = NULL);

      inline tGi_Mode_Register& setGi_Loading_On_TC(nCounter::tGi_Loading_On_TC_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nCounter::tGi_Loading_On_TC_t getGi_Loading_On_TC(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeGi_Loading_On_TC(nCounter::tGi_Loading_On_TC_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nCounter::tGi_Loading_On_TC_t readGi_Loading_On_TC(nMDBG::tStatus2* statusChain = NULL);

      inline tGi_Mode_Register& setGi_ForceSourceEqualToTimebase(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getGi_ForceSourceEqualToTimebase(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeGi_ForceSourceEqualToTimebase(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u16 readGi_ForceSourceEqualToTimebase(nMDBG::tStatus2* statusChain = NULL);

      inline tGi_Mode_Register& setGi_Loading_On_Gate(nCounter::tGi_Loading_On_Gate_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nCounter::tGi_Loading_On_Gate_t getGi_Loading_On_Gate(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeGi_Loading_On_Gate(nCounter::tGi_Loading_On_Gate_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nCounter::tGi_Loading_On_Gate_t readGi_Loading_On_Gate(nMDBG::tStatus2* statusChain = NULL);

      inline tGi_Mode_Register& setGi_Reload_Source_Switching(nCounter::tGi_Reload_Source_Switching_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nCounter::tGi_Reload_Source_Switching_t getGi_Reload_Source_Switching(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeGi_Reload_Source_Switching(nCounter::tGi_Reload_Source_Switching_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nCounter::tGi_Reload_Source_Switching_t readGi_Reload_Source_Switching(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u16 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tGi_Mode_Register(const tGi_Mode_Register&);
      tGi_Mode_Register& operator=(const tGi_Mode_Register&);

   };

   //---------------------------------------------------------------------------
   // Gi_HW_Save_Register
   //---------------------------------------------------------------------------
   class tGi_HW_Save_Register : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tCounter tRegisterMap;

      enum {
         kOffset = 0x4,
         kId     = 2
      };
      tGi_HW_Save_Register();


      typedef enum {
         kRegisterId                          = 0,
         kGi_HW_Save_ValueId               = 1,
         kMaxFieldId                          = 1
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Register Accessors (Compile-time selectable)
      inline tGi_HW_Save_Register& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void refresh(nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tGi_HW_Save_Register& setGi_HW_Save_Value(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getGi_HW_Save_Value(nMDBG::tStatus2* statusChain = NULL) const;

      inline u32 readGi_HW_Save_Value(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tGi_HW_Save_Register(const tGi_HW_Save_Register&);
      tGi_HW_Save_Register& operator=(const tGi_HW_Save_Register&);

   };

   //---------------------------------------------------------------------------
   // Gi_Load_A_Register
   //---------------------------------------------------------------------------
   class tGi_Load_A_Register : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tCounter tRegisterMap;

      enum {
         kOffset = 0x4,
         kId     = 3
      };
      tGi_Load_A_Register();


      typedef enum {
         kRegisterId                          = 0,
         kGi_Load_AId                      = 1,
         kMaxFieldId                          = 1
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Dirty Tracking
      inline tBoolean isDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markClean(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tGi_Load_A_Register& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tGi_Load_A_Register& setGi_Load_A(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getGi_Load_A(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeGi_Load_A(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u32 readGi_Load_A(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tGi_Load_A_Register(const tGi_Load_A_Register&);
      tGi_Load_A_Register& operator=(const tGi_Load_A_Register&);

   };

   //---------------------------------------------------------------------------
   // Gi_Load_B_Register
   //---------------------------------------------------------------------------
   class tGi_Load_B_Register : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tCounter tRegisterMap;

      enum {
         kOffset = 0x8,
         kId     = 4
      };
      tGi_Load_B_Register();


      typedef enum {
         kRegisterId                          = 0,
         kGi_Load_BId                      = 1,
         kMaxFieldId                          = 1
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Dirty Tracking
      inline tBoolean isDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markClean(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tGi_Load_B_Register& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tGi_Load_B_Register& setGi_Load_B(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getGi_Load_B(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeGi_Load_B(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u32 readGi_Load_B(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tGi_Load_B_Register(const tGi_Load_B_Register&);
      tGi_Load_B_Register& operator=(const tGi_Load_B_Register&);

   };

   //---------------------------------------------------------------------------
   // Gi_Save_Register
   //---------------------------------------------------------------------------
   class tGi_Save_Register : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tCounter tRegisterMap;

      enum {
         kOffset = 0x8,
         kId     = 5
      };
      tGi_Save_Register();


      typedef enum {
         kRegisterId                          = 0,
         kGi_Save_ValueId                  = 1,
         kMaxFieldId                          = 1
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Register Accessors (Compile-time selectable)
      inline tGi_Save_Register& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void refresh(nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tGi_Save_Register& setGi_Save_Value(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getGi_Save_Value(nMDBG::tStatus2* statusChain = NULL) const;

      inline u32 readGi_Save_Value(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tGi_Save_Register(const tGi_Save_Register&);
      tGi_Save_Register& operator=(const tGi_Save_Register&);

   };

   //---------------------------------------------------------------------------
   // Gi_Input_Select_Register
   //---------------------------------------------------------------------------
   class tGi_Input_Select_Register : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tCounter tRegisterMap;

      enum {
         kOffset = 0xc,
         kId     = 6
      };
      tGi_Input_Select_Register();


      typedef enum {
         kRegisterId                          = 0,
         kGi_Gate_PolarityId               = 1,
         kGi_Source_SelectId               = 2,
         kGi_Gate_SelectId                 = 3,
         kGi_Gate_Select_Load_SourceId     = 4,
         kGi_Output_PolarityId             = 5,
         kGi_Source_PolarityId             = 6,
         kMaxFieldId                          = 6
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Dirty Tracking
      inline tBoolean isDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markClean(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tGi_Input_Select_Register& setRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline void writeRegister(u16 value, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u16 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tGi_Input_Select_Register& setGi_Gate_Polarity(nCounter::tGi_Polarity_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nCounter::tGi_Polarity_t getGi_Gate_Polarity(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeGi_Gate_Polarity(nCounter::tGi_Polarity_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nCounter::tGi_Polarity_t readGi_Gate_Polarity(nMDBG::tStatus2* statusChain = NULL);

      inline tGi_Input_Select_Register& setGi_Source_Select(nCounter::tGi_Source_Select_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nCounter::tGi_Source_Select_t getGi_Source_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeGi_Source_Select(nCounter::tGi_Source_Select_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nCounter::tGi_Source_Select_t readGi_Source_Select(nMDBG::tStatus2* statusChain = NULL);

      inline tGi_Input_Select_Register& setGi_Gate_Select(nCounter::tGi_Gate_Select_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nCounter::tGi_Gate_Select_t getGi_Gate_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeGi_Gate_Select(nCounter::tGi_Gate_Select_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nCounter::tGi_Gate_Select_t readGi_Gate_Select(nMDBG::tStatus2* statusChain = NULL);

      inline tGi_Input_Select_Register& setGi_Gate_Select_Load_Source(nCounter::tGi_Disabled_Enabled_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nCounter::tGi_Disabled_Enabled_t getGi_Gate_Select_Load_Source(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeGi_Gate_Select_Load_Source(nCounter::tGi_Disabled_Enabled_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nCounter::tGi_Disabled_Enabled_t readGi_Gate_Select_Load_Source(nMDBG::tStatus2* statusChain = NULL);

      inline tGi_Input_Select_Register& setGi_Output_Polarity(nCounter::tGi_Polarity_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nCounter::tGi_Polarity_t getGi_Output_Polarity(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeGi_Output_Polarity(nCounter::tGi_Polarity_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nCounter::tGi_Polarity_t readGi_Output_Polarity(nMDBG::tStatus2* statusChain = NULL);

      inline tGi_Input_Select_Register& setGi_Source_Polarity(nCounter::tGi_Polarity_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nCounter::tGi_Polarity_t getGi_Source_Polarity(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeGi_Source_Polarity(nCounter::tGi_Polarity_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nCounter::tGi_Polarity_t readGi_Source_Polarity(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u16 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tGi_Input_Select_Register(const tGi_Input_Select_Register&);
      tGi_Input_Select_Register& operator=(const tGi_Input_Select_Register&);

   };

   //---------------------------------------------------------------------------
   // Gi_Status_Register
   //---------------------------------------------------------------------------
   class tGi_Status_Register : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tCounter tRegisterMap;

      enum {
         kOffset = 0xc,
         kId     = 7
      };
      tGi_Status_Register();


      typedef enum {
         kRegisterId                          = 0,
         kGi_Output_StId                   = 1,
         kGi_Counting_StId                 = 3,
         kGi_Next_Load_Source_StId         = 5,
         kGi_Armed_StId                    = 7,
         kGi_No_Load_Between_Gates_StId    = 9,
         kGi_DRQ_ErrorId                   = 10,
         kGi_TC_Error_StId                 = 11,
         kGi_Gate_Error_StId               = 13,
         kGi_DRQ_StId                      = 14,
         kGi_SampleClockOverrun_StId       = 15,
         kGi_SampleClockInterruptStId      = 16,
         kGi_Bank_StId                     = 17,
         kGi_Gate_StId                     = 19,
         kGi_Gate_Interrupt_StId           = 21,
         kGi_TC_StId                       = 22,
         kGi_GateSwitchError_StId          = 23,
         kGi_DisarmEventInterruptStId      = 24,
         kGi_ForcedWrFromFifoInProgStId    = 25,
         kGi_WritesTooFastErrorStId        = 26,
         kGi_AuxTC_ErrorEventStId          = 27,
         kGi_AuxTC_EventStId               = 28,
         kMaxFieldId                          = 28
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Register Accessors (Compile-time selectable)
      inline tGi_Status_Register& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void refresh(nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tGi_Status_Register& setGi_Output_St(nCounter::tGi_Output_St_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nCounter::tGi_Output_St_t getGi_Output_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline nCounter::tGi_Output_St_t readGi_Output_St(nMDBG::tStatus2* statusChain = NULL);

      inline tGi_Status_Register& setGi_Counting_St(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getGi_Counting_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u32 readGi_Counting_St(nMDBG::tStatus2* statusChain = NULL);

      inline tGi_Status_Register& setGi_Next_Load_Source_St(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getGi_Next_Load_Source_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u32 readGi_Next_Load_Source_St(nMDBG::tStatus2* statusChain = NULL);

      inline tGi_Status_Register& setGi_Armed_St(nCounter::tGi_Armed_St_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nCounter::tGi_Armed_St_t getGi_Armed_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline nCounter::tGi_Armed_St_t readGi_Armed_St(nMDBG::tStatus2* statusChain = NULL);

      inline tGi_Status_Register& setGi_No_Load_Between_Gates_St(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getGi_No_Load_Between_Gates_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u32 readGi_No_Load_Between_Gates_St(nMDBG::tStatus2* statusChain = NULL);

      inline tGi_Status_Register& setGi_DRQ_Error(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getGi_DRQ_Error(nMDBG::tStatus2* statusChain = NULL) const;

      inline u32 readGi_DRQ_Error(nMDBG::tStatus2* statusChain = NULL);

      inline tGi_Status_Register& setGi_TC_Error_St(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getGi_TC_Error_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u32 readGi_TC_Error_St(nMDBG::tStatus2* statusChain = NULL);

      inline tGi_Status_Register& setGi_Gate_Error_St(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getGi_Gate_Error_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u32 readGi_Gate_Error_St(nMDBG::tStatus2* statusChain = NULL);

      inline tGi_Status_Register& setGi_DRQ_St(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getGi_DRQ_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u32 readGi_DRQ_St(nMDBG::tStatus2* statusChain = NULL);

      inline tGi_Status_Register& setGi_SampleClockOverrun_St(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getGi_SampleClockOverrun_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u32 readGi_SampleClockOverrun_St(nMDBG::tStatus2* statusChain = NULL);

      inline tGi_Status_Register& setGi_SampleClockInterruptSt(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getGi_SampleClockInterruptSt(nMDBG::tStatus2* statusChain = NULL) const;

      inline u32 readGi_SampleClockInterruptSt(nMDBG::tStatus2* statusChain = NULL);

      inline tGi_Status_Register& setGi_Bank_St(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getGi_Bank_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u32 readGi_Bank_St(nMDBG::tStatus2* statusChain = NULL);

      inline tGi_Status_Register& setGi_Gate_St(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getGi_Gate_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u32 readGi_Gate_St(nMDBG::tStatus2* statusChain = NULL);

      inline tGi_Status_Register& setGi_Gate_Interrupt_St(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getGi_Gate_Interrupt_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u32 readGi_Gate_Interrupt_St(nMDBG::tStatus2* statusChain = NULL);

      inline tGi_Status_Register& setGi_TC_St(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getGi_TC_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u32 readGi_TC_St(nMDBG::tStatus2* statusChain = NULL);

      inline tGi_Status_Register& setGi_GateSwitchError_St(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getGi_GateSwitchError_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u32 readGi_GateSwitchError_St(nMDBG::tStatus2* statusChain = NULL);

      inline tGi_Status_Register& setGi_DisarmEventInterruptSt(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getGi_DisarmEventInterruptSt(nMDBG::tStatus2* statusChain = NULL) const;

      inline u32 readGi_DisarmEventInterruptSt(nMDBG::tStatus2* statusChain = NULL);

      inline tGi_Status_Register& setGi_ForcedWrFromFifoInProgSt(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getGi_ForcedWrFromFifoInProgSt(nMDBG::tStatus2* statusChain = NULL) const;

      inline u32 readGi_ForcedWrFromFifoInProgSt(nMDBG::tStatus2* statusChain = NULL);

      inline tGi_Status_Register& setGi_WritesTooFastErrorSt(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getGi_WritesTooFastErrorSt(nMDBG::tStatus2* statusChain = NULL) const;

      inline u32 readGi_WritesTooFastErrorSt(nMDBG::tStatus2* statusChain = NULL);

      inline tGi_Status_Register& setGi_AuxTC_ErrorEventSt(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getGi_AuxTC_ErrorEventSt(nMDBG::tStatus2* statusChain = NULL) const;

      inline u32 readGi_AuxTC_ErrorEventSt(nMDBG::tStatus2* statusChain = NULL);

      inline tGi_Status_Register& setGi_AuxTC_EventSt(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getGi_AuxTC_EventSt(nMDBG::tStatus2* statusChain = NULL) const;

      inline u32 readGi_AuxTC_EventSt(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tGi_Status_Register(const tGi_Status_Register&);
      tGi_Status_Register& operator=(const tGi_Status_Register&);

   };

   //---------------------------------------------------------------------------
   // Gi_Autoincrement_Register
   //---------------------------------------------------------------------------
   class tGi_Autoincrement_Register : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tCounter tRegisterMap;

      enum {
         kOffset = 0xe,
         kId     = 8
      };
      tGi_Autoincrement_Register();


      typedef enum {
         kRegisterId                          = 0,
         kGi_AutoincrementId               = 1,
         kMaxFieldId                          = 1
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Dirty Tracking
      inline tBoolean isDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markClean(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tGi_Autoincrement_Register& setRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline void writeRegister(u16 value, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u16 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tGi_Autoincrement_Register& setGi_Autoincrement(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getGi_Autoincrement(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeGi_Autoincrement(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u16 readGi_Autoincrement(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u16 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tGi_Autoincrement_Register(const tGi_Autoincrement_Register&);
      tGi_Autoincrement_Register& operator=(const tGi_Autoincrement_Register&);

   };

   //---------------------------------------------------------------------------
   // Gi_Counting_Mode_Register
   //---------------------------------------------------------------------------
   class tGi_Counting_Mode_Register : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tCounter tRegisterMap;

      enum {
         kOffset = 0x10,
         kId     = 9
      };
      tGi_Counting_Mode_Register();


      typedef enum {
         kRegisterId                          = 0,
         kGi_Counting_ModeId               = 1,
         kGi_HW_Arm_PolarityId             = 2,
         kGi_Index_ModeId                  = 3,
         kGi_Index_PhaseId                 = 4,
         kGi_HW_Arm_EnableId               = 5,
         kGi_HW_Arm_SelectId               = 6,
         kGi_PrescaleId                    = 7,
         kGi_Prescale_Div_2Id              = 8,
         kMaxFieldId                          = 8
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Dirty Tracking
      inline tBoolean isDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markClean(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tGi_Counting_Mode_Register& setRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline void writeRegister(u16 value, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u16 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tGi_Counting_Mode_Register& setGi_Counting_Mode(nCounter::tGi_CountingMode_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nCounter::tGi_CountingMode_t getGi_Counting_Mode(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeGi_Counting_Mode(nCounter::tGi_CountingMode_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nCounter::tGi_CountingMode_t readGi_Counting_Mode(nMDBG::tStatus2* statusChain = NULL);

      inline tGi_Counting_Mode_Register& setGi_HW_Arm_Polarity(nCounter::tGi_Polarity_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nCounter::tGi_Polarity_t getGi_HW_Arm_Polarity(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeGi_HW_Arm_Polarity(nCounter::tGi_Polarity_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nCounter::tGi_Polarity_t readGi_HW_Arm_Polarity(nMDBG::tStatus2* statusChain = NULL);

      inline tGi_Counting_Mode_Register& setGi_Index_Mode(nCounter::tGi_Index_Mode_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nCounter::tGi_Index_Mode_t getGi_Index_Mode(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeGi_Index_Mode(nCounter::tGi_Index_Mode_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nCounter::tGi_Index_Mode_t readGi_Index_Mode(nMDBG::tStatus2* statusChain = NULL);

      inline tGi_Counting_Mode_Register& setGi_Index_Phase(nCounter::tGi_Index_Phase_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nCounter::tGi_Index_Phase_t getGi_Index_Phase(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeGi_Index_Phase(nCounter::tGi_Index_Phase_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nCounter::tGi_Index_Phase_t readGi_Index_Phase(nMDBG::tStatus2* statusChain = NULL);

      inline tGi_Counting_Mode_Register& setGi_HW_Arm_Enable(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getGi_HW_Arm_Enable(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeGi_HW_Arm_Enable(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u16 readGi_HW_Arm_Enable(nMDBG::tStatus2* statusChain = NULL);

      inline tGi_Counting_Mode_Register& setGi_HW_Arm_Select(nCounter::tGi_HW_Arm_Select_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nCounter::tGi_HW_Arm_Select_t getGi_HW_Arm_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeGi_HW_Arm_Select(nCounter::tGi_HW_Arm_Select_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nCounter::tGi_HW_Arm_Select_t readGi_HW_Arm_Select(nMDBG::tStatus2* statusChain = NULL);

      inline tGi_Counting_Mode_Register& setGi_Prescale(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getGi_Prescale(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeGi_Prescale(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u16 readGi_Prescale(nMDBG::tStatus2* statusChain = NULL);

      inline tGi_Counting_Mode_Register& setGi_Prescale_Div_2(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getGi_Prescale_Div_2(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeGi_Prescale_Div_2(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u16 readGi_Prescale_Div_2(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u16 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tGi_Counting_Mode_Register(const tGi_Counting_Mode_Register&);
      tGi_Counting_Mode_Register& operator=(const tGi_Counting_Mode_Register&);

   };

   //---------------------------------------------------------------------------
   // Gi_FifoStatusRegister
   //---------------------------------------------------------------------------
   class tGi_FifoStatusRegister : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tCounter tRegisterMap;

      enum {
         kOffset = 0x10,
         kId     = 10
      };
      tGi_FifoStatusRegister();


      typedef enum {
         kRegisterId                          = 0,
         kGi_FifoStatusId                  = 1,
         kMaxFieldId                          = 1
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Register Accessors (Compile-time selectable)
      inline tGi_FifoStatusRegister& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void refresh(nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tGi_FifoStatusRegister& setGi_FifoStatus(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getGi_FifoStatus(nMDBG::tStatus2* statusChain = NULL) const;

      inline u32 readGi_FifoStatus(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tGi_FifoStatusRegister(const tGi_FifoStatusRegister&);
      tGi_FifoStatusRegister& operator=(const tGi_FifoStatusRegister&);

   };

   //---------------------------------------------------------------------------
   // Gi_Second_Gate_Register
   //---------------------------------------------------------------------------
   class tGi_Second_Gate_Register : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tCounter tRegisterMap;

      enum {
         kOffset = 0x12,
         kId     = 11
      };
      tGi_Second_Gate_Register();


      typedef enum {
         kRegisterId                          = 0,
         kGi_Second_Gate_ModeId            = 1,
         kGi_Second_Gate_SelectId          = 3,
         kGi_Second_Gate_PolarityId        = 4,
         kMaxFieldId                          = 4
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Dirty Tracking
      inline tBoolean isDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markClean(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tGi_Second_Gate_Register& setRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline void writeRegister(u16 value, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u16 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tGi_Second_Gate_Register& setGi_Second_Gate_Mode(nCounter::tGi_Second_Gate_Mode_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nCounter::tGi_Second_Gate_Mode_t getGi_Second_Gate_Mode(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeGi_Second_Gate_Mode(nCounter::tGi_Second_Gate_Mode_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nCounter::tGi_Second_Gate_Mode_t readGi_Second_Gate_Mode(nMDBG::tStatus2* statusChain = NULL);

      inline tGi_Second_Gate_Register& setGi_Second_Gate_Select(nCounter::tGi_Second_Gate_Select_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nCounter::tGi_Second_Gate_Select_t getGi_Second_Gate_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeGi_Second_Gate_Select(nCounter::tGi_Second_Gate_Select_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nCounter::tGi_Second_Gate_Select_t readGi_Second_Gate_Select(nMDBG::tStatus2* statusChain = NULL);

      inline tGi_Second_Gate_Register& setGi_Second_Gate_Polarity(nCounter::tGi_Polarity_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nCounter::tGi_Polarity_t getGi_Second_Gate_Polarity(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeGi_Second_Gate_Polarity(nCounter::tGi_Polarity_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nCounter::tGi_Polarity_t readGi_Second_Gate_Polarity(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u16 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tGi_Second_Gate_Register(const tGi_Second_Gate_Register&);
      tGi_Second_Gate_Register& operator=(const tGi_Second_Gate_Register&);

   };

   //---------------------------------------------------------------------------
   // Gi_DMA_Config_Register
   //---------------------------------------------------------------------------
   class tGi_DMA_Config_Register : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tCounter tRegisterMap;

      enum {
         kOffset = 0x14,
         kId     = 12
      };
      tGi_DMA_Config_Register();


      typedef enum {
         kRegisterId                          = 0,
         kGi_DMA_EnableId                  = 1,
         kGi_DMA_WriteId                   = 2,
         kGi_DMA_ResetId                   = 4,
         kGi_WaitForFirstEventOnGateId     = 6,
         kGi_WrFifoEnableId                = 8,
         kGi_DoneNotificationEnableId      = 9,
         kMaxFieldId                          = 9
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Dirty Tracking
      inline tBoolean isDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markClean(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tGi_DMA_Config_Register& setRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline void writeRegister(u16 value, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u16 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tGi_DMA_Config_Register& setGi_DMA_Enable(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getGi_DMA_Enable(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeGi_DMA_Enable(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u16 readGi_DMA_Enable(nMDBG::tStatus2* statusChain = NULL);

      inline tGi_DMA_Config_Register& setGi_DMA_Write(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getGi_DMA_Write(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeGi_DMA_Write(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u16 readGi_DMA_Write(nMDBG::tStatus2* statusChain = NULL);

      inline tGi_DMA_Config_Register& setGi_DMA_Reset(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getGi_DMA_Reset(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeGi_DMA_Reset(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u16 readGi_DMA_Reset(nMDBG::tStatus2* statusChain = NULL);

      inline tGi_DMA_Config_Register& setGi_WaitForFirstEventOnGate(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getGi_WaitForFirstEventOnGate(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeGi_WaitForFirstEventOnGate(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u16 readGi_WaitForFirstEventOnGate(nMDBG::tStatus2* statusChain = NULL);

      inline tGi_DMA_Config_Register& setGi_WrFifoEnable(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getGi_WrFifoEnable(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeGi_WrFifoEnable(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u16 readGi_WrFifoEnable(nMDBG::tStatus2* statusChain = NULL);

      inline tGi_DMA_Config_Register& setGi_DoneNotificationEnable(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getGi_DoneNotificationEnable(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeGi_DoneNotificationEnable(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u16 readGi_DoneNotificationEnable(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u16 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tGi_DMA_Config_Register(const tGi_DMA_Config_Register&);
      tGi_DMA_Config_Register& operator=(const tGi_DMA_Config_Register&);

   };

   //---------------------------------------------------------------------------
   // Gi_SampleClockCountRegister
   //---------------------------------------------------------------------------
   class tGi_SampleClockCountRegister : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tCounter tRegisterMap;

      enum {
         kOffset = 0x14,
         kId     = 13
      };
      tGi_SampleClockCountRegister();


      typedef enum {
         kRegisterId                          = 0,
         kGi_SampleClockCountId            = 1,
         kMaxFieldId                          = 1
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Register Accessors (Compile-time selectable)
      inline tGi_SampleClockCountRegister& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void refresh(nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tGi_SampleClockCountRegister& setGi_SampleClockCount(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getGi_SampleClockCount(nMDBG::tStatus2* statusChain = NULL) const;

      inline u32 readGi_SampleClockCount(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tGi_SampleClockCountRegister(const tGi_SampleClockCountRegister&);
      tGi_SampleClockCountRegister& operator=(const tGi_SampleClockCountRegister&);

   };

   //---------------------------------------------------------------------------
   // Gi_RdFifoRegister
   //---------------------------------------------------------------------------
   class tGi_RdFifoRegister : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tCounter tRegisterMap;

      enum {
         kOffset = 0x18,
         kId     = 14
      };
      tGi_RdFifoRegister();


      typedef enum {
         kRegisterId                          = 0,
         kGi_RdFifoDataId                  = 1,
         kMaxFieldId                          = 1
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Register Accessors (Compile-time selectable)
      inline tGi_RdFifoRegister& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void refresh(nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tGi_RdFifoRegister& setGi_RdFifoData(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getGi_RdFifoData(nMDBG::tStatus2* statusChain = NULL) const;

      inline u32 readGi_RdFifoData(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tGi_RdFifoRegister(const tGi_RdFifoRegister&);
      tGi_RdFifoRegister& operator=(const tGi_RdFifoRegister&);

   };

   //---------------------------------------------------------------------------
   // Gi_WrFifoRegister
   //---------------------------------------------------------------------------
   class tGi_WrFifoRegister : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tCounter tRegisterMap;

      enum {
         kOffset = 0x18,
         kId     = 15
      };
      tGi_WrFifoRegister();


      typedef enum {
         kRegisterId                          = 0,
         kGi_WrFifoDataId                  = 1,
         kMaxFieldId                          = 1
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Register Accessors (Compile-time selectable)

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);


      // Field Accessors (Compile-time selectable)
      inline void writeGi_WrFifoData(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      tRegisterMap* _regMap;

      // Usage guidelines
      tGi_WrFifoRegister(const tGi_WrFifoRegister&);
      tGi_WrFifoRegister& operator=(const tGi_WrFifoRegister&);

   };

   //---------------------------------------------------------------------------
   // Gi_SampleClockRegister
   //---------------------------------------------------------------------------
   class tGi_SampleClockRegister : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tCounter tRegisterMap;

      enum {
         kOffset = 0x1c,
         kId     = 16
      };
      tGi_SampleClockRegister();


      typedef enum {
         kRegisterId                          = 0,
         kGi_SampleClockSelectId           = 1,
         kGi_SampleClockPolarityId         = 2,
         kGi_SampleClockLevelModeId        = 3,
         kGi_SampleClockModeId             = 4,
         kGi_SampleClockPulseId            = 5,
         kGi_SampleClockSampleModeId       = 6,
         kGi_SampleClockGateIndependentId  = 8,
         kMaxFieldId                          = 8
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Dirty Tracking
      inline tBoolean isDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markClean(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tGi_SampleClockRegister& setRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline void writeRegister(u16 value, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u16 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tGi_SampleClockRegister& setGi_SampleClockSelect(nCounter::tGi_SampleClockSelect_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nCounter::tGi_SampleClockSelect_t getGi_SampleClockSelect(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeGi_SampleClockSelect(nCounter::tGi_SampleClockSelect_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nCounter::tGi_SampleClockSelect_t readGi_SampleClockSelect(nMDBG::tStatus2* statusChain = NULL);

      inline tGi_SampleClockRegister& setGi_SampleClockPolarity(nCounter::tGi_Polarity_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nCounter::tGi_Polarity_t getGi_SampleClockPolarity(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeGi_SampleClockPolarity(nCounter::tGi_Polarity_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nCounter::tGi_Polarity_t readGi_SampleClockPolarity(nMDBG::tStatus2* statusChain = NULL);

      inline tGi_SampleClockRegister& setGi_SampleClockLevelMode(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getGi_SampleClockLevelMode(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeGi_SampleClockLevelMode(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u16 readGi_SampleClockLevelMode(nMDBG::tStatus2* statusChain = NULL);

      inline tGi_SampleClockRegister& setGi_SampleClockMode(nCounter::tGi_SampleClockMode_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nCounter::tGi_SampleClockMode_t getGi_SampleClockMode(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeGi_SampleClockMode(nCounter::tGi_SampleClockMode_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nCounter::tGi_SampleClockMode_t readGi_SampleClockMode(nMDBG::tStatus2* statusChain = NULL);

      inline tGi_SampleClockRegister& setGi_SampleClockPulse(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getGi_SampleClockPulse(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeGi_SampleClockPulse(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u16 readGi_SampleClockPulse(nMDBG::tStatus2* statusChain = NULL);

      inline tGi_SampleClockRegister& setGi_SampleClockSampleMode(nCounter::tGi_SampleClkSampleMode_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nCounter::tGi_SampleClkSampleMode_t getGi_SampleClockSampleMode(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeGi_SampleClockSampleMode(nCounter::tGi_SampleClkSampleMode_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nCounter::tGi_SampleClkSampleMode_t readGi_SampleClockSampleMode(nMDBG::tStatus2* statusChain = NULL);

      inline tGi_SampleClockRegister& setGi_SampleClockGateIndependent(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getGi_SampleClockGateIndependent(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeGi_SampleClockGateIndependent(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u16 readGi_SampleClockGateIndependent(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u16 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tGi_SampleClockRegister(const tGi_SampleClockRegister&);
      tGi_SampleClockRegister& operator=(const tGi_SampleClockRegister&);

   };

   //---------------------------------------------------------------------------
   // Gi_AuxCtrRegister
   //---------------------------------------------------------------------------
   class tGi_AuxCtrRegister : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tCounter tRegisterMap;

      enum {
         kOffset = 0x1e,
         kId     = 17
      };
      tGi_AuxCtrRegister();


      typedef enum {
         kRegisterId                          = 0,
         kGi_AuxCtrModeId                  = 1,
         kGi_AuxCtrLoadId                  = 3,
         kMaxFieldId                          = 3
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Dirty Tracking
      inline tBoolean isDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markClean(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tGi_AuxCtrRegister& setRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline void writeRegister(u16 value, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u16 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tGi_AuxCtrRegister& setGi_AuxCtrMode(nCounter::tGi_AuxCtrMode_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nCounter::tGi_AuxCtrMode_t getGi_AuxCtrMode(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeGi_AuxCtrMode(nCounter::tGi_AuxCtrMode_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nCounter::tGi_AuxCtrMode_t readGi_AuxCtrMode(nMDBG::tStatus2* statusChain = NULL);

      inline tGi_AuxCtrRegister& setGi_AuxCtrLoad(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getGi_AuxCtrLoad(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeGi_AuxCtrLoad(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u16 readGi_AuxCtrLoad(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u16 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tGi_AuxCtrRegister(const tGi_AuxCtrRegister&);
      tGi_AuxCtrRegister& operator=(const tGi_AuxCtrRegister&);

   };

   //---------------------------------------------------------------------------
   // Gi_AuxCtrLoadA_Register
   //---------------------------------------------------------------------------
   class tGi_AuxCtrLoadA_Register : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tCounter tRegisterMap;

      enum {
         kOffset = 0x20,
         kId     = 18
      };
      tGi_AuxCtrLoadA_Register();


      typedef enum {
         kRegisterId                          = 0,
         kGi_AuxCtrLoadAId                 = 1,
         kMaxFieldId                          = 1
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Dirty Tracking
      inline tBoolean isDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markClean(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tGi_AuxCtrLoadA_Register& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tGi_AuxCtrLoadA_Register& setGi_AuxCtrLoadA(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getGi_AuxCtrLoadA(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeGi_AuxCtrLoadA(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u32 readGi_AuxCtrLoadA(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tGi_AuxCtrLoadA_Register(const tGi_AuxCtrLoadA_Register&);
      tGi_AuxCtrLoadA_Register& operator=(const tGi_AuxCtrLoadA_Register&);

   };

   //---------------------------------------------------------------------------
   // Gi_AuxCtrLoadB_Register
   //---------------------------------------------------------------------------
   class tGi_AuxCtrLoadB_Register : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tCounter tRegisterMap;

      enum {
         kOffset = 0x24,
         kId     = 19
      };
      tGi_AuxCtrLoadB_Register();


      typedef enum {
         kRegisterId                          = 0,
         kGi_AuxCtrLoadBId                 = 1,
         kMaxFieldId                          = 1
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Dirty Tracking
      inline tBoolean isDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markClean(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tGi_AuxCtrLoadB_Register& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tGi_AuxCtrLoadB_Register& setGi_AuxCtrLoadB(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getGi_AuxCtrLoadB(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeGi_AuxCtrLoadB(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u32 readGi_AuxCtrLoadB(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tGi_AuxCtrLoadB_Register(const tGi_AuxCtrLoadB_Register&);
      tGi_AuxCtrLoadB_Register& operator=(const tGi_AuxCtrLoadB_Register&);

   };

   //---------------------------------------------------------------------------
   // Gi_AutomaticLoadRegister
   //---------------------------------------------------------------------------
   class tGi_AutomaticLoadRegister : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tCounter tRegisterMap;

      enum {
         kOffset = 0x28,
         kId     = 20
      };
      tGi_AutomaticLoadRegister();


      typedef enum {
         kRegisterId                          = 0,
         kGi_AutoLdRegisterId              = 1,
         kMaxFieldId                          = 1
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Register Accessors (Compile-time selectable)

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);


      // Field Accessors (Compile-time selectable)
      inline void writeGi_AutoLdRegister(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      tRegisterMap* _regMap;

      // Usage guidelines
      tGi_AutomaticLoadRegister(const tGi_AutomaticLoadRegister&);
      tGi_AutomaticLoadRegister& operator=(const tGi_AutomaticLoadRegister&);

   };

   //---------------------------------------------------------------------------
   // Gi_Interrupt1_Register
   //---------------------------------------------------------------------------
   class tGi_Interrupt1_Register : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tCounter tRegisterMap;

      enum {
         kOffset = 0x2c,
         kId     = 21
      };
      tGi_Interrupt1_Register();


      typedef enum {
         kRegisterId                          = 0,
         kGi_Aux_Ctr_TC_Error_Interrupt_EnId     = 2,
         kGi_Aux_Ctr_TC_Interrupt_EnId     = 3,
         kGi_Disarm_Interrupt_EnId         = 4,
         kGi_SampleClockInterruptEnId      = 5,
         kGi_GateSwitchErrorInt_EnId       = 6,
         kGi_WritesTooFastErrorEnId        = 7,
         kGi_DMA_Int_EnableId              = 8,
         kGi_Gate_Interrupt_EnableId       = 9,
         kGi_TC_Interrupt_EnableId         = 10,
         kGi_SampleClockOverrunIntEnId     = 11,
         kGi_Gate_Error_Interrupt_EnabledId    = 12,
         kGi_TC_Error_Interrupt_EnableId   = 13,
         kGi_DMA_Error_Interrupt_EnableId  = 14,
         kGi_SampleClockOverrunErrorAckId  = 16,
         kGi_SampleClockInterruptAckId     = 17,
         kGi_Gate_Error_ConfirmId          = 18,
         kGi_TC_Error_ConfirmId            = 19,
         kGi_Aux_Ctr_TC_Error_Interrupt_AckId      = 21,
         kGi_Aux_Ctr_TC_Interrupt_AckId    = 22,
         kGi_Disarm_Interrupt_AckId        = 23,
         kGi_WritesTooFastErrorAckId       = 24,
         kGi_GateSwitchError_AckId         = 25,
         kGi_DMA_Error_AckId               = 26,
         kGi_TC_Interrupt_AckId            = 27,
         kGi_Gate_Interrupt_AckId          = 28,
         kMaxFieldId                          = 28
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Register Accessors (Compile-time selectable)

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);


      // Field Accessors (Compile-time selectable)
      inline void writeGi_Aux_Ctr_TC_Error_Interrupt_En(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeGi_Aux_Ctr_TC_Interrupt_En(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeGi_Disarm_Interrupt_En(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeGi_SampleClockInterruptEn(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeGi_GateSwitchErrorInt_En(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeGi_WritesTooFastErrorEn(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeGi_DMA_Int_Enable(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeGi_Gate_Interrupt_Enable(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeGi_TC_Interrupt_Enable(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeGi_SampleClockOverrunIntEn(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeGi_Gate_Error_Interrupt_Enabled(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeGi_TC_Error_Interrupt_Enable(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeGi_DMA_Error_Interrupt_Enable(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeGi_SampleClockOverrunErrorAck(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeGi_SampleClockInterruptAck(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeGi_Gate_Error_Confirm(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeGi_TC_Error_Confirm(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeGi_Aux_Ctr_TC_Error_Interrupt_Ack(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeGi_Aux_Ctr_TC_Interrupt_Ack(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeGi_Disarm_Interrupt_Ack(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeGi_WritesTooFastErrorAck(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeGi_GateSwitchError_Ack(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeGi_DMA_Error_Ack(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeGi_TC_Interrupt_Ack(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeGi_Gate_Interrupt_Ack(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      tRegisterMap* _regMap;

      // Usage guidelines
      tGi_Interrupt1_Register(const tGi_Interrupt1_Register&);
      tGi_Interrupt1_Register& operator=(const tGi_Interrupt1_Register&);

   };

   //---------------------------------------------------------------------------
   // Gi_Interrupt2_Register
   //---------------------------------------------------------------------------
   class tGi_Interrupt2_Register : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tCounter tRegisterMap;

      enum {
         kOffset = 0x30,
         kId     = 22
      };
      tGi_Interrupt2_Register();


      typedef enum {
         kRegisterId                          = 0,
         kGi_Aux_Ctr_TC_Error_Interrupt_DisId      = 2,
         kGi_Aux_Ctr_TC_Interrupt_DisId    = 3,
         kGi_Disarm_Interrupt_DisId        = 4,
         kGi_SampleClockInterruptDisId     = 5,
         kGi_GateSwitchErrorInt_DisId      = 6,
         kGi_WritesTooFastErrorDisId       = 7,
         kGi_DMA_Int_DisableId             = 8,
         kGi_Gate_Interrupt_DisableId      = 9,
         kGi_TC_Interrupt_DisableId        = 10,
         kGi_SampleClockOverrunIntDisId    = 11,
         kGi_Gate_Error_Interrupt_DisableId    = 12,
         kGi_TC_Error_Interrupt_DisableId  = 13,
         kGi_DMA_Error_Interrupt_DisableId   = 14,
         kGi_SampleClockOverrunErrorAck2Id   = 16,
         kGi_SampleClockInterruptAck2Id    = 17,
         kGi_Gate_Error_Confirm2Id         = 18,
         kGi_TC_Error_Confirm2Id           = 19,
         kGi_Aux_Ctr_TC_Error_Interrupt_Ack2Id       = 21,
         kGi_Aux_Ctr_TC_Interrupt_Ack2Id   = 22,
         kGi_Disarm_Interrupt_Ack2Id       = 23,
         kGi_WritesTooFastErrorAck2Id      = 24,
         kGi_GateSwitchError_Ack2Id        = 25,
         kGi_DMA_Error_Ack2Id              = 26,
         kGi_TC_Interrupt_Ack2Id           = 27,
         kGi_Gate_Interrupt_Ack2Id         = 28,
         kMaxFieldId                          = 28
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Register Accessors (Compile-time selectable)

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);


      // Field Accessors (Compile-time selectable)
      inline void writeGi_Aux_Ctr_TC_Error_Interrupt_Dis(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeGi_Aux_Ctr_TC_Interrupt_Dis(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeGi_Disarm_Interrupt_Dis(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeGi_SampleClockInterruptDis(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeGi_GateSwitchErrorInt_Dis(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeGi_WritesTooFastErrorDis(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeGi_DMA_Int_Disable(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeGi_Gate_Interrupt_Disable(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeGi_TC_Interrupt_Disable(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeGi_SampleClockOverrunIntDis(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeGi_Gate_Error_Interrupt_Disable(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeGi_TC_Error_Interrupt_Disable(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeGi_DMA_Error_Interrupt_Disable(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeGi_SampleClockOverrunErrorAck2(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeGi_SampleClockInterruptAck2(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeGi_Gate_Error_Confirm2(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeGi_TC_Error_Confirm2(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeGi_Aux_Ctr_TC_Error_Interrupt_Ack2(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeGi_Aux_Ctr_TC_Interrupt_Ack2(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeGi_Disarm_Interrupt_Ack2(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeGi_WritesTooFastErrorAck2(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeGi_GateSwitchError_Ack2(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeGi_DMA_Error_Ack2(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeGi_TC_Interrupt_Ack2(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeGi_Gate_Interrupt_Ack2(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      tRegisterMap* _regMap;

      // Usage guidelines
      tGi_Interrupt2_Register(const tGi_Interrupt2_Register&);
      tGi_Interrupt2_Register& operator=(const tGi_Interrupt2_Register&);

   };

   //---------------------------------------------------------------------------
   // Gi_ABZ_Select_Register
   //---------------------------------------------------------------------------
   class tGi_ABZ_Select_Register : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tCounter tRegisterMap;

      enum {
         kOffset = 0x38,
         kId     = 23
      };
      tGi_ABZ_Select_Register();


      typedef enum {
         kRegisterId                          = 0,
         kGi_Z_SelectId                    = 1,
         kGi_B_SelectId                    = 3,
         kGi_A_SelectId                    = 5,
         kMaxFieldId                          = 5
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Dirty Tracking
      inline tBoolean isDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markClean(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tGi_ABZ_Select_Register& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tGi_ABZ_Select_Register& setGi_Z_Select(nCounter::tGi_Z_Select_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nCounter::tGi_Z_Select_t getGi_Z_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeGi_Z_Select(nCounter::tGi_Z_Select_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nCounter::tGi_Z_Select_t readGi_Z_Select(nMDBG::tStatus2* statusChain = NULL);

      inline tGi_ABZ_Select_Register& setGi_B_Select(nCounter::tGi_B_Select_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nCounter::tGi_B_Select_t getGi_B_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeGi_B_Select(nCounter::tGi_B_Select_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nCounter::tGi_B_Select_t readGi_B_Select(nMDBG::tStatus2* statusChain = NULL);

      inline tGi_ABZ_Select_Register& setGi_A_Select(nCounter::tGi_A_Select_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nCounter::tGi_A_Select_t getGi_A_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeGi_A_Select(nCounter::tGi_A_Select_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nCounter::tGi_A_Select_t readGi_A_Select(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tGi_ABZ_Select_Register(const tGi_ABZ_Select_Register&);
      tGi_ABZ_Select_Register& operator=(const tGi_ABZ_Select_Register&);

   };

   //---------------------------------------------------------------------------
   // Gi_Mode3_Register
   //---------------------------------------------------------------------------
   class tGi_Mode3_Register : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tCounter tRegisterMap;

      enum {
         kOffset = 0x3c,
         kId     = 24
      };
      tGi_Mode3_Register();


      typedef enum {
         kRegisterId                          = 0,
         kGi_TimeCoherentSemiperiodId      = 3,
         kMaxFieldId                          = 3
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Dirty Tracking
      inline tBoolean isDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markClean(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tGi_Mode3_Register& setRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline void writeRegister(u16 value, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u16 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tGi_Mode3_Register& setGi_TimeCoherentSemiperiod(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getGi_TimeCoherentSemiperiod(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeGi_TimeCoherentSemiperiod(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u16 readGi_TimeCoherentSemiperiod(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u16 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tGi_Mode3_Register(const tGi_Mode3_Register&);
      tGi_Mode3_Register& operator=(const tGi_Mode3_Register&);

   };

   //---------------------------------------------------------------------------
   // Gi_Mode2_Register
   //---------------------------------------------------------------------------
   class tGi_Mode2_Register : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tCounter tRegisterMap;

      enum {
         kOffset = 0x3e,
         kId     = 25
      };
      tGi_Mode2_Register();


      typedef enum {
         kRegisterId                          = 0,
         kGi_HwArmSyncModeId               = 1,
         kGi_CtrOutFifoRegenerationEnId    = 2,
         kGi_StopOnErrorId                 = 3,
         kGi_WriteOnSwitchRequestId        = 5,
         kGi_Bank_Switch_ModeId            = 7,
         kGi_Bank_Switch_EnableId          = 8,
         kGi_Up_DownId                     = 10,
         kMaxFieldId                          = 10
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Dirty Tracking
      inline tBoolean isDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markClean(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tGi_Mode2_Register& setRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline void writeRegister(u16 value, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u16 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tGi_Mode2_Register& setGi_HwArmSyncMode(nCounter::tGi_HwArmSyncMode_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nCounter::tGi_HwArmSyncMode_t getGi_HwArmSyncMode(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeGi_HwArmSyncMode(nCounter::tGi_HwArmSyncMode_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nCounter::tGi_HwArmSyncMode_t readGi_HwArmSyncMode(nMDBG::tStatus2* statusChain = NULL);

      inline tGi_Mode2_Register& setGi_CtrOutFifoRegenerationEn(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getGi_CtrOutFifoRegenerationEn(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeGi_CtrOutFifoRegenerationEn(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u16 readGi_CtrOutFifoRegenerationEn(nMDBG::tStatus2* statusChain = NULL);

      inline tGi_Mode2_Register& setGi_StopOnError(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getGi_StopOnError(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeGi_StopOnError(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u16 readGi_StopOnError(nMDBG::tStatus2* statusChain = NULL);

      inline tGi_Mode2_Register& setGi_WriteOnSwitchRequest(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getGi_WriteOnSwitchRequest(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeGi_WriteOnSwitchRequest(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u16 readGi_WriteOnSwitchRequest(nMDBG::tStatus2* statusChain = NULL);

      inline tGi_Mode2_Register& setGi_Bank_Switch_Mode(nCounter::tGi_Bank_Switch_Mode_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nCounter::tGi_Bank_Switch_Mode_t getGi_Bank_Switch_Mode(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeGi_Bank_Switch_Mode(nCounter::tGi_Bank_Switch_Mode_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nCounter::tGi_Bank_Switch_Mode_t readGi_Bank_Switch_Mode(nMDBG::tStatus2* statusChain = NULL);

      inline tGi_Mode2_Register& setGi_Bank_Switch_Enable(nCounter::tGi_Bank_Switch_Enable_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nCounter::tGi_Bank_Switch_Enable_t getGi_Bank_Switch_Enable(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeGi_Bank_Switch_Enable(nCounter::tGi_Bank_Switch_Enable_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nCounter::tGi_Bank_Switch_Enable_t readGi_Bank_Switch_Enable(nMDBG::tStatus2* statusChain = NULL);

      inline tGi_Mode2_Register& setGi_Up_Down(nCounter::tGi_Up_Down_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nCounter::tGi_Up_Down_t getGi_Up_Down(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeGi_Up_Down(nCounter::tGi_Up_Down_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nCounter::tGi_Up_Down_t readGi_Up_Down(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u16 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tGi_Mode2_Register(const tGi_Mode2_Register&);
      tGi_Mode2_Register& operator=(const tGi_Mode2_Register&);

   };

   //---------------------------------------------------------------------------
   // Gi_Command_Register
   //---------------------------------------------------------------------------
   tGi_Command_Register Gi_Command_Register;

   //---------------------------------------------------------------------------
   // Gi_Mode_Register
   //---------------------------------------------------------------------------
   tGi_Mode_Register Gi_Mode_Register;

   //---------------------------------------------------------------------------
   // Gi_HW_Save_Register
   //---------------------------------------------------------------------------
   tGi_HW_Save_Register Gi_HW_Save_Register;

   //---------------------------------------------------------------------------
   // Gi_Load_A_Register
   //---------------------------------------------------------------------------
   tGi_Load_A_Register Gi_Load_A_Register;

   //---------------------------------------------------------------------------
   // Gi_Load_B_Register
   //---------------------------------------------------------------------------
   tGi_Load_B_Register Gi_Load_B_Register;

   //---------------------------------------------------------------------------
   // Gi_Save_Register
   //---------------------------------------------------------------------------
   tGi_Save_Register Gi_Save_Register;

   //---------------------------------------------------------------------------
   // Gi_Input_Select_Register
   //---------------------------------------------------------------------------
   tGi_Input_Select_Register Gi_Input_Select_Register;

   //---------------------------------------------------------------------------
   // Gi_Status_Register
   //---------------------------------------------------------------------------
   tGi_Status_Register Gi_Status_Register;

   //---------------------------------------------------------------------------
   // Gi_Autoincrement_Register
   //---------------------------------------------------------------------------
   tGi_Autoincrement_Register Gi_Autoincrement_Register;

   //---------------------------------------------------------------------------
   // Gi_Counting_Mode_Register
   //---------------------------------------------------------------------------
   tGi_Counting_Mode_Register Gi_Counting_Mode_Register;

   //---------------------------------------------------------------------------
   // Gi_FifoStatusRegister
   //---------------------------------------------------------------------------
   tGi_FifoStatusRegister Gi_FifoStatusRegister;

   //---------------------------------------------------------------------------
   // Gi_Second_Gate_Register
   //---------------------------------------------------------------------------
   tGi_Second_Gate_Register Gi_Second_Gate_Register;

   //---------------------------------------------------------------------------
   // Gi_DMA_Config_Register
   //---------------------------------------------------------------------------
   tGi_DMA_Config_Register Gi_DMA_Config_Register;

   //---------------------------------------------------------------------------
   // Gi_SampleClockCountRegister
   //---------------------------------------------------------------------------
   tGi_SampleClockCountRegister Gi_SampleClockCountRegister;

   //---------------------------------------------------------------------------
   // Gi_RdFifoRegister
   //---------------------------------------------------------------------------
   tGi_RdFifoRegister Gi_RdFifoRegister;

   //---------------------------------------------------------------------------
   // Gi_WrFifoRegister
   //---------------------------------------------------------------------------
   tGi_WrFifoRegister Gi_WrFifoRegister;

   //---------------------------------------------------------------------------
   // Gi_SampleClockRegister
   //---------------------------------------------------------------------------
   tGi_SampleClockRegister Gi_SampleClockRegister;

   //---------------------------------------------------------------------------
   // Gi_AuxCtrRegister
   //---------------------------------------------------------------------------
   tGi_AuxCtrRegister Gi_AuxCtrRegister;

   //---------------------------------------------------------------------------
   // Gi_AuxCtrLoadA_Register
   //---------------------------------------------------------------------------
   tGi_AuxCtrLoadA_Register Gi_AuxCtrLoadA_Register;

   //---------------------------------------------------------------------------
   // Gi_AuxCtrLoadB_Register
   //---------------------------------------------------------------------------
   tGi_AuxCtrLoadB_Register Gi_AuxCtrLoadB_Register;

   //---------------------------------------------------------------------------
   // Gi_AutomaticLoadRegister
   //---------------------------------------------------------------------------
   tGi_AutomaticLoadRegister Gi_AutomaticLoadRegister;

   //---------------------------------------------------------------------------
   // Gi_Interrupt1_Register
   //---------------------------------------------------------------------------
   tGi_Interrupt1_Register Gi_Interrupt1_Register;

   //---------------------------------------------------------------------------
   // Gi_Interrupt2_Register
   //---------------------------------------------------------------------------
   tGi_Interrupt2_Register Gi_Interrupt2_Register;

   //---------------------------------------------------------------------------
   // Gi_ABZ_Select_Register
   //---------------------------------------------------------------------------
   tGi_ABZ_Select_Register Gi_ABZ_Select_Register;

   //---------------------------------------------------------------------------
   // Gi_Mode3_Register
   //---------------------------------------------------------------------------
   tGi_Mode3_Register Gi_Mode3_Register;

   //---------------------------------------------------------------------------
   // Gi_Mode2_Register
   //---------------------------------------------------------------------------
   tGi_Mode2_Register Gi_Mode2_Register;

   //---------------------------------------------------------------------------
   // Register Groups
   //---------------------------------------------------------------------------

   //----------------------------------------
   // Register/Field Ids
   //----------------------------------------
   typedef enum {
      kGi_Command_RegisterId            = 0,
      kGi_ArmId                         = nNIMXRegisterMap120_mBuildFieldId(tGi_Command_Register::kGi_ArmId, kGi_Command_RegisterId),
      kGi_LoadId                        = nNIMXRegisterMap120_mBuildFieldId(tGi_Command_Register::kGi_LoadId, kGi_Command_RegisterId),
      kGi_DisarmId                      = nNIMXRegisterMap120_mBuildFieldId(tGi_Command_Register::kGi_DisarmId, kGi_Command_RegisterId),
      kGi_WrLoadRegsFromFifoId          = nNIMXRegisterMap120_mBuildFieldId(tGi_Command_Register::kGi_WrLoadRegsFromFifoId, kGi_Command_RegisterId),
      kGi_Bank_Switch_StartId           = nNIMXRegisterMap120_mBuildFieldId(tGi_Command_Register::kGi_Bank_Switch_StartId, kGi_Command_RegisterId),
      kGi_Arm_Paired_CounterId          = nNIMXRegisterMap120_mBuildFieldId(tGi_Command_Register::kGi_Arm_Paired_CounterId, kGi_Command_RegisterId),
      kGi_ResetId                       = nNIMXRegisterMap120_mBuildFieldId(tGi_Command_Register::kGi_ResetId, kGi_Command_RegisterId),
      kGi_Disarm_Paired_CounterId       = nNIMXRegisterMap120_mBuildFieldId(tGi_Command_Register::kGi_Disarm_Paired_CounterId, kGi_Command_RegisterId),

      kGi_Mode_RegisterId               = 1,
      kGi_Gating_ModeId                 = nNIMXRegisterMap120_mBuildFieldId(tGi_Mode_Register::kGi_Gating_ModeId, kGi_Mode_RegisterId),
      kGi_Gate_On_Both_EdgesId          = nNIMXRegisterMap120_mBuildFieldId(tGi_Mode_Register::kGi_Gate_On_Both_EdgesId, kGi_Mode_RegisterId),
      kGi_Trigger_Mode_For_Edge_GateId  = nNIMXRegisterMap120_mBuildFieldId(tGi_Mode_Register::kGi_Trigger_Mode_For_Edge_GateId, kGi_Mode_RegisterId),
      kGi_Stop_ModeId                   = nNIMXRegisterMap120_mBuildFieldId(tGi_Mode_Register::kGi_Stop_ModeId, kGi_Mode_RegisterId),
      kGi_Load_Source_SelectId          = nNIMXRegisterMap120_mBuildFieldId(tGi_Mode_Register::kGi_Load_Source_SelectId, kGi_Mode_RegisterId),
      kGi_Output_ModeId                 = nNIMXRegisterMap120_mBuildFieldId(tGi_Mode_Register::kGi_Output_ModeId, kGi_Mode_RegisterId),
      kGi_Counting_OnceId               = nNIMXRegisterMap120_mBuildFieldId(tGi_Mode_Register::kGi_Counting_OnceId, kGi_Mode_RegisterId),
      kGi_Loading_On_TCId               = nNIMXRegisterMap120_mBuildFieldId(tGi_Mode_Register::kGi_Loading_On_TCId, kGi_Mode_RegisterId),
      kGi_ForceSourceEqualToTimebaseId  = nNIMXRegisterMap120_mBuildFieldId(tGi_Mode_Register::kGi_ForceSourceEqualToTimebaseId, kGi_Mode_RegisterId),
      kGi_Loading_On_GateId             = nNIMXRegisterMap120_mBuildFieldId(tGi_Mode_Register::kGi_Loading_On_GateId, kGi_Mode_RegisterId),
      kGi_Reload_Source_SwitchingId     = nNIMXRegisterMap120_mBuildFieldId(tGi_Mode_Register::kGi_Reload_Source_SwitchingId, kGi_Mode_RegisterId),

      kGi_HW_Save_RegisterId            = 2,
      kGi_HW_Save_ValueId               = nNIMXRegisterMap120_mBuildFieldId(tGi_HW_Save_Register::kGi_HW_Save_ValueId, kGi_HW_Save_RegisterId),

      kGi_Load_A_RegisterId             = 3,
      kGi_Load_AId                      = nNIMXRegisterMap120_mBuildFieldId(tGi_Load_A_Register::kGi_Load_AId, kGi_Load_A_RegisterId),

      kGi_Load_B_RegisterId             = 4,
      kGi_Load_BId                      = nNIMXRegisterMap120_mBuildFieldId(tGi_Load_B_Register::kGi_Load_BId, kGi_Load_B_RegisterId),

      kGi_Save_RegisterId               = 5,
      kGi_Save_ValueId                  = nNIMXRegisterMap120_mBuildFieldId(tGi_Save_Register::kGi_Save_ValueId, kGi_Save_RegisterId),

      kGi_Input_Select_RegisterId       = 6,
      kGi_Gate_PolarityId               = nNIMXRegisterMap120_mBuildFieldId(tGi_Input_Select_Register::kGi_Gate_PolarityId, kGi_Input_Select_RegisterId),
      kGi_Source_SelectId               = nNIMXRegisterMap120_mBuildFieldId(tGi_Input_Select_Register::kGi_Source_SelectId, kGi_Input_Select_RegisterId),
      kGi_Gate_SelectId                 = nNIMXRegisterMap120_mBuildFieldId(tGi_Input_Select_Register::kGi_Gate_SelectId, kGi_Input_Select_RegisterId),
      kGi_Gate_Select_Load_SourceId     = nNIMXRegisterMap120_mBuildFieldId(tGi_Input_Select_Register::kGi_Gate_Select_Load_SourceId, kGi_Input_Select_RegisterId),
      kGi_Output_PolarityId             = nNIMXRegisterMap120_mBuildFieldId(tGi_Input_Select_Register::kGi_Output_PolarityId, kGi_Input_Select_RegisterId),
      kGi_Source_PolarityId             = nNIMXRegisterMap120_mBuildFieldId(tGi_Input_Select_Register::kGi_Source_PolarityId, kGi_Input_Select_RegisterId),

      kGi_Status_RegisterId             = 7,
      kGi_Output_StId                   = nNIMXRegisterMap120_mBuildFieldId(tGi_Status_Register::kGi_Output_StId, kGi_Status_RegisterId),
      kGi_Counting_StId                 = nNIMXRegisterMap120_mBuildFieldId(tGi_Status_Register::kGi_Counting_StId, kGi_Status_RegisterId),
      kGi_Next_Load_Source_StId         = nNIMXRegisterMap120_mBuildFieldId(tGi_Status_Register::kGi_Next_Load_Source_StId, kGi_Status_RegisterId),
      kGi_Armed_StId                    = nNIMXRegisterMap120_mBuildFieldId(tGi_Status_Register::kGi_Armed_StId, kGi_Status_RegisterId),
      kGi_No_Load_Between_Gates_StId    = nNIMXRegisterMap120_mBuildFieldId(tGi_Status_Register::kGi_No_Load_Between_Gates_StId, kGi_Status_RegisterId),
      kGi_DRQ_ErrorId                   = nNIMXRegisterMap120_mBuildFieldId(tGi_Status_Register::kGi_DRQ_ErrorId, kGi_Status_RegisterId),
      kGi_TC_Error_StId                 = nNIMXRegisterMap120_mBuildFieldId(tGi_Status_Register::kGi_TC_Error_StId, kGi_Status_RegisterId),
      kGi_Gate_Error_StId               = nNIMXRegisterMap120_mBuildFieldId(tGi_Status_Register::kGi_Gate_Error_StId, kGi_Status_RegisterId),
      kGi_DRQ_StId                      = nNIMXRegisterMap120_mBuildFieldId(tGi_Status_Register::kGi_DRQ_StId, kGi_Status_RegisterId),
      kGi_SampleClockOverrun_StId       = nNIMXRegisterMap120_mBuildFieldId(tGi_Status_Register::kGi_SampleClockOverrun_StId, kGi_Status_RegisterId),
      kGi_SampleClockInterruptStId      = nNIMXRegisterMap120_mBuildFieldId(tGi_Status_Register::kGi_SampleClockInterruptStId, kGi_Status_RegisterId),
      kGi_Bank_StId                     = nNIMXRegisterMap120_mBuildFieldId(tGi_Status_Register::kGi_Bank_StId, kGi_Status_RegisterId),
      kGi_Gate_StId                     = nNIMXRegisterMap120_mBuildFieldId(tGi_Status_Register::kGi_Gate_StId, kGi_Status_RegisterId),
      kGi_Gate_Interrupt_StId           = nNIMXRegisterMap120_mBuildFieldId(tGi_Status_Register::kGi_Gate_Interrupt_StId, kGi_Status_RegisterId),
      kGi_TC_StId                       = nNIMXRegisterMap120_mBuildFieldId(tGi_Status_Register::kGi_TC_StId, kGi_Status_RegisterId),
      kGi_GateSwitchError_StId          = nNIMXRegisterMap120_mBuildFieldId(tGi_Status_Register::kGi_GateSwitchError_StId, kGi_Status_RegisterId),
      kGi_DisarmEventInterruptStId      = nNIMXRegisterMap120_mBuildFieldId(tGi_Status_Register::kGi_DisarmEventInterruptStId, kGi_Status_RegisterId),
      kGi_ForcedWrFromFifoInProgStId    = nNIMXRegisterMap120_mBuildFieldId(tGi_Status_Register::kGi_ForcedWrFromFifoInProgStId, kGi_Status_RegisterId),
      kGi_WritesTooFastErrorStId        = nNIMXRegisterMap120_mBuildFieldId(tGi_Status_Register::kGi_WritesTooFastErrorStId, kGi_Status_RegisterId),
      kGi_AuxTC_ErrorEventStId          = nNIMXRegisterMap120_mBuildFieldId(tGi_Status_Register::kGi_AuxTC_ErrorEventStId, kGi_Status_RegisterId),
      kGi_AuxTC_EventStId               = nNIMXRegisterMap120_mBuildFieldId(tGi_Status_Register::kGi_AuxTC_EventStId, kGi_Status_RegisterId),

      kGi_Autoincrement_RegisterId      = 8,
      kGi_AutoincrementId               = nNIMXRegisterMap120_mBuildFieldId(tGi_Autoincrement_Register::kGi_AutoincrementId, kGi_Autoincrement_RegisterId),

      kGi_Counting_Mode_RegisterId      = 9,
      kGi_Counting_ModeId               = nNIMXRegisterMap120_mBuildFieldId(tGi_Counting_Mode_Register::kGi_Counting_ModeId, kGi_Counting_Mode_RegisterId),
      kGi_HW_Arm_PolarityId             = nNIMXRegisterMap120_mBuildFieldId(tGi_Counting_Mode_Register::kGi_HW_Arm_PolarityId, kGi_Counting_Mode_RegisterId),
      kGi_Index_ModeId                  = nNIMXRegisterMap120_mBuildFieldId(tGi_Counting_Mode_Register::kGi_Index_ModeId, kGi_Counting_Mode_RegisterId),
      kGi_Index_PhaseId                 = nNIMXRegisterMap120_mBuildFieldId(tGi_Counting_Mode_Register::kGi_Index_PhaseId, kGi_Counting_Mode_RegisterId),
      kGi_HW_Arm_EnableId               = nNIMXRegisterMap120_mBuildFieldId(tGi_Counting_Mode_Register::kGi_HW_Arm_EnableId, kGi_Counting_Mode_RegisterId),
      kGi_HW_Arm_SelectId               = nNIMXRegisterMap120_mBuildFieldId(tGi_Counting_Mode_Register::kGi_HW_Arm_SelectId, kGi_Counting_Mode_RegisterId),
      kGi_PrescaleId                    = nNIMXRegisterMap120_mBuildFieldId(tGi_Counting_Mode_Register::kGi_PrescaleId, kGi_Counting_Mode_RegisterId),
      kGi_Prescale_Div_2Id              = nNIMXRegisterMap120_mBuildFieldId(tGi_Counting_Mode_Register::kGi_Prescale_Div_2Id, kGi_Counting_Mode_RegisterId),

      kGi_FifoStatusRegisterId          = 10,
      kGi_FifoStatusId                  = nNIMXRegisterMap120_mBuildFieldId(tGi_FifoStatusRegister::kGi_FifoStatusId, kGi_FifoStatusRegisterId),

      kGi_Second_Gate_RegisterId        = 11,
      kGi_Second_Gate_ModeId            = nNIMXRegisterMap120_mBuildFieldId(tGi_Second_Gate_Register::kGi_Second_Gate_ModeId, kGi_Second_Gate_RegisterId),
      kGi_Second_Gate_SelectId          = nNIMXRegisterMap120_mBuildFieldId(tGi_Second_Gate_Register::kGi_Second_Gate_SelectId, kGi_Second_Gate_RegisterId),
      kGi_Second_Gate_PolarityId        = nNIMXRegisterMap120_mBuildFieldId(tGi_Second_Gate_Register::kGi_Second_Gate_PolarityId, kGi_Second_Gate_RegisterId),

      kGi_DMA_Config_RegisterId         = 12,
      kGi_DMA_EnableId                  = nNIMXRegisterMap120_mBuildFieldId(tGi_DMA_Config_Register::kGi_DMA_EnableId, kGi_DMA_Config_RegisterId),
      kGi_DMA_WriteId                   = nNIMXRegisterMap120_mBuildFieldId(tGi_DMA_Config_Register::kGi_DMA_WriteId, kGi_DMA_Config_RegisterId),
      kGi_DMA_ResetId                   = nNIMXRegisterMap120_mBuildFieldId(tGi_DMA_Config_Register::kGi_DMA_ResetId, kGi_DMA_Config_RegisterId),
      kGi_WaitForFirstEventOnGateId     = nNIMXRegisterMap120_mBuildFieldId(tGi_DMA_Config_Register::kGi_WaitForFirstEventOnGateId, kGi_DMA_Config_RegisterId),
      kGi_WrFifoEnableId                = nNIMXRegisterMap120_mBuildFieldId(tGi_DMA_Config_Register::kGi_WrFifoEnableId, kGi_DMA_Config_RegisterId),
      kGi_DoneNotificationEnableId      = nNIMXRegisterMap120_mBuildFieldId(tGi_DMA_Config_Register::kGi_DoneNotificationEnableId, kGi_DMA_Config_RegisterId),

      kGi_SampleClockCountRegisterId    = 13,
      kGi_SampleClockCountId            = nNIMXRegisterMap120_mBuildFieldId(tGi_SampleClockCountRegister::kGi_SampleClockCountId, kGi_SampleClockCountRegisterId),

      kGi_RdFifoRegisterId              = 14,
      kGi_RdFifoDataId                  = nNIMXRegisterMap120_mBuildFieldId(tGi_RdFifoRegister::kGi_RdFifoDataId, kGi_RdFifoRegisterId),

      kGi_WrFifoRegisterId              = 15,
      kGi_WrFifoDataId                  = nNIMXRegisterMap120_mBuildFieldId(tGi_WrFifoRegister::kGi_WrFifoDataId, kGi_WrFifoRegisterId),

      kGi_SampleClockRegisterId         = 16,
      kGi_SampleClockSelectId           = nNIMXRegisterMap120_mBuildFieldId(tGi_SampleClockRegister::kGi_SampleClockSelectId, kGi_SampleClockRegisterId),
      kGi_SampleClockPolarityId         = nNIMXRegisterMap120_mBuildFieldId(tGi_SampleClockRegister::kGi_SampleClockPolarityId, kGi_SampleClockRegisterId),
      kGi_SampleClockLevelModeId        = nNIMXRegisterMap120_mBuildFieldId(tGi_SampleClockRegister::kGi_SampleClockLevelModeId, kGi_SampleClockRegisterId),
      kGi_SampleClockModeId             = nNIMXRegisterMap120_mBuildFieldId(tGi_SampleClockRegister::kGi_SampleClockModeId, kGi_SampleClockRegisterId),
      kGi_SampleClockPulseId            = nNIMXRegisterMap120_mBuildFieldId(tGi_SampleClockRegister::kGi_SampleClockPulseId, kGi_SampleClockRegisterId),
      kGi_SampleClockSampleModeId       = nNIMXRegisterMap120_mBuildFieldId(tGi_SampleClockRegister::kGi_SampleClockSampleModeId, kGi_SampleClockRegisterId),
      kGi_SampleClockGateIndependentId  = nNIMXRegisterMap120_mBuildFieldId(tGi_SampleClockRegister::kGi_SampleClockGateIndependentId, kGi_SampleClockRegisterId),

      kGi_AuxCtrRegisterId              = 17,
      kGi_AuxCtrModeId                  = nNIMXRegisterMap120_mBuildFieldId(tGi_AuxCtrRegister::kGi_AuxCtrModeId, kGi_AuxCtrRegisterId),
      kGi_AuxCtrLoadId                  = nNIMXRegisterMap120_mBuildFieldId(tGi_AuxCtrRegister::kGi_AuxCtrLoadId, kGi_AuxCtrRegisterId),

      kGi_AuxCtrLoadA_RegisterId        = 18,
      kGi_AuxCtrLoadAId                 = nNIMXRegisterMap120_mBuildFieldId(tGi_AuxCtrLoadA_Register::kGi_AuxCtrLoadAId, kGi_AuxCtrLoadA_RegisterId),

      kGi_AuxCtrLoadB_RegisterId        = 19,
      kGi_AuxCtrLoadBId                 = nNIMXRegisterMap120_mBuildFieldId(tGi_AuxCtrLoadB_Register::kGi_AuxCtrLoadBId, kGi_AuxCtrLoadB_RegisterId),

      kGi_AutomaticLoadRegisterId       = 20,
      kGi_AutoLdRegisterId              = nNIMXRegisterMap120_mBuildFieldId(tGi_AutomaticLoadRegister::kGi_AutoLdRegisterId, kGi_AutomaticLoadRegisterId),

      kGi_Interrupt1_RegisterId         = 21,
      kGi_Aux_Ctr_TC_Error_Interrupt_EnId     = nNIMXRegisterMap120_mBuildFieldId(tGi_Interrupt1_Register::kGi_Aux_Ctr_TC_Error_Interrupt_EnId, kGi_Interrupt1_RegisterId),
      kGi_Aux_Ctr_TC_Interrupt_EnId     = nNIMXRegisterMap120_mBuildFieldId(tGi_Interrupt1_Register::kGi_Aux_Ctr_TC_Interrupt_EnId, kGi_Interrupt1_RegisterId),
      kGi_Disarm_Interrupt_EnId         = nNIMXRegisterMap120_mBuildFieldId(tGi_Interrupt1_Register::kGi_Disarm_Interrupt_EnId, kGi_Interrupt1_RegisterId),
      kGi_SampleClockInterruptEnId      = nNIMXRegisterMap120_mBuildFieldId(tGi_Interrupt1_Register::kGi_SampleClockInterruptEnId, kGi_Interrupt1_RegisterId),
      kGi_GateSwitchErrorInt_EnId       = nNIMXRegisterMap120_mBuildFieldId(tGi_Interrupt1_Register::kGi_GateSwitchErrorInt_EnId, kGi_Interrupt1_RegisterId),
      kGi_WritesTooFastErrorEnId        = nNIMXRegisterMap120_mBuildFieldId(tGi_Interrupt1_Register::kGi_WritesTooFastErrorEnId, kGi_Interrupt1_RegisterId),
      kGi_DMA_Int_EnableId              = nNIMXRegisterMap120_mBuildFieldId(tGi_Interrupt1_Register::kGi_DMA_Int_EnableId, kGi_Interrupt1_RegisterId),
      kGi_Gate_Interrupt_EnableId       = nNIMXRegisterMap120_mBuildFieldId(tGi_Interrupt1_Register::kGi_Gate_Interrupt_EnableId, kGi_Interrupt1_RegisterId),
      kGi_TC_Interrupt_EnableId         = nNIMXRegisterMap120_mBuildFieldId(tGi_Interrupt1_Register::kGi_TC_Interrupt_EnableId, kGi_Interrupt1_RegisterId),
      kGi_SampleClockOverrunIntEnId     = nNIMXRegisterMap120_mBuildFieldId(tGi_Interrupt1_Register::kGi_SampleClockOverrunIntEnId, kGi_Interrupt1_RegisterId),
      kGi_Gate_Error_Interrupt_EnabledId    = nNIMXRegisterMap120_mBuildFieldId(tGi_Interrupt1_Register::kGi_Gate_Error_Interrupt_EnabledId, kGi_Interrupt1_RegisterId),
      kGi_TC_Error_Interrupt_EnableId   = nNIMXRegisterMap120_mBuildFieldId(tGi_Interrupt1_Register::kGi_TC_Error_Interrupt_EnableId, kGi_Interrupt1_RegisterId),
      kGi_DMA_Error_Interrupt_EnableId  = nNIMXRegisterMap120_mBuildFieldId(tGi_Interrupt1_Register::kGi_DMA_Error_Interrupt_EnableId, kGi_Interrupt1_RegisterId),
      kGi_SampleClockOverrunErrorAckId  = nNIMXRegisterMap120_mBuildFieldId(tGi_Interrupt1_Register::kGi_SampleClockOverrunErrorAckId, kGi_Interrupt1_RegisterId),
      kGi_SampleClockInterruptAckId     = nNIMXRegisterMap120_mBuildFieldId(tGi_Interrupt1_Register::kGi_SampleClockInterruptAckId, kGi_Interrupt1_RegisterId),
      kGi_Gate_Error_ConfirmId          = nNIMXRegisterMap120_mBuildFieldId(tGi_Interrupt1_Register::kGi_Gate_Error_ConfirmId, kGi_Interrupt1_RegisterId),
      kGi_TC_Error_ConfirmId            = nNIMXRegisterMap120_mBuildFieldId(tGi_Interrupt1_Register::kGi_TC_Error_ConfirmId, kGi_Interrupt1_RegisterId),
      kGi_Aux_Ctr_TC_Error_Interrupt_AckId      = nNIMXRegisterMap120_mBuildFieldId(tGi_Interrupt1_Register::kGi_Aux_Ctr_TC_Error_Interrupt_AckId, kGi_Interrupt1_RegisterId),
      kGi_Aux_Ctr_TC_Interrupt_AckId    = nNIMXRegisterMap120_mBuildFieldId(tGi_Interrupt1_Register::kGi_Aux_Ctr_TC_Interrupt_AckId, kGi_Interrupt1_RegisterId),
      kGi_Disarm_Interrupt_AckId        = nNIMXRegisterMap120_mBuildFieldId(tGi_Interrupt1_Register::kGi_Disarm_Interrupt_AckId, kGi_Interrupt1_RegisterId),
      kGi_WritesTooFastErrorAckId       = nNIMXRegisterMap120_mBuildFieldId(tGi_Interrupt1_Register::kGi_WritesTooFastErrorAckId, kGi_Interrupt1_RegisterId),
      kGi_GateSwitchError_AckId         = nNIMXRegisterMap120_mBuildFieldId(tGi_Interrupt1_Register::kGi_GateSwitchError_AckId, kGi_Interrupt1_RegisterId),
      kGi_DMA_Error_AckId               = nNIMXRegisterMap120_mBuildFieldId(tGi_Interrupt1_Register::kGi_DMA_Error_AckId, kGi_Interrupt1_RegisterId),
      kGi_TC_Interrupt_AckId            = nNIMXRegisterMap120_mBuildFieldId(tGi_Interrupt1_Register::kGi_TC_Interrupt_AckId, kGi_Interrupt1_RegisterId),
      kGi_Gate_Interrupt_AckId          = nNIMXRegisterMap120_mBuildFieldId(tGi_Interrupt1_Register::kGi_Gate_Interrupt_AckId, kGi_Interrupt1_RegisterId),

      kGi_Interrupt2_RegisterId         = 22,
      kGi_Aux_Ctr_TC_Error_Interrupt_DisId      = nNIMXRegisterMap120_mBuildFieldId(tGi_Interrupt2_Register::kGi_Aux_Ctr_TC_Error_Interrupt_DisId, kGi_Interrupt2_RegisterId),
      kGi_Aux_Ctr_TC_Interrupt_DisId    = nNIMXRegisterMap120_mBuildFieldId(tGi_Interrupt2_Register::kGi_Aux_Ctr_TC_Interrupt_DisId, kGi_Interrupt2_RegisterId),
      kGi_Disarm_Interrupt_DisId        = nNIMXRegisterMap120_mBuildFieldId(tGi_Interrupt2_Register::kGi_Disarm_Interrupt_DisId, kGi_Interrupt2_RegisterId),
      kGi_SampleClockInterruptDisId     = nNIMXRegisterMap120_mBuildFieldId(tGi_Interrupt2_Register::kGi_SampleClockInterruptDisId, kGi_Interrupt2_RegisterId),
      kGi_GateSwitchErrorInt_DisId      = nNIMXRegisterMap120_mBuildFieldId(tGi_Interrupt2_Register::kGi_GateSwitchErrorInt_DisId, kGi_Interrupt2_RegisterId),
      kGi_WritesTooFastErrorDisId       = nNIMXRegisterMap120_mBuildFieldId(tGi_Interrupt2_Register::kGi_WritesTooFastErrorDisId, kGi_Interrupt2_RegisterId),
      kGi_DMA_Int_DisableId             = nNIMXRegisterMap120_mBuildFieldId(tGi_Interrupt2_Register::kGi_DMA_Int_DisableId, kGi_Interrupt2_RegisterId),
      kGi_Gate_Interrupt_DisableId      = nNIMXRegisterMap120_mBuildFieldId(tGi_Interrupt2_Register::kGi_Gate_Interrupt_DisableId, kGi_Interrupt2_RegisterId),
      kGi_TC_Interrupt_DisableId        = nNIMXRegisterMap120_mBuildFieldId(tGi_Interrupt2_Register::kGi_TC_Interrupt_DisableId, kGi_Interrupt2_RegisterId),
      kGi_SampleClockOverrunIntDisId    = nNIMXRegisterMap120_mBuildFieldId(tGi_Interrupt2_Register::kGi_SampleClockOverrunIntDisId, kGi_Interrupt2_RegisterId),
      kGi_Gate_Error_Interrupt_DisableId    = nNIMXRegisterMap120_mBuildFieldId(tGi_Interrupt2_Register::kGi_Gate_Error_Interrupt_DisableId, kGi_Interrupt2_RegisterId),
      kGi_TC_Error_Interrupt_DisableId  = nNIMXRegisterMap120_mBuildFieldId(tGi_Interrupt2_Register::kGi_TC_Error_Interrupt_DisableId, kGi_Interrupt2_RegisterId),
      kGi_DMA_Error_Interrupt_DisableId   = nNIMXRegisterMap120_mBuildFieldId(tGi_Interrupt2_Register::kGi_DMA_Error_Interrupt_DisableId, kGi_Interrupt2_RegisterId),
      kGi_SampleClockOverrunErrorAck2Id   = nNIMXRegisterMap120_mBuildFieldId(tGi_Interrupt2_Register::kGi_SampleClockOverrunErrorAck2Id, kGi_Interrupt2_RegisterId),
      kGi_SampleClockInterruptAck2Id    = nNIMXRegisterMap120_mBuildFieldId(tGi_Interrupt2_Register::kGi_SampleClockInterruptAck2Id, kGi_Interrupt2_RegisterId),
      kGi_Gate_Error_Confirm2Id         = nNIMXRegisterMap120_mBuildFieldId(tGi_Interrupt2_Register::kGi_Gate_Error_Confirm2Id, kGi_Interrupt2_RegisterId),
      kGi_TC_Error_Confirm2Id           = nNIMXRegisterMap120_mBuildFieldId(tGi_Interrupt2_Register::kGi_TC_Error_Confirm2Id, kGi_Interrupt2_RegisterId),
      kGi_Aux_Ctr_TC_Error_Interrupt_Ack2Id       = nNIMXRegisterMap120_mBuildFieldId(tGi_Interrupt2_Register::kGi_Aux_Ctr_TC_Error_Interrupt_Ack2Id, kGi_Interrupt2_RegisterId),
      kGi_Aux_Ctr_TC_Interrupt_Ack2Id   = nNIMXRegisterMap120_mBuildFieldId(tGi_Interrupt2_Register::kGi_Aux_Ctr_TC_Interrupt_Ack2Id, kGi_Interrupt2_RegisterId),
      kGi_Disarm_Interrupt_Ack2Id       = nNIMXRegisterMap120_mBuildFieldId(tGi_Interrupt2_Register::kGi_Disarm_Interrupt_Ack2Id, kGi_Interrupt2_RegisterId),
      kGi_WritesTooFastErrorAck2Id      = nNIMXRegisterMap120_mBuildFieldId(tGi_Interrupt2_Register::kGi_WritesTooFastErrorAck2Id, kGi_Interrupt2_RegisterId),
      kGi_GateSwitchError_Ack2Id        = nNIMXRegisterMap120_mBuildFieldId(tGi_Interrupt2_Register::kGi_GateSwitchError_Ack2Id, kGi_Interrupt2_RegisterId),
      kGi_DMA_Error_Ack2Id              = nNIMXRegisterMap120_mBuildFieldId(tGi_Interrupt2_Register::kGi_DMA_Error_Ack2Id, kGi_Interrupt2_RegisterId),
      kGi_TC_Interrupt_Ack2Id           = nNIMXRegisterMap120_mBuildFieldId(tGi_Interrupt2_Register::kGi_TC_Interrupt_Ack2Id, kGi_Interrupt2_RegisterId),
      kGi_Gate_Interrupt_Ack2Id         = nNIMXRegisterMap120_mBuildFieldId(tGi_Interrupt2_Register::kGi_Gate_Interrupt_Ack2Id, kGi_Interrupt2_RegisterId),

      kGi_ABZ_Select_RegisterId         = 23,
      kGi_Z_SelectId                    = nNIMXRegisterMap120_mBuildFieldId(tGi_ABZ_Select_Register::kGi_Z_SelectId, kGi_ABZ_Select_RegisterId),
      kGi_B_SelectId                    = nNIMXRegisterMap120_mBuildFieldId(tGi_ABZ_Select_Register::kGi_B_SelectId, kGi_ABZ_Select_RegisterId),
      kGi_A_SelectId                    = nNIMXRegisterMap120_mBuildFieldId(tGi_ABZ_Select_Register::kGi_A_SelectId, kGi_ABZ_Select_RegisterId),

      kGi_Mode3_RegisterId              = 24,
      kGi_TimeCoherentSemiperiodId      = nNIMXRegisterMap120_mBuildFieldId(tGi_Mode3_Register::kGi_TimeCoherentSemiperiodId, kGi_Mode3_RegisterId),

      kGi_Mode2_RegisterId              = 25,
      kGi_HwArmSyncModeId               = nNIMXRegisterMap120_mBuildFieldId(tGi_Mode2_Register::kGi_HwArmSyncModeId, kGi_Mode2_RegisterId),
      kGi_CtrOutFifoRegenerationEnId    = nNIMXRegisterMap120_mBuildFieldId(tGi_Mode2_Register::kGi_CtrOutFifoRegenerationEnId, kGi_Mode2_RegisterId),
      kGi_StopOnErrorId                 = nNIMXRegisterMap120_mBuildFieldId(tGi_Mode2_Register::kGi_StopOnErrorId, kGi_Mode2_RegisterId),
      kGi_WriteOnSwitchRequestId        = nNIMXRegisterMap120_mBuildFieldId(tGi_Mode2_Register::kGi_WriteOnSwitchRequestId, kGi_Mode2_RegisterId),
      kGi_Bank_Switch_ModeId            = nNIMXRegisterMap120_mBuildFieldId(tGi_Mode2_Register::kGi_Bank_Switch_ModeId, kGi_Mode2_RegisterId),
      kGi_Bank_Switch_EnableId          = nNIMXRegisterMap120_mBuildFieldId(tGi_Mode2_Register::kGi_Bank_Switch_EnableId, kGi_Mode2_RegisterId),
      kGi_Up_DownId                     = nNIMXRegisterMap120_mBuildFieldId(tGi_Mode2_Register::kGi_Up_DownId, kGi_Mode2_RegisterId),


      kMaxRegisterId = 25

   } tId;

   tCounter(tBusSpaceReference addrSpace, nMDBG::tStatus2* statusChain = NULL);
   tCounter();
   void initialize(tBusSpaceReference addrSpace, u32 addressOffset, nMDBG::tStatus2* statusChain = NULL);
   void reset(nMDBG::tStatus2* statusChain = NULL);
   virtual ~tCounter();

   inline tBusSpaceReference getBusSpaceReference(void) const;

   inline void setAddressOffset(u32 value, nMDBG::tStatus2* statusChain = NULL);
   inline u32  getAddressOffset(nMDBG::tStatus2* statusChain = NULL);
   inline tBoolean isDirty(tId id, nMDBG::tStatus2* statusChain = NULL);
   inline void markDirty(tId id, nMDBG::tStatus2* statusChain = NULL);
   inline void markClean(tId id, nMDBG::tStatus2* statusChain = NULL);

   inline void markDirty(nMDBG::tStatus2* statusChain = NULL);
   inline void markClean(nMDBG::tStatus2* statusChain = NULL);

private:
   void _initialize(nMDBG::tStatus2* statusChain = NULL);
   tBusSpaceReference _addrSpace;
   u32 _addressOffset;
   u8 _dirtyVector[26];

};

#ifndef ___tCounter_ipp___
#ifndef ___tCounter_h_no_inline___
#include "tCounter.ipp"
#endif

#endif

#endif


// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// This file is autogenerated!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!

