// Copyright 2011 National Instruments
// License: NATIONAL INSTRUMENTS SOFTWARE LICENSE AGREEMENT
//   Refer to "MHDDK License Agreement.pdf" in the root of this distribution.

// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// This file is autogenerated!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!

#ifndef ___tInTimer_h___
#define ___tInTimer_h___

// includes
#include "osiTypes.h"
#include "osiBus.h"
#include "tInTimerValues.h"


#ifndef ___tInTimerValues_h___
#include "tInTimerValues.h"
#endif

#ifndef nNIMXRegisterMap120_mBuildFieldId

// Algorithm:
//    Move lowermost 5 bits (4 through 0) of field id to uppermost 5 bits (31
//          through 27)
//    Move bit 5 of field id to bit 26
//    Move bit 6 of field id to bit 25
//    OR in the register id (which is allowed the remaining bits)
//
// Why not move the lowermost 7 bits directly to the uppermost 7 bits? Because
// we originally moved only the lowermost 5, and for backwards compatibility,
// we can't change where those 5 bits end up.
//
// For future expansion purposes, the bits beyond the first 5 are put in reverse
// order in the resulting combined id.
#define nNIMXRegisterMap120_mBuildFieldId(fieldId, regId) \
   ( \
     ((fieldId) << 27) | \
     ((((fieldId) >> 5) & 0x1) << 26) | \
     ((((fieldId) >> 6) & 0x1) << 25) | \
     (regId) \
   )

#endif

#ifndef nNIMXRegisterMap120_mExtractFieldId

// Algorithm: (basically the reverse of mBuildFieldId)
//    Move uppermost 5 bits (31 through 27) to lowermost 5 bits (4 through 0)
//    Move 26th bit to bit 5 (right-shifting by (26 - 5) is like right-shifting
//          by 26 then left-shifting by 5, but it's more efficient)
//    Move 25th bit to bit 6
#define nNIMXRegisterMap120_mExtractFieldId(id) \
   (unsigned int) \
   ( \
     (((id) >> 27) & 0x1F) | \
     (((id) & (0x1 << 26)) >> (26 - 5)) | \
     (((id) & (0x1 << 25)) >> (25 - 6)) \
   )

#endif

class tInTimer
{
public:
   //---------------------------------------------------------------------------
   // IO Strategies
   //---------------------------------------------------------------------------
   class tReg16IODirect32
   {
   public:
      inline void write(
         tBusSpaceReference addrSpace,
         u32 offset,
         u16 value,
         nMDBG::tStatus2* statusChain = NULL);

      inline u16 read(
         tBusSpaceReference addrSpace,
         u32 offset,
         nMDBG::tStatus2* statusChain = NULL);
   };

   class tReg32IODirect32
   {
   public:
      inline void write(
         tBusSpaceReference addrSpace,
         u32 offset,
         u32 value,
         nMDBG::tStatus2* statusChain = NULL);

      inline u32 read(
         tBusSpaceReference addrSpace,
         u32 offset,
         nMDBG::tStatus2* statusChain = NULL);
   };

   //---------------------------------------------------------------------------
   // Command_Register
   //---------------------------------------------------------------------------
   class tCommand_Register : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tInTimer tRegisterMap;

      enum {
         kOffset = 0x0,
         kId     = 0
      };
      tCommand_Register();


      typedef enum {
         kRegisterId                          = 0,
         kCONVERT_PulseId                  = 1,
         kSI_Cancel_Load_SwitchId          = 2,
         kLOCALMUX_CLK_PulseId             = 3,
         kEXTMUX_CLK_PulseId               = 4,
         kSC_LoadId                        = 6,
         kSC_ArmId                         = 7,
         kDIV_LoadId                       = 8,
         kDIV_ArmId                        = 9,
         kSI_LoadId                        = 10,
         kSI_ArmId                         = 11,
         kSI2_LoadId                       = 12,
         kSI2_ArmId                        = 13,
         kDisarmId                         = 14,
         kSTART1_PulseId                   = 16,
         kSTART2_PulseId                   = 17,
         kSTART_PulseId                    = 18,
         kSC_Switch_Load_On_TCId           = 20,
         kSI_Switch_Load_On_TCId           = 22,
         kSI_Switch_Load_On_STOPId         = 23,
         kSI_Switch_Load_On_SC_TCId        = 24,
         kSC_PreWaitCountTC_ErrorAckId     = 26,
         kEnd_On_End_Of_ScanId             = 27,
         kEnd_On_SC_TCId                   = 28,
         kMaxFieldId                          = 28
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Register Accessors (Compile-time selectable)

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);


      // Field Accessors (Compile-time selectable)
      inline void writeCONVERT_Pulse(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeSI_Cancel_Load_Switch(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeLOCALMUX_CLK_Pulse(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeEXTMUX_CLK_Pulse(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeSC_Load(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeSC_Arm(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeDIV_Load(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeDIV_Arm(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeSI_Load(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeSI_Arm(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeSI2_Load(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeSI2_Arm(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeDisarm(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeSTART1_Pulse(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeSTART2_Pulse(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeSTART_Pulse(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeSC_Switch_Load_On_TC(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeSI_Switch_Load_On_TC(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeSI_Switch_Load_On_STOP(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeSI_Switch_Load_On_SC_TC(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeSC_PreWaitCountTC_ErrorAck(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeEnd_On_End_Of_Scan(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeEnd_On_SC_TC(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      tRegisterMap* _regMap;

      // Usage guidelines
      tCommand_Register(const tCommand_Register&);
      tCommand_Register& operator=(const tCommand_Register&);

   };

   //---------------------------------------------------------------------------
   // Status_1_Register
   //---------------------------------------------------------------------------
   class tStatus_1_Register : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tInTimer tRegisterMap;

      enum {
         kOffset = 0x0,
         kId     = 1
      };
      tStatus_1_Register();


      typedef enum {
         kRegisterId                          = 0,
         kFIFO_Request_StId                = 2,
         kSTOP_StId                        = 4,
         kSTART_StId                       = 5,
         kSC_TC_StId                       = 6,
         kSTART1_StId                      = 7,
         kSTART2_StId                      = 8,
         kSC_TC_Error_StId                 = 9,
         kOverflow_StId                    = 10,
         kOverrun_StId                     = 11,
         kFIFO_Empty_StId                  = 12,
         kFIFO_Half_Full_StId              = 13,
         kFIFO_Full_StId                   = 14,
         kScanOverrun_StId                 = 15,
         kSC_Armed_StId                    = 16,
         kSC_Next_Load_Source_StId         = 17,
         kSI_Armed_StId                    = 19,
         kSI_Next_Load_Source_StId         = 20,
         kSI_Counting_StId                 = 21,
         kSI2_Armed_StId                   = 22,
         kSI2_Next_Load_Source_StId        = 23,
         kDIV_Armed_StId                   = 24,
         kSC_Gate_StId                     = 25,
         kStart_Stop_Gate_StId             = 26,
         kSC_PreWaitCountTC_StId           = 27,
         kScan_In_Progress_StId            = 28,
         kExternal_Gate_StId               = 29,
         kLast_Shiftin_StId                = 30,
         kSC_PreWaitCountTC_ErrorStId      = 31,
         kMaxFieldId                          = 31
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Register Accessors (Compile-time selectable)
      inline tStatus_1_Register& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void refresh(nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tStatus_1_Register& setFIFO_Request_St(nInTimer::tInTimer_FIFO_Request_St_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nInTimer::tInTimer_FIFO_Request_St_t getFIFO_Request_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline nInTimer::tInTimer_FIFO_Request_St_t readFIFO_Request_St(nMDBG::tStatus2* statusChain = NULL);

      inline tStatus_1_Register& setSTOP_St(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getSTOP_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u32 readSTOP_St(nMDBG::tStatus2* statusChain = NULL);

      inline tStatus_1_Register& setSTART_St(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getSTART_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u32 readSTART_St(nMDBG::tStatus2* statusChain = NULL);

      inline tStatus_1_Register& setSC_TC_St(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getSC_TC_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u32 readSC_TC_St(nMDBG::tStatus2* statusChain = NULL);

      inline tStatus_1_Register& setSTART1_St(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getSTART1_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u32 readSTART1_St(nMDBG::tStatus2* statusChain = NULL);

      inline tStatus_1_Register& setSTART2_St(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getSTART2_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u32 readSTART2_St(nMDBG::tStatus2* statusChain = NULL);

      inline tStatus_1_Register& setSC_TC_Error_St(nInTimer::tInTimer_Error_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nInTimer::tInTimer_Error_t getSC_TC_Error_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline nInTimer::tInTimer_Error_t readSC_TC_Error_St(nMDBG::tStatus2* statusChain = NULL);

      inline tStatus_1_Register& setOverflow_St(nInTimer::tInTimer_Error_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nInTimer::tInTimer_Error_t getOverflow_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline nInTimer::tInTimer_Error_t readOverflow_St(nMDBG::tStatus2* statusChain = NULL);

      inline tStatus_1_Register& setOverrun_St(nInTimer::tInTimer_Error_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nInTimer::tInTimer_Error_t getOverrun_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline nInTimer::tInTimer_Error_t readOverrun_St(nMDBG::tStatus2* statusChain = NULL);

      inline tStatus_1_Register& setFIFO_Empty_St(nInTimer::tInTimer_FIFO_Empty_St_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nInTimer::tInTimer_FIFO_Empty_St_t getFIFO_Empty_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline nInTimer::tInTimer_FIFO_Empty_St_t readFIFO_Empty_St(nMDBG::tStatus2* statusChain = NULL);

      inline tStatus_1_Register& setFIFO_Half_Full_St(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getFIFO_Half_Full_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u32 readFIFO_Half_Full_St(nMDBG::tStatus2* statusChain = NULL);

      inline tStatus_1_Register& setFIFO_Full_St(nInTimer::tInTimer_FIFO_Full_St_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nInTimer::tInTimer_FIFO_Full_St_t getFIFO_Full_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline nInTimer::tInTimer_FIFO_Full_St_t readFIFO_Full_St(nMDBG::tStatus2* statusChain = NULL);

      inline tStatus_1_Register& setScanOverrun_St(nInTimer::tInTimer_Error_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nInTimer::tInTimer_Error_t getScanOverrun_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline nInTimer::tInTimer_Error_t readScanOverrun_St(nMDBG::tStatus2* statusChain = NULL);

      inline tStatus_1_Register& setSC_Armed_St(nInTimer::tInTimer_Disarmed_Armed_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nInTimer::tInTimer_Disarmed_Armed_t getSC_Armed_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline nInTimer::tInTimer_Disarmed_Armed_t readSC_Armed_St(nMDBG::tStatus2* statusChain = NULL);

      inline tStatus_1_Register& setSC_Next_Load_Source_St(nInTimer::tInTimer_Load_A_Load_B_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nInTimer::tInTimer_Load_A_Load_B_t getSC_Next_Load_Source_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline nInTimer::tInTimer_Load_A_Load_B_t readSC_Next_Load_Source_St(nMDBG::tStatus2* statusChain = NULL);

      inline tStatus_1_Register& setSI_Armed_St(nInTimer::tInTimer_Disarmed_Armed_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nInTimer::tInTimer_Disarmed_Armed_t getSI_Armed_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline nInTimer::tInTimer_Disarmed_Armed_t readSI_Armed_St(nMDBG::tStatus2* statusChain = NULL);

      inline tStatus_1_Register& setSI_Next_Load_Source_St(nInTimer::tInTimer_Load_A_Load_B_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nInTimer::tInTimer_Load_A_Load_B_t getSI_Next_Load_Source_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline nInTimer::tInTimer_Load_A_Load_B_t readSI_Next_Load_Source_St(nMDBG::tStatus2* statusChain = NULL);

      inline tStatus_1_Register& setSI_Counting_St(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getSI_Counting_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u32 readSI_Counting_St(nMDBG::tStatus2* statusChain = NULL);

      inline tStatus_1_Register& setSI2_Armed_St(nInTimer::tInTimer_Disarmed_Armed_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nInTimer::tInTimer_Disarmed_Armed_t getSI2_Armed_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline nInTimer::tInTimer_Disarmed_Armed_t readSI2_Armed_St(nMDBG::tStatus2* statusChain = NULL);

      inline tStatus_1_Register& setSI2_Next_Load_Source_St(nInTimer::tInTimer_Load_A_Load_B_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nInTimer::tInTimer_Load_A_Load_B_t getSI2_Next_Load_Source_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline nInTimer::tInTimer_Load_A_Load_B_t readSI2_Next_Load_Source_St(nMDBG::tStatus2* statusChain = NULL);

      inline tStatus_1_Register& setDIV_Armed_St(nInTimer::tInTimer_Disarmed_Armed_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nInTimer::tInTimer_Disarmed_Armed_t getDIV_Armed_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline nInTimer::tInTimer_Disarmed_Armed_t readDIV_Armed_St(nMDBG::tStatus2* statusChain = NULL);

      inline tStatus_1_Register& setSC_Gate_St(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getSC_Gate_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u32 readSC_Gate_St(nMDBG::tStatus2* statusChain = NULL);

      inline tStatus_1_Register& setStart_Stop_Gate_St(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getStart_Stop_Gate_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u32 readStart_Stop_Gate_St(nMDBG::tStatus2* statusChain = NULL);

      inline tStatus_1_Register& setSC_PreWaitCountTC_St(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getSC_PreWaitCountTC_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u32 readSC_PreWaitCountTC_St(nMDBG::tStatus2* statusChain = NULL);

      inline tStatus_1_Register& setScan_In_Progress_St(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getScan_In_Progress_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u32 readScan_In_Progress_St(nMDBG::tStatus2* statusChain = NULL);

      inline tStatus_1_Register& setExternal_Gate_St(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getExternal_Gate_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u32 readExternal_Gate_St(nMDBG::tStatus2* statusChain = NULL);

      inline tStatus_1_Register& setLast_Shiftin_St(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getLast_Shiftin_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u32 readLast_Shiftin_St(nMDBG::tStatus2* statusChain = NULL);

      inline tStatus_1_Register& setSC_PreWaitCountTC_ErrorSt(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getSC_PreWaitCountTC_ErrorSt(nMDBG::tStatus2* statusChain = NULL) const;

      inline u32 readSC_PreWaitCountTC_ErrorSt(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tStatus_1_Register(const tStatus_1_Register&);
      tStatus_1_Register& operator=(const tStatus_1_Register&);

   };

   //---------------------------------------------------------------------------
   // Mode_1_Register
   //---------------------------------------------------------------------------
   class tMode_1_Register : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tInTimer tRegisterMap;

      enum {
         kOffset = 0x4,
         kId     = 2
      };
      tMode_1_Register();


      typedef enum {
         kRegisterId                          = 0,
         kExportedConvertPolarityId        = 1,
         kSC_Reload_ModeId                 = 2,
         kSC_Initial_Load_SourceId         = 3,
         kSI_Reload_ModeId                 = 5,
         kSI_Initial_Load_SourceId         = 6,
         kSI2_Reload_ModeId                = 7,
         kSI2_Initial_Load_SourceId        = 8,
         kExternal_MUX_PresentId           = 11,
         kPre_TriggerId                    = 12,
         kStart_Stop_Gate_EnableId         = 13,
         kTrigger_OnceId                   = 15,
         kContinuousId                     = 16,
         kSI_Source_PolarityId             = 18,
         kSI_Source_SelectId               = 20,
         kSCAN_IN_PROG_PulseId             = 22,
         kMaxFieldId                          = 22
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Dirty Tracking
      inline tBoolean isDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markClean(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tMode_1_Register& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tMode_1_Register& setExportedConvertPolarity(nInTimer::tInTimer_Polarity_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nInTimer::tInTimer_Polarity_t getExportedConvertPolarity(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeExportedConvertPolarity(nInTimer::tInTimer_Polarity_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nInTimer::tInTimer_Polarity_t readExportedConvertPolarity(nMDBG::tStatus2* statusChain = NULL);

      inline tMode_1_Register& setSC_Reload_Mode(nInTimer::tInTimer_SC_Reload_Mode_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nInTimer::tInTimer_SC_Reload_Mode_t getSC_Reload_Mode(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeSC_Reload_Mode(nInTimer::tInTimer_SC_Reload_Mode_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nInTimer::tInTimer_SC_Reload_Mode_t readSC_Reload_Mode(nMDBG::tStatus2* statusChain = NULL);

      inline tMode_1_Register& setSC_Initial_Load_Source(nInTimer::tInTimer_Load_A_Load_B_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nInTimer::tInTimer_Load_A_Load_B_t getSC_Initial_Load_Source(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeSC_Initial_Load_Source(nInTimer::tInTimer_Load_A_Load_B_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nInTimer::tInTimer_Load_A_Load_B_t readSC_Initial_Load_Source(nMDBG::tStatus2* statusChain = NULL);

      inline tMode_1_Register& setSI_Reload_Mode(nInTimer::tInTimer_SI_Reload_Mode_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nInTimer::tInTimer_SI_Reload_Mode_t getSI_Reload_Mode(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeSI_Reload_Mode(nInTimer::tInTimer_SI_Reload_Mode_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nInTimer::tInTimer_SI_Reload_Mode_t readSI_Reload_Mode(nMDBG::tStatus2* statusChain = NULL);

      inline tMode_1_Register& setSI_Initial_Load_Source(nInTimer::tInTimer_Load_A_Load_B_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nInTimer::tInTimer_Load_A_Load_B_t getSI_Initial_Load_Source(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeSI_Initial_Load_Source(nInTimer::tInTimer_Load_A_Load_B_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nInTimer::tInTimer_Load_A_Load_B_t readSI_Initial_Load_Source(nMDBG::tStatus2* statusChain = NULL);

      inline tMode_1_Register& setSI2_Reload_Mode(nInTimer::tInTimer_SI2_Reload_Mode_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nInTimer::tInTimer_SI2_Reload_Mode_t getSI2_Reload_Mode(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeSI2_Reload_Mode(nInTimer::tInTimer_SI2_Reload_Mode_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nInTimer::tInTimer_SI2_Reload_Mode_t readSI2_Reload_Mode(nMDBG::tStatus2* statusChain = NULL);

      inline tMode_1_Register& setSI2_Initial_Load_Source(nInTimer::tInTimer_Load_A_Load_B_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nInTimer::tInTimer_Load_A_Load_B_t getSI2_Initial_Load_Source(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeSI2_Initial_Load_Source(nInTimer::tInTimer_Load_A_Load_B_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nInTimer::tInTimer_Load_A_Load_B_t readSI2_Initial_Load_Source(nMDBG::tStatus2* statusChain = NULL);

      inline tMode_1_Register& setExternal_MUX_Present(nInTimer::tInTimer_External_MUX_Present_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nInTimer::tInTimer_External_MUX_Present_t getExternal_MUX_Present(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeExternal_MUX_Present(nInTimer::tInTimer_External_MUX_Present_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nInTimer::tInTimer_External_MUX_Present_t readExternal_MUX_Present(nMDBG::tStatus2* statusChain = NULL);

      inline tMode_1_Register& setPre_Trigger(nInTimer::tInTimer_Pre_Trigger_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nInTimer::tInTimer_Pre_Trigger_t getPre_Trigger(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writePre_Trigger(nInTimer::tInTimer_Pre_Trigger_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nInTimer::tInTimer_Pre_Trigger_t readPre_Trigger(nMDBG::tStatus2* statusChain = NULL);

      inline tMode_1_Register& setStart_Stop_Gate_Enable(nInTimer::tInTimer_Disabled_Enabled_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nInTimer::tInTimer_Disabled_Enabled_t getStart_Stop_Gate_Enable(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeStart_Stop_Gate_Enable(nInTimer::tInTimer_Disabled_Enabled_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nInTimer::tInTimer_Disabled_Enabled_t readStart_Stop_Gate_Enable(nMDBG::tStatus2* statusChain = NULL);

      inline tMode_1_Register& setTrigger_Once(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getTrigger_Once(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeTrigger_Once(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u32 readTrigger_Once(nMDBG::tStatus2* statusChain = NULL);

      inline tMode_1_Register& setContinuous(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getContinuous(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeContinuous(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u32 readContinuous(nMDBG::tStatus2* statusChain = NULL);

      inline tMode_1_Register& setSI_Source_Polarity(nInTimer::tInTimer_SI_Source_Polarity_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nInTimer::tInTimer_SI_Source_Polarity_t getSI_Source_Polarity(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeSI_Source_Polarity(nInTimer::tInTimer_SI_Source_Polarity_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nInTimer::tInTimer_SI_Source_Polarity_t readSI_Source_Polarity(nMDBG::tStatus2* statusChain = NULL);

      inline tMode_1_Register& setSI_Source_Select(nInTimer::tInTimer_SI_Source_Select_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nInTimer::tInTimer_SI_Source_Select_t getSI_Source_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeSI_Source_Select(nInTimer::tInTimer_SI_Source_Select_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nInTimer::tInTimer_SI_Source_Select_t readSI_Source_Select(nMDBG::tStatus2* statusChain = NULL);

      inline tMode_1_Register& setSCAN_IN_PROG_Pulse(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getSCAN_IN_PROG_Pulse(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeSCAN_IN_PROG_Pulse(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u32 readSCAN_IN_PROG_Pulse(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tMode_1_Register(const tMode_1_Register&);
      tMode_1_Register& operator=(const tMode_1_Register&);

   };

   //---------------------------------------------------------------------------
   // Status_2_Register
   //---------------------------------------------------------------------------
   class tStatus_2_Register : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tInTimer tRegisterMap;

      enum {
         kOffset = 0x4,
         kId     = 3
      };
      tStatus_2_Register();


      typedef enum {
         kRegisterId                          = 0,
         kSI_Load_Switch_Pending_StId      = 1,
         kSC_Q_StId                        = 3,
         kSI2_Q_StId                       = 5,
         kSI_Q_StId                        = 7,
         kDIV_Q_StId                       = 9,
         kMaxFieldId                          = 9
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Register Accessors (Compile-time selectable)
      inline tStatus_2_Register& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void refresh(nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tStatus_2_Register& setSI_Load_Switch_Pending_St(nInTimer::tInTimer_SI_Load_Switch_Pending_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nInTimer::tInTimer_SI_Load_Switch_Pending_t getSI_Load_Switch_Pending_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline nInTimer::tInTimer_SI_Load_Switch_Pending_t readSI_Load_Switch_Pending_St(nMDBG::tStatus2* statusChain = NULL);

      inline tStatus_2_Register& setSC_Q_St(nInTimer::tInTimer_SC_Q_St_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nInTimer::tInTimer_SC_Q_St_t getSC_Q_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline nInTimer::tInTimer_SC_Q_St_t readSC_Q_St(nMDBG::tStatus2* statusChain = NULL);

      inline tStatus_2_Register& setSI2_Q_St(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getSI2_Q_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u32 readSI2_Q_St(nMDBG::tStatus2* statusChain = NULL);

      inline tStatus_2_Register& setSI_Q_St(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getSI_Q_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u32 readSI_Q_St(nMDBG::tStatus2* statusChain = NULL);

      inline tStatus_2_Register& setDIV_Q_St(nInTimer::tInTimer_Idle_Counting_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nInTimer::tInTimer_Idle_Counting_t getDIV_Q_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline nInTimer::tInTimer_Idle_Counting_t readDIV_Q_St(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tStatus_2_Register(const tStatus_2_Register&);
      tStatus_2_Register& operator=(const tStatus_2_Register&);

   };

   //---------------------------------------------------------------------------
   // Mode_2_Register
   //---------------------------------------------------------------------------
   class tMode_2_Register : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tInTimer tRegisterMap;

      enum {
         kOffset = 0x8,
         kId     = 4
      };
      tMode_2_Register();


      typedef enum {
         kRegisterId                          = 0,
         kEXTMUX_CLK_Pulse_WidthId         = 2,
         kEXTMUX_CLK_PolarityId            = 4,
         kSCAN_IN_PROG_PolarityId          = 6,
         kSTART_Output_SelectId            = 7,
         kStart2_Export_ModeId             = 9,
         kStart1_Export_ModeId             = 10,
         kStart_Trigger_LengthId           = 11,
         kSyncModeId                       = 12,
         kFIFO_ModeId                      = 13,
         kExternal_Gate_ModeId             = 14,
         kSI2_Source_SelectId              = 16,
         kSoftware_GateId                  = 18,
         kHaltOnErrorId                    = 19,
         kMaxFieldId                          = 19
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Dirty Tracking
      inline tBoolean isDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markClean(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tMode_2_Register& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tMode_2_Register& setEXTMUX_CLK_Pulse_Width(nInTimer::tInTimer_EXTMUX_CLK_Pulse_Width_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nInTimer::tInTimer_EXTMUX_CLK_Pulse_Width_t getEXTMUX_CLK_Pulse_Width(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeEXTMUX_CLK_Pulse_Width(nInTimer::tInTimer_EXTMUX_CLK_Pulse_Width_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nInTimer::tInTimer_EXTMUX_CLK_Pulse_Width_t readEXTMUX_CLK_Pulse_Width(nMDBG::tStatus2* statusChain = NULL);

      inline tMode_2_Register& setEXTMUX_CLK_Polarity(nInTimer::tInTimer_Polarity_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nInTimer::tInTimer_Polarity_t getEXTMUX_CLK_Polarity(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeEXTMUX_CLK_Polarity(nInTimer::tInTimer_Polarity_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nInTimer::tInTimer_Polarity_t readEXTMUX_CLK_Polarity(nMDBG::tStatus2* statusChain = NULL);

      inline tMode_2_Register& setSCAN_IN_PROG_Polarity(nInTimer::tInTimer_Polarity_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nInTimer::tInTimer_Polarity_t getSCAN_IN_PROG_Polarity(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeSCAN_IN_PROG_Polarity(nInTimer::tInTimer_Polarity_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nInTimer::tInTimer_Polarity_t readSCAN_IN_PROG_Polarity(nMDBG::tStatus2* statusChain = NULL);

      inline tMode_2_Register& setSTART_Output_Select(nInTimer::tInTimer_START_Output_Select_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nInTimer::tInTimer_START_Output_Select_t getSTART_Output_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeSTART_Output_Select(nInTimer::tInTimer_START_Output_Select_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nInTimer::tInTimer_START_Output_Select_t readSTART_Output_Select(nMDBG::tStatus2* statusChain = NULL);

      inline tMode_2_Register& setStart2_Export_Mode(nInTimer::tInTimer_Start2_Export_Mode_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nInTimer::tInTimer_Start2_Export_Mode_t getStart2_Export_Mode(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeStart2_Export_Mode(nInTimer::tInTimer_Start2_Export_Mode_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nInTimer::tInTimer_Start2_Export_Mode_t readStart2_Export_Mode(nMDBG::tStatus2* statusChain = NULL);

      inline tMode_2_Register& setStart1_Export_Mode(nInTimer::tInTimer_Start1_Export_Mode_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nInTimer::tInTimer_Start1_Export_Mode_t getStart1_Export_Mode(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeStart1_Export_Mode(nInTimer::tInTimer_Start1_Export_Mode_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nInTimer::tInTimer_Start1_Export_Mode_t readStart1_Export_Mode(nMDBG::tStatus2* statusChain = NULL);

      inline tMode_2_Register& setStart_Trigger_Length(nInTimer::tInTimer_Start_Trigger_Length_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nInTimer::tInTimer_Start_Trigger_Length_t getStart_Trigger_Length(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeStart_Trigger_Length(nInTimer::tInTimer_Start_Trigger_Length_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nInTimer::tInTimer_Start_Trigger_Length_t readStart_Trigger_Length(nMDBG::tStatus2* statusChain = NULL);

      inline tMode_2_Register& setSyncMode(nInTimer::tInTimer_SyncMode_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nInTimer::tInTimer_SyncMode_t getSyncMode(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeSyncMode(nInTimer::tInTimer_SyncMode_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nInTimer::tInTimer_SyncMode_t readSyncMode(nMDBG::tStatus2* statusChain = NULL);

      inline tMode_2_Register& setFIFO_Mode(nInTimer::tInTimer_FIFO_Mode_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nInTimer::tInTimer_FIFO_Mode_t getFIFO_Mode(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeFIFO_Mode(nInTimer::tInTimer_FIFO_Mode_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nInTimer::tInTimer_FIFO_Mode_t readFIFO_Mode(nMDBG::tStatus2* statusChain = NULL);

      inline tMode_2_Register& setExternal_Gate_Mode(nInTimer::tInTimer_External_Gate_Mode_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nInTimer::tInTimer_External_Gate_Mode_t getExternal_Gate_Mode(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeExternal_Gate_Mode(nInTimer::tInTimer_External_Gate_Mode_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nInTimer::tInTimer_External_Gate_Mode_t readExternal_Gate_Mode(nMDBG::tStatus2* statusChain = NULL);

      inline tMode_2_Register& setSI2_Source_Select(nInTimer::tInTimer_SI2_Source_Select_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nInTimer::tInTimer_SI2_Source_Select_t getSI2_Source_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeSI2_Source_Select(nInTimer::tInTimer_SI2_Source_Select_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nInTimer::tInTimer_SI2_Source_Select_t readSI2_Source_Select(nMDBG::tStatus2* statusChain = NULL);

      inline tMode_2_Register& setSoftware_Gate(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getSoftware_Gate(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeSoftware_Gate(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u32 readSoftware_Gate(nMDBG::tStatus2* statusChain = NULL);

      inline tMode_2_Register& setHaltOnError(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getHaltOnError(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeHaltOnError(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u32 readHaltOnError(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tMode_2_Register(const tMode_2_Register&);
      tMode_2_Register& operator=(const tMode_2_Register&);

   };

   //---------------------------------------------------------------------------
   // SI_Save_Register
   //---------------------------------------------------------------------------
   class tSI_Save_Register : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tInTimer tRegisterMap;

      enum {
         kOffset = 0x8,
         kId     = 5
      };
      tSI_Save_Register();


      typedef enum {
         kRegisterId                          = 0,
         kSI_Save_ValueId                  = 1,
         kMaxFieldId                          = 1
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Register Accessors (Compile-time selectable)
      inline tSI_Save_Register& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void refresh(nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tSI_Save_Register& setSI_Save_Value(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getSI_Save_Value(nMDBG::tStatus2* statusChain = NULL) const;

      inline u32 readSI_Save_Value(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tSI_Save_Register(const tSI_Save_Register&);
      tSI_Save_Register& operator=(const tSI_Save_Register&);

   };

   //---------------------------------------------------------------------------
   // SC_Save_Register
   //---------------------------------------------------------------------------
   class tSC_Save_Register : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tInTimer tRegisterMap;

      enum {
         kOffset = 0xc,
         kId     = 6
      };
      tSC_Save_Register();


      typedef enum {
         kRegisterId                          = 0,
         kSC_Save_ValueId                  = 1,
         kMaxFieldId                          = 1
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Register Accessors (Compile-time selectable)
      inline tSC_Save_Register& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void refresh(nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tSC_Save_Register& setSC_Save_Value(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getSC_Save_Value(nMDBG::tStatus2* statusChain = NULL) const;

      inline u32 readSC_Save_Value(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tSC_Save_Register(const tSC_Save_Register&);
      tSC_Save_Register& operator=(const tSC_Save_Register&);

   };

   //---------------------------------------------------------------------------
   // SI_Load_A_Register
   //---------------------------------------------------------------------------
   class tSI_Load_A_Register : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tInTimer tRegisterMap;

      enum {
         kOffset = 0xc,
         kId     = 7
      };
      tSI_Load_A_Register();


      typedef enum {
         kRegisterId                          = 0,
         kSI_Load_AId                      = 1,
         kMaxFieldId                          = 1
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Dirty Tracking
      inline tBoolean isDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markClean(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tSI_Load_A_Register& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tSI_Load_A_Register& setSI_Load_A(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getSI_Load_A(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeSI_Load_A(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u32 readSI_Load_A(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tSI_Load_A_Register(const tSI_Load_A_Register&);
      tSI_Load_A_Register& operator=(const tSI_Load_A_Register&);

   };

   //---------------------------------------------------------------------------
   // SI2_Save_Register
   //---------------------------------------------------------------------------
   class tSI2_Save_Register : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tInTimer tRegisterMap;

      enum {
         kOffset = 0x10,
         kId     = 8
      };
      tSI2_Save_Register();


      typedef enum {
         kRegisterId                          = 0,
         kSI2_Save_ValueId                 = 1,
         kMaxFieldId                          = 1
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Register Accessors (Compile-time selectable)
      inline tSI2_Save_Register& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void refresh(nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tSI2_Save_Register& setSI2_Save_Value(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getSI2_Save_Value(nMDBG::tStatus2* statusChain = NULL) const;

      inline u32 readSI2_Save_Value(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tSI2_Save_Register(const tSI2_Save_Register&);
      tSI2_Save_Register& operator=(const tSI2_Save_Register&);

   };

   //---------------------------------------------------------------------------
   // SI_Load_B_Register
   //---------------------------------------------------------------------------
   class tSI_Load_B_Register : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tInTimer tRegisterMap;

      enum {
         kOffset = 0x10,
         kId     = 9
      };
      tSI_Load_B_Register();


      typedef enum {
         kRegisterId                          = 0,
         kSI_Load_BId                      = 1,
         kMaxFieldId                          = 1
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Dirty Tracking
      inline tBoolean isDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markClean(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tSI_Load_B_Register& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tSI_Load_B_Register& setSI_Load_B(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getSI_Load_B(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeSI_Load_B(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u32 readSI_Load_B(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tSI_Load_B_Register(const tSI_Load_B_Register&);
      tSI_Load_B_Register& operator=(const tSI_Load_B_Register&);

   };

   //---------------------------------------------------------------------------
   // DIV_Save_Register
   //---------------------------------------------------------------------------
   class tDIV_Save_Register : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tInTimer tRegisterMap;

      enum {
         kOffset = 0x14,
         kId     = 10
      };
      tDIV_Save_Register();


      typedef enum {
         kRegisterId                          = 0,
         kDIV_Save_ValueId                 = 1,
         kMaxFieldId                          = 1
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Register Accessors (Compile-time selectable)
      inline tDIV_Save_Register& setRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void refresh(nMDBG::tStatus2* statusChain = NULL);

      inline u16 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tDIV_Save_Register& setDIV_Save_Value(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getDIV_Save_Value(nMDBG::tStatus2* statusChain = NULL) const;

      inline u16 readDIV_Save_Value(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u16 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tDIV_Save_Register(const tDIV_Save_Register&);
      tDIV_Save_Register& operator=(const tDIV_Save_Register&);

   };

   //---------------------------------------------------------------------------
   // SC_Load_A_Register
   //---------------------------------------------------------------------------
   class tSC_Load_A_Register : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tInTimer tRegisterMap;

      enum {
         kOffset = 0x14,
         kId     = 11
      };
      tSC_Load_A_Register();


      typedef enum {
         kRegisterId                          = 0,
         kSC_Load_AId                      = 1,
         kMaxFieldId                          = 1
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Dirty Tracking
      inline tBoolean isDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markClean(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tSC_Load_A_Register& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tSC_Load_A_Register& setSC_Load_A(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getSC_Load_A(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeSC_Load_A(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u32 readSC_Load_A(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tSC_Load_A_Register(const tSC_Load_A_Register&);
      tSC_Load_A_Register& operator=(const tSC_Load_A_Register&);

   };

   //---------------------------------------------------------------------------
   // SC_Load_B_Register
   //---------------------------------------------------------------------------
   class tSC_Load_B_Register : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tInTimer tRegisterMap;

      enum {
         kOffset = 0x18,
         kId     = 12
      };
      tSC_Load_B_Register();


      typedef enum {
         kRegisterId                          = 0,
         kSC_Load_BId                      = 1,
         kMaxFieldId                          = 1
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Dirty Tracking
      inline tBoolean isDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markClean(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tSC_Load_B_Register& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tSC_Load_B_Register& setSC_Load_B(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getSC_Load_B(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeSC_Load_B(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u32 readSC_Load_B(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tSC_Load_B_Register(const tSC_Load_B_Register&);
      tSC_Load_B_Register& operator=(const tSC_Load_B_Register&);

   };

   //---------------------------------------------------------------------------
   // SC_PreWaitCntRegister
   //---------------------------------------------------------------------------
   class tSC_PreWaitCntRegister : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tInTimer tRegisterMap;

      enum {
         kOffset = 0x18,
         kId     = 13
      };
      tSC_PreWaitCntRegister();


      typedef enum {
         kRegisterId                          = 0,
         kSC_PreWaitCountId                = 1,
         kMaxFieldId                          = 1
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Register Accessors (Compile-time selectable)
      inline tSC_PreWaitCntRegister& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void refresh(nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tSC_PreWaitCntRegister& setSC_PreWaitCount(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getSC_PreWaitCount(nMDBG::tStatus2* statusChain = NULL) const;

      inline u32 readSC_PreWaitCount(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tSC_PreWaitCntRegister(const tSC_PreWaitCntRegister&);
      tSC_PreWaitCntRegister& operator=(const tSC_PreWaitCntRegister&);

   };

   //---------------------------------------------------------------------------
   // SI2_Load_A_Register
   //---------------------------------------------------------------------------
   class tSI2_Load_A_Register : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tInTimer tRegisterMap;

      enum {
         kOffset = 0x1c,
         kId     = 14
      };
      tSI2_Load_A_Register();


      typedef enum {
         kRegisterId                          = 0,
         kSI2_Load_AId                     = 1,
         kMaxFieldId                          = 1
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Dirty Tracking
      inline tBoolean isDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markClean(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tSI2_Load_A_Register& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tSI2_Load_A_Register& setSI2_Load_A(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getSI2_Load_A(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeSI2_Load_A(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u32 readSI2_Load_A(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tSI2_Load_A_Register(const tSI2_Load_A_Register&);
      tSI2_Load_A_Register& operator=(const tSI2_Load_A_Register&);

   };

   //---------------------------------------------------------------------------
   // SI2_Load_B_Register
   //---------------------------------------------------------------------------
   class tSI2_Load_B_Register : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tInTimer tRegisterMap;

      enum {
         kOffset = 0x20,
         kId     = 15
      };
      tSI2_Load_B_Register();


      typedef enum {
         kRegisterId                          = 0,
         kSI2_Load_BId                     = 1,
         kMaxFieldId                          = 1
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Dirty Tracking
      inline tBoolean isDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markClean(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tSI2_Load_B_Register& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tSI2_Load_B_Register& setSI2_Load_B(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getSI2_Load_B(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeSI2_Load_B(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u32 readSI2_Load_B(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tSI2_Load_B_Register(const tSI2_Load_B_Register&);
      tSI2_Load_B_Register& operator=(const tSI2_Load_B_Register&);

   };

   //---------------------------------------------------------------------------
   // DIV_Load_A_Register
   //---------------------------------------------------------------------------
   class tDIV_Load_A_Register : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tInTimer tRegisterMap;

      enum {
         kOffset = 0x24,
         kId     = 16
      };
      tDIV_Load_A_Register();


      typedef enum {
         kRegisterId                          = 0,
         kDIV_Load_AId                     = 1,
         kMaxFieldId                          = 1
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Dirty Tracking
      inline tBoolean isDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markClean(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tDIV_Load_A_Register& setRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline void writeRegister(u16 value, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u16 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tDIV_Load_A_Register& setDIV_Load_A(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getDIV_Load_A(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeDIV_Load_A(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u16 readDIV_Load_A(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u16 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tDIV_Load_A_Register(const tDIV_Load_A_Register&);
      tDIV_Load_A_Register& operator=(const tDIV_Load_A_Register&);

   };

   //---------------------------------------------------------------------------
   // Interrupt1_Register
   //---------------------------------------------------------------------------
   class tInterrupt1_Register : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tInTimer tRegisterMap;

      enum {
         kOffset = 0x2c,
         kId     = 17
      };
      tInterrupt1_Register();


      typedef enum {
         kRegisterId                          = 0,
         kSC_TC_Interrupt_EnableId         = 1,
         kSTART1_Interrupt_EnableId        = 2,
         kSTART2_Interrupt_EnableId        = 3,
         kSTART_Interrupt_EnableId         = 4,
         kSTOP_Interrupt_EnableId          = 5,
         kOverrun_Interrupt_EnableId       = 6,
         kOverflow_Interrupt_EnableId      = 7,
         kFIFO_Interrupt_EnableId          = 8,
         kScanOverrun_Interrupt_EnableId   = 9,
         kSC_PreWaitCountTC_Interrupt_EnableId       = 10,
         kScanOverrun_Interrupt_AckId      = 12,
         kSC_TC_Error_ConfirmId            = 13,
         kSC_TC_Interrupt_AckId            = 14,
         kSTART1_Interrupt_AckId           = 15,
         kSTART2_Interrupt_AckId           = 16,
         kSTART_Interrupt_AckId            = 17,
         kSTOP_Interrupt_AckId             = 18,
         kOverrun_Interrupt_AckId          = 19,
         kSC_PreWaitCountTC_Interrupt_AckId    = 20,
         kOverflow_Interrupt_AckId         = 21,
         kMaxFieldId                          = 21
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Register Accessors (Compile-time selectable)

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);


      // Field Accessors (Compile-time selectable)
      inline void writeSC_TC_Interrupt_Enable(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeSTART1_Interrupt_Enable(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeSTART2_Interrupt_Enable(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeSTART_Interrupt_Enable(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeSTOP_Interrupt_Enable(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeOverrun_Interrupt_Enable(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeOverflow_Interrupt_Enable(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeFIFO_Interrupt_Enable(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeScanOverrun_Interrupt_Enable(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeSC_PreWaitCountTC_Interrupt_Enable(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeScanOverrun_Interrupt_Ack(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeSC_TC_Error_Confirm(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeSC_TC_Interrupt_Ack(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeSTART1_Interrupt_Ack(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeSTART2_Interrupt_Ack(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeSTART_Interrupt_Ack(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeSTOP_Interrupt_Ack(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeOverrun_Interrupt_Ack(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeSC_PreWaitCountTC_Interrupt_Ack(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeOverflow_Interrupt_Ack(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      tRegisterMap* _regMap;

      // Usage guidelines
      tInterrupt1_Register(const tInterrupt1_Register&);
      tInterrupt1_Register& operator=(const tInterrupt1_Register&);

   };

   //---------------------------------------------------------------------------
   // Interrupt2_Register
   //---------------------------------------------------------------------------
   class tInterrupt2_Register : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tInTimer tRegisterMap;

      enum {
         kOffset = 0x30,
         kId     = 18
      };
      tInterrupt2_Register();


      typedef enum {
         kRegisterId                          = 0,
         kSC_TC_Interrupt_DisableId        = 1,
         kSTART1_Interrupt_DisableId       = 2,
         kSTART2_Interrupt_DisableId       = 3,
         kSTART_Interrupt_DisableId        = 4,
         kSTOP_Interrupt_DisableId         = 5,
         kOverrun_Interrupt_DisableId      = 6,
         kOverflow_Interrupt_DisableId     = 7,
         kFIFO_Interrupt_DisableId         = 8,
         kScanOverrun_Interrupt_DisableId  = 9,
         kSC_PreWaitCountTC_Interrupt_DisableId        = 10,
         kScanOverrun_Interrupt_Ack2Id     = 12,
         kSC_TC_Error_Confirm2Id           = 13,
         kSC_TC_Interrupt_Ack2Id           = 14,
         kSTART1_Interrupt_Ack2Id          = 15,
         kSTART2_Interrupt_Ack2Id          = 16,
         kSTART_Interrupt_Ack2Id           = 17,
         kSTOP_Interrupt_Ack2Id            = 18,
         kOverrun_Interrupt_Ack2Id         = 19,
         kSC_PreWaitCountTC_Interrupt_Ack2Id     = 20,
         kOverflow_Interrupt_Ack2Id        = 21,
         kMaxFieldId                          = 21
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Register Accessors (Compile-time selectable)

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);


      // Field Accessors (Compile-time selectable)
      inline void writeSC_TC_Interrupt_Disable(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeSTART1_Interrupt_Disable(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeSTART2_Interrupt_Disable(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeSTART_Interrupt_Disable(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeSTOP_Interrupt_Disable(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeOverrun_Interrupt_Disable(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeOverflow_Interrupt_Disable(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeFIFO_Interrupt_Disable(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeScanOverrun_Interrupt_Disable(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeSC_PreWaitCountTC_Interrupt_Disable(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeScanOverrun_Interrupt_Ack2(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeSC_TC_Error_Confirm2(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeSC_TC_Interrupt_Ack2(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeSTART1_Interrupt_Ack2(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeSTART2_Interrupt_Ack2(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeSTART_Interrupt_Ack2(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeSTOP_Interrupt_Ack2(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeOverrun_Interrupt_Ack2(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeSC_PreWaitCountTC_Interrupt_Ack2(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeOverflow_Interrupt_Ack2(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      tRegisterMap* _regMap;

      // Usage guidelines
      tInterrupt2_Register(const tInterrupt2_Register&);
      tInterrupt2_Register& operator=(const tInterrupt2_Register&);

   };

   //---------------------------------------------------------------------------
   // Reset_Register
   //---------------------------------------------------------------------------
   class tReset_Register : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tInTimer tRegisterMap;

      enum {
         kOffset = 0x38,
         kId     = 19
      };
      tReset_Register();


      typedef enum {
         kRegisterId                          = 0,
         kResetId                          = 1,
         kConfiguration_StartId            = 2,
         kConfiguration_EndId              = 3,
         kConfiguration_Memory_ClearId     = 4,
         kFIFO_ClearId                     = 5,
         kMaxFieldId                          = 5
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Register Accessors (Compile-time selectable)

      inline void writeRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);


      // Field Accessors (Compile-time selectable)
      inline void writeReset(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeConfiguration_Start(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeConfiguration_End(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeConfiguration_Memory_Clear(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeFIFO_Clear(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      tRegisterMap* _regMap;

      // Usage guidelines
      tReset_Register(const tReset_Register&);
      tReset_Register& operator=(const tReset_Register&);

   };

   //---------------------------------------------------------------------------
   // Command_Register
   //---------------------------------------------------------------------------
   tCommand_Register Command_Register;

   //---------------------------------------------------------------------------
   // Status_1_Register
   //---------------------------------------------------------------------------
   tStatus_1_Register Status_1_Register;

   //---------------------------------------------------------------------------
   // Mode_1_Register
   //---------------------------------------------------------------------------
   tMode_1_Register Mode_1_Register;

   //---------------------------------------------------------------------------
   // Status_2_Register
   //---------------------------------------------------------------------------
   tStatus_2_Register Status_2_Register;

   //---------------------------------------------------------------------------
   // Mode_2_Register
   //---------------------------------------------------------------------------
   tMode_2_Register Mode_2_Register;

   //---------------------------------------------------------------------------
   // SI_Save_Register
   //---------------------------------------------------------------------------
   tSI_Save_Register SI_Save_Register;

   //---------------------------------------------------------------------------
   // SC_Save_Register
   //---------------------------------------------------------------------------
   tSC_Save_Register SC_Save_Register;

   //---------------------------------------------------------------------------
   // SI_Load_A_Register
   //---------------------------------------------------------------------------
   tSI_Load_A_Register SI_Load_A_Register;

   //---------------------------------------------------------------------------
   // SI2_Save_Register
   //---------------------------------------------------------------------------
   tSI2_Save_Register SI2_Save_Register;

   //---------------------------------------------------------------------------
   // SI_Load_B_Register
   //---------------------------------------------------------------------------
   tSI_Load_B_Register SI_Load_B_Register;

   //---------------------------------------------------------------------------
   // DIV_Save_Register
   //---------------------------------------------------------------------------
   tDIV_Save_Register DIV_Save_Register;

   //---------------------------------------------------------------------------
   // SC_Load_A_Register
   //---------------------------------------------------------------------------
   tSC_Load_A_Register SC_Load_A_Register;

   //---------------------------------------------------------------------------
   // SC_Load_B_Register
   //---------------------------------------------------------------------------
   tSC_Load_B_Register SC_Load_B_Register;

   //---------------------------------------------------------------------------
   // SC_PreWaitCntRegister
   //---------------------------------------------------------------------------
   tSC_PreWaitCntRegister SC_PreWaitCntRegister;

   //---------------------------------------------------------------------------
   // SI2_Load_A_Register
   //---------------------------------------------------------------------------
   tSI2_Load_A_Register SI2_Load_A_Register;

   //---------------------------------------------------------------------------
   // SI2_Load_B_Register
   //---------------------------------------------------------------------------
   tSI2_Load_B_Register SI2_Load_B_Register;

   //---------------------------------------------------------------------------
   // DIV_Load_A_Register
   //---------------------------------------------------------------------------
   tDIV_Load_A_Register DIV_Load_A_Register;

   //---------------------------------------------------------------------------
   // Interrupt1_Register
   //---------------------------------------------------------------------------
   tInterrupt1_Register Interrupt1_Register;

   //---------------------------------------------------------------------------
   // Interrupt2_Register
   //---------------------------------------------------------------------------
   tInterrupt2_Register Interrupt2_Register;

   //---------------------------------------------------------------------------
   // Reset_Register
   //---------------------------------------------------------------------------
   tReset_Register Reset_Register;

   //---------------------------------------------------------------------------
   // Register Groups
   //---------------------------------------------------------------------------

   //----------------------------------------
   // Register/Field Ids
   //----------------------------------------
   typedef enum {
      kCommand_RegisterId               = 0,
      kCONVERT_PulseId                  = nNIMXRegisterMap120_mBuildFieldId(tCommand_Register::kCONVERT_PulseId, kCommand_RegisterId),
      kSI_Cancel_Load_SwitchId          = nNIMXRegisterMap120_mBuildFieldId(tCommand_Register::kSI_Cancel_Load_SwitchId, kCommand_RegisterId),
      kLOCALMUX_CLK_PulseId             = nNIMXRegisterMap120_mBuildFieldId(tCommand_Register::kLOCALMUX_CLK_PulseId, kCommand_RegisterId),
      kEXTMUX_CLK_PulseId               = nNIMXRegisterMap120_mBuildFieldId(tCommand_Register::kEXTMUX_CLK_PulseId, kCommand_RegisterId),
      kSC_LoadId                        = nNIMXRegisterMap120_mBuildFieldId(tCommand_Register::kSC_LoadId, kCommand_RegisterId),
      kSC_ArmId                         = nNIMXRegisterMap120_mBuildFieldId(tCommand_Register::kSC_ArmId, kCommand_RegisterId),
      kDIV_LoadId                       = nNIMXRegisterMap120_mBuildFieldId(tCommand_Register::kDIV_LoadId, kCommand_RegisterId),
      kDIV_ArmId                        = nNIMXRegisterMap120_mBuildFieldId(tCommand_Register::kDIV_ArmId, kCommand_RegisterId),
      kSI_LoadId                        = nNIMXRegisterMap120_mBuildFieldId(tCommand_Register::kSI_LoadId, kCommand_RegisterId),
      kSI_ArmId                         = nNIMXRegisterMap120_mBuildFieldId(tCommand_Register::kSI_ArmId, kCommand_RegisterId),
      kSI2_LoadId                       = nNIMXRegisterMap120_mBuildFieldId(tCommand_Register::kSI2_LoadId, kCommand_RegisterId),
      kSI2_ArmId                        = nNIMXRegisterMap120_mBuildFieldId(tCommand_Register::kSI2_ArmId, kCommand_RegisterId),
      kDisarmId                         = nNIMXRegisterMap120_mBuildFieldId(tCommand_Register::kDisarmId, kCommand_RegisterId),
      kSTART1_PulseId                   = nNIMXRegisterMap120_mBuildFieldId(tCommand_Register::kSTART1_PulseId, kCommand_RegisterId),
      kSTART2_PulseId                   = nNIMXRegisterMap120_mBuildFieldId(tCommand_Register::kSTART2_PulseId, kCommand_RegisterId),
      kSTART_PulseId                    = nNIMXRegisterMap120_mBuildFieldId(tCommand_Register::kSTART_PulseId, kCommand_RegisterId),
      kSC_Switch_Load_On_TCId           = nNIMXRegisterMap120_mBuildFieldId(tCommand_Register::kSC_Switch_Load_On_TCId, kCommand_RegisterId),
      kSI_Switch_Load_On_TCId           = nNIMXRegisterMap120_mBuildFieldId(tCommand_Register::kSI_Switch_Load_On_TCId, kCommand_RegisterId),
      kSI_Switch_Load_On_STOPId         = nNIMXRegisterMap120_mBuildFieldId(tCommand_Register::kSI_Switch_Load_On_STOPId, kCommand_RegisterId),
      kSI_Switch_Load_On_SC_TCId        = nNIMXRegisterMap120_mBuildFieldId(tCommand_Register::kSI_Switch_Load_On_SC_TCId, kCommand_RegisterId),
      kSC_PreWaitCountTC_ErrorAckId     = nNIMXRegisterMap120_mBuildFieldId(tCommand_Register::kSC_PreWaitCountTC_ErrorAckId, kCommand_RegisterId),
      kEnd_On_End_Of_ScanId             = nNIMXRegisterMap120_mBuildFieldId(tCommand_Register::kEnd_On_End_Of_ScanId, kCommand_RegisterId),
      kEnd_On_SC_TCId                   = nNIMXRegisterMap120_mBuildFieldId(tCommand_Register::kEnd_On_SC_TCId, kCommand_RegisterId),

      kStatus_1_RegisterId              = 1,
      kFIFO_Request_StId                = nNIMXRegisterMap120_mBuildFieldId(tStatus_1_Register::kFIFO_Request_StId, kStatus_1_RegisterId),
      kSTOP_StId                        = nNIMXRegisterMap120_mBuildFieldId(tStatus_1_Register::kSTOP_StId, kStatus_1_RegisterId),
      kSTART_StId                       = nNIMXRegisterMap120_mBuildFieldId(tStatus_1_Register::kSTART_StId, kStatus_1_RegisterId),
      kSC_TC_StId                       = nNIMXRegisterMap120_mBuildFieldId(tStatus_1_Register::kSC_TC_StId, kStatus_1_RegisterId),
      kSTART1_StId                      = nNIMXRegisterMap120_mBuildFieldId(tStatus_1_Register::kSTART1_StId, kStatus_1_RegisterId),
      kSTART2_StId                      = nNIMXRegisterMap120_mBuildFieldId(tStatus_1_Register::kSTART2_StId, kStatus_1_RegisterId),
      kSC_TC_Error_StId                 = nNIMXRegisterMap120_mBuildFieldId(tStatus_1_Register::kSC_TC_Error_StId, kStatus_1_RegisterId),
      kOverflow_StId                    = nNIMXRegisterMap120_mBuildFieldId(tStatus_1_Register::kOverflow_StId, kStatus_1_RegisterId),
      kOverrun_StId                     = nNIMXRegisterMap120_mBuildFieldId(tStatus_1_Register::kOverrun_StId, kStatus_1_RegisterId),
      kFIFO_Empty_StId                  = nNIMXRegisterMap120_mBuildFieldId(tStatus_1_Register::kFIFO_Empty_StId, kStatus_1_RegisterId),
      kFIFO_Half_Full_StId              = nNIMXRegisterMap120_mBuildFieldId(tStatus_1_Register::kFIFO_Half_Full_StId, kStatus_1_RegisterId),
      kFIFO_Full_StId                   = nNIMXRegisterMap120_mBuildFieldId(tStatus_1_Register::kFIFO_Full_StId, kStatus_1_RegisterId),
      kScanOverrun_StId                 = nNIMXRegisterMap120_mBuildFieldId(tStatus_1_Register::kScanOverrun_StId, kStatus_1_RegisterId),
      kSC_Armed_StId                    = nNIMXRegisterMap120_mBuildFieldId(tStatus_1_Register::kSC_Armed_StId, kStatus_1_RegisterId),
      kSC_Next_Load_Source_StId         = nNIMXRegisterMap120_mBuildFieldId(tStatus_1_Register::kSC_Next_Load_Source_StId, kStatus_1_RegisterId),
      kSI_Armed_StId                    = nNIMXRegisterMap120_mBuildFieldId(tStatus_1_Register::kSI_Armed_StId, kStatus_1_RegisterId),
      kSI_Next_Load_Source_StId         = nNIMXRegisterMap120_mBuildFieldId(tStatus_1_Register::kSI_Next_Load_Source_StId, kStatus_1_RegisterId),
      kSI_Counting_StId                 = nNIMXRegisterMap120_mBuildFieldId(tStatus_1_Register::kSI_Counting_StId, kStatus_1_RegisterId),
      kSI2_Armed_StId                   = nNIMXRegisterMap120_mBuildFieldId(tStatus_1_Register::kSI2_Armed_StId, kStatus_1_RegisterId),
      kSI2_Next_Load_Source_StId        = nNIMXRegisterMap120_mBuildFieldId(tStatus_1_Register::kSI2_Next_Load_Source_StId, kStatus_1_RegisterId),
      kDIV_Armed_StId                   = nNIMXRegisterMap120_mBuildFieldId(tStatus_1_Register::kDIV_Armed_StId, kStatus_1_RegisterId),
      kSC_Gate_StId                     = nNIMXRegisterMap120_mBuildFieldId(tStatus_1_Register::kSC_Gate_StId, kStatus_1_RegisterId),
      kStart_Stop_Gate_StId             = nNIMXRegisterMap120_mBuildFieldId(tStatus_1_Register::kStart_Stop_Gate_StId, kStatus_1_RegisterId),
      kSC_PreWaitCountTC_StId           = nNIMXRegisterMap120_mBuildFieldId(tStatus_1_Register::kSC_PreWaitCountTC_StId, kStatus_1_RegisterId),
      kScan_In_Progress_StId            = nNIMXRegisterMap120_mBuildFieldId(tStatus_1_Register::kScan_In_Progress_StId, kStatus_1_RegisterId),
      kExternal_Gate_StId               = nNIMXRegisterMap120_mBuildFieldId(tStatus_1_Register::kExternal_Gate_StId, kStatus_1_RegisterId),
      kLast_Shiftin_StId                = nNIMXRegisterMap120_mBuildFieldId(tStatus_1_Register::kLast_Shiftin_StId, kStatus_1_RegisterId),
      kSC_PreWaitCountTC_ErrorStId      = nNIMXRegisterMap120_mBuildFieldId(tStatus_1_Register::kSC_PreWaitCountTC_ErrorStId, kStatus_1_RegisterId),

      kMode_1_RegisterId                = 2,
      kExportedConvertPolarityId        = nNIMXRegisterMap120_mBuildFieldId(tMode_1_Register::kExportedConvertPolarityId, kMode_1_RegisterId),
      kSC_Reload_ModeId                 = nNIMXRegisterMap120_mBuildFieldId(tMode_1_Register::kSC_Reload_ModeId, kMode_1_RegisterId),
      kSC_Initial_Load_SourceId         = nNIMXRegisterMap120_mBuildFieldId(tMode_1_Register::kSC_Initial_Load_SourceId, kMode_1_RegisterId),
      kSI_Reload_ModeId                 = nNIMXRegisterMap120_mBuildFieldId(tMode_1_Register::kSI_Reload_ModeId, kMode_1_RegisterId),
      kSI_Initial_Load_SourceId         = nNIMXRegisterMap120_mBuildFieldId(tMode_1_Register::kSI_Initial_Load_SourceId, kMode_1_RegisterId),
      kSI2_Reload_ModeId                = nNIMXRegisterMap120_mBuildFieldId(tMode_1_Register::kSI2_Reload_ModeId, kMode_1_RegisterId),
      kSI2_Initial_Load_SourceId        = nNIMXRegisterMap120_mBuildFieldId(tMode_1_Register::kSI2_Initial_Load_SourceId, kMode_1_RegisterId),
      kExternal_MUX_PresentId           = nNIMXRegisterMap120_mBuildFieldId(tMode_1_Register::kExternal_MUX_PresentId, kMode_1_RegisterId),
      kPre_TriggerId                    = nNIMXRegisterMap120_mBuildFieldId(tMode_1_Register::kPre_TriggerId, kMode_1_RegisterId),
      kStart_Stop_Gate_EnableId         = nNIMXRegisterMap120_mBuildFieldId(tMode_1_Register::kStart_Stop_Gate_EnableId, kMode_1_RegisterId),
      kTrigger_OnceId                   = nNIMXRegisterMap120_mBuildFieldId(tMode_1_Register::kTrigger_OnceId, kMode_1_RegisterId),
      kContinuousId                     = nNIMXRegisterMap120_mBuildFieldId(tMode_1_Register::kContinuousId, kMode_1_RegisterId),
      kSI_Source_PolarityId             = nNIMXRegisterMap120_mBuildFieldId(tMode_1_Register::kSI_Source_PolarityId, kMode_1_RegisterId),
      kSI_Source_SelectId               = nNIMXRegisterMap120_mBuildFieldId(tMode_1_Register::kSI_Source_SelectId, kMode_1_RegisterId),
      kSCAN_IN_PROG_PulseId             = nNIMXRegisterMap120_mBuildFieldId(tMode_1_Register::kSCAN_IN_PROG_PulseId, kMode_1_RegisterId),

      kStatus_2_RegisterId              = 3,
      kSI_Load_Switch_Pending_StId      = nNIMXRegisterMap120_mBuildFieldId(tStatus_2_Register::kSI_Load_Switch_Pending_StId, kStatus_2_RegisterId),
      kSC_Q_StId                        = nNIMXRegisterMap120_mBuildFieldId(tStatus_2_Register::kSC_Q_StId, kStatus_2_RegisterId),
      kSI2_Q_StId                       = nNIMXRegisterMap120_mBuildFieldId(tStatus_2_Register::kSI2_Q_StId, kStatus_2_RegisterId),
      kSI_Q_StId                        = nNIMXRegisterMap120_mBuildFieldId(tStatus_2_Register::kSI_Q_StId, kStatus_2_RegisterId),
      kDIV_Q_StId                       = nNIMXRegisterMap120_mBuildFieldId(tStatus_2_Register::kDIV_Q_StId, kStatus_2_RegisterId),

      kMode_2_RegisterId                = 4,
      kEXTMUX_CLK_Pulse_WidthId         = nNIMXRegisterMap120_mBuildFieldId(tMode_2_Register::kEXTMUX_CLK_Pulse_WidthId, kMode_2_RegisterId),
      kEXTMUX_CLK_PolarityId            = nNIMXRegisterMap120_mBuildFieldId(tMode_2_Register::kEXTMUX_CLK_PolarityId, kMode_2_RegisterId),
      kSCAN_IN_PROG_PolarityId          = nNIMXRegisterMap120_mBuildFieldId(tMode_2_Register::kSCAN_IN_PROG_PolarityId, kMode_2_RegisterId),
      kSTART_Output_SelectId            = nNIMXRegisterMap120_mBuildFieldId(tMode_2_Register::kSTART_Output_SelectId, kMode_2_RegisterId),
      kStart2_Export_ModeId             = nNIMXRegisterMap120_mBuildFieldId(tMode_2_Register::kStart2_Export_ModeId, kMode_2_RegisterId),
      kStart1_Export_ModeId             = nNIMXRegisterMap120_mBuildFieldId(tMode_2_Register::kStart1_Export_ModeId, kMode_2_RegisterId),
      kStart_Trigger_LengthId           = nNIMXRegisterMap120_mBuildFieldId(tMode_2_Register::kStart_Trigger_LengthId, kMode_2_RegisterId),
      kSyncModeId                       = nNIMXRegisterMap120_mBuildFieldId(tMode_2_Register::kSyncModeId, kMode_2_RegisterId),
      kFIFO_ModeId                      = nNIMXRegisterMap120_mBuildFieldId(tMode_2_Register::kFIFO_ModeId, kMode_2_RegisterId),
      kExternal_Gate_ModeId             = nNIMXRegisterMap120_mBuildFieldId(tMode_2_Register::kExternal_Gate_ModeId, kMode_2_RegisterId),
      kSI2_Source_SelectId              = nNIMXRegisterMap120_mBuildFieldId(tMode_2_Register::kSI2_Source_SelectId, kMode_2_RegisterId),
      kSoftware_GateId                  = nNIMXRegisterMap120_mBuildFieldId(tMode_2_Register::kSoftware_GateId, kMode_2_RegisterId),
      kHaltOnErrorId                    = nNIMXRegisterMap120_mBuildFieldId(tMode_2_Register::kHaltOnErrorId, kMode_2_RegisterId),

      kSI_Save_RegisterId               = 5,
      kSI_Save_ValueId                  = nNIMXRegisterMap120_mBuildFieldId(tSI_Save_Register::kSI_Save_ValueId, kSI_Save_RegisterId),

      kSC_Save_RegisterId               = 6,
      kSC_Save_ValueId                  = nNIMXRegisterMap120_mBuildFieldId(tSC_Save_Register::kSC_Save_ValueId, kSC_Save_RegisterId),

      kSI_Load_A_RegisterId             = 7,
      kSI_Load_AId                      = nNIMXRegisterMap120_mBuildFieldId(tSI_Load_A_Register::kSI_Load_AId, kSI_Load_A_RegisterId),

      kSI2_Save_RegisterId              = 8,
      kSI2_Save_ValueId                 = nNIMXRegisterMap120_mBuildFieldId(tSI2_Save_Register::kSI2_Save_ValueId, kSI2_Save_RegisterId),

      kSI_Load_B_RegisterId             = 9,
      kSI_Load_BId                      = nNIMXRegisterMap120_mBuildFieldId(tSI_Load_B_Register::kSI_Load_BId, kSI_Load_B_RegisterId),

      kDIV_Save_RegisterId              = 10,
      kDIV_Save_ValueId                 = nNIMXRegisterMap120_mBuildFieldId(tDIV_Save_Register::kDIV_Save_ValueId, kDIV_Save_RegisterId),

      kSC_Load_A_RegisterId             = 11,
      kSC_Load_AId                      = nNIMXRegisterMap120_mBuildFieldId(tSC_Load_A_Register::kSC_Load_AId, kSC_Load_A_RegisterId),

      kSC_Load_B_RegisterId             = 12,
      kSC_Load_BId                      = nNIMXRegisterMap120_mBuildFieldId(tSC_Load_B_Register::kSC_Load_BId, kSC_Load_B_RegisterId),

      kSC_PreWaitCntRegisterId          = 13,
      kSC_PreWaitCountId                = nNIMXRegisterMap120_mBuildFieldId(tSC_PreWaitCntRegister::kSC_PreWaitCountId, kSC_PreWaitCntRegisterId),

      kSI2_Load_A_RegisterId            = 14,
      kSI2_Load_AId                     = nNIMXRegisterMap120_mBuildFieldId(tSI2_Load_A_Register::kSI2_Load_AId, kSI2_Load_A_RegisterId),

      kSI2_Load_B_RegisterId            = 15,
      kSI2_Load_BId                     = nNIMXRegisterMap120_mBuildFieldId(tSI2_Load_B_Register::kSI2_Load_BId, kSI2_Load_B_RegisterId),

      kDIV_Load_A_RegisterId            = 16,
      kDIV_Load_AId                     = nNIMXRegisterMap120_mBuildFieldId(tDIV_Load_A_Register::kDIV_Load_AId, kDIV_Load_A_RegisterId),

      kInterrupt1_RegisterId            = 17,
      kSC_TC_Interrupt_EnableId         = nNIMXRegisterMap120_mBuildFieldId(tInterrupt1_Register::kSC_TC_Interrupt_EnableId, kInterrupt1_RegisterId),
      kSTART1_Interrupt_EnableId        = nNIMXRegisterMap120_mBuildFieldId(tInterrupt1_Register::kSTART1_Interrupt_EnableId, kInterrupt1_RegisterId),
      kSTART2_Interrupt_EnableId        = nNIMXRegisterMap120_mBuildFieldId(tInterrupt1_Register::kSTART2_Interrupt_EnableId, kInterrupt1_RegisterId),
      kSTART_Interrupt_EnableId         = nNIMXRegisterMap120_mBuildFieldId(tInterrupt1_Register::kSTART_Interrupt_EnableId, kInterrupt1_RegisterId),
      kSTOP_Interrupt_EnableId          = nNIMXRegisterMap120_mBuildFieldId(tInterrupt1_Register::kSTOP_Interrupt_EnableId, kInterrupt1_RegisterId),
      kOverrun_Interrupt_EnableId       = nNIMXRegisterMap120_mBuildFieldId(tInterrupt1_Register::kOverrun_Interrupt_EnableId, kInterrupt1_RegisterId),
      kOverflow_Interrupt_EnableId      = nNIMXRegisterMap120_mBuildFieldId(tInterrupt1_Register::kOverflow_Interrupt_EnableId, kInterrupt1_RegisterId),
      kFIFO_Interrupt_EnableId          = nNIMXRegisterMap120_mBuildFieldId(tInterrupt1_Register::kFIFO_Interrupt_EnableId, kInterrupt1_RegisterId),
      kScanOverrun_Interrupt_EnableId   = nNIMXRegisterMap120_mBuildFieldId(tInterrupt1_Register::kScanOverrun_Interrupt_EnableId, kInterrupt1_RegisterId),
      kSC_PreWaitCountTC_Interrupt_EnableId       = nNIMXRegisterMap120_mBuildFieldId(tInterrupt1_Register::kSC_PreWaitCountTC_Interrupt_EnableId, kInterrupt1_RegisterId),
      kScanOverrun_Interrupt_AckId      = nNIMXRegisterMap120_mBuildFieldId(tInterrupt1_Register::kScanOverrun_Interrupt_AckId, kInterrupt1_RegisterId),
      kSC_TC_Error_ConfirmId            = nNIMXRegisterMap120_mBuildFieldId(tInterrupt1_Register::kSC_TC_Error_ConfirmId, kInterrupt1_RegisterId),
      kSC_TC_Interrupt_AckId            = nNIMXRegisterMap120_mBuildFieldId(tInterrupt1_Register::kSC_TC_Interrupt_AckId, kInterrupt1_RegisterId),
      kSTART1_Interrupt_AckId           = nNIMXRegisterMap120_mBuildFieldId(tInterrupt1_Register::kSTART1_Interrupt_AckId, kInterrupt1_RegisterId),
      kSTART2_Interrupt_AckId           = nNIMXRegisterMap120_mBuildFieldId(tInterrupt1_Register::kSTART2_Interrupt_AckId, kInterrupt1_RegisterId),
      kSTART_Interrupt_AckId            = nNIMXRegisterMap120_mBuildFieldId(tInterrupt1_Register::kSTART_Interrupt_AckId, kInterrupt1_RegisterId),
      kSTOP_Interrupt_AckId             = nNIMXRegisterMap120_mBuildFieldId(tInterrupt1_Register::kSTOP_Interrupt_AckId, kInterrupt1_RegisterId),
      kOverrun_Interrupt_AckId          = nNIMXRegisterMap120_mBuildFieldId(tInterrupt1_Register::kOverrun_Interrupt_AckId, kInterrupt1_RegisterId),
      kSC_PreWaitCountTC_Interrupt_AckId    = nNIMXRegisterMap120_mBuildFieldId(tInterrupt1_Register::kSC_PreWaitCountTC_Interrupt_AckId, kInterrupt1_RegisterId),
      kOverflow_Interrupt_AckId         = nNIMXRegisterMap120_mBuildFieldId(tInterrupt1_Register::kOverflow_Interrupt_AckId, kInterrupt1_RegisterId),

      kInterrupt2_RegisterId            = 18,
      kSC_TC_Interrupt_DisableId        = nNIMXRegisterMap120_mBuildFieldId(tInterrupt2_Register::kSC_TC_Interrupt_DisableId, kInterrupt2_RegisterId),
      kSTART1_Interrupt_DisableId       = nNIMXRegisterMap120_mBuildFieldId(tInterrupt2_Register::kSTART1_Interrupt_DisableId, kInterrupt2_RegisterId),
      kSTART2_Interrupt_DisableId       = nNIMXRegisterMap120_mBuildFieldId(tInterrupt2_Register::kSTART2_Interrupt_DisableId, kInterrupt2_RegisterId),
      kSTART_Interrupt_DisableId        = nNIMXRegisterMap120_mBuildFieldId(tInterrupt2_Register::kSTART_Interrupt_DisableId, kInterrupt2_RegisterId),
      kSTOP_Interrupt_DisableId         = nNIMXRegisterMap120_mBuildFieldId(tInterrupt2_Register::kSTOP_Interrupt_DisableId, kInterrupt2_RegisterId),
      kOverrun_Interrupt_DisableId      = nNIMXRegisterMap120_mBuildFieldId(tInterrupt2_Register::kOverrun_Interrupt_DisableId, kInterrupt2_RegisterId),
      kOverflow_Interrupt_DisableId     = nNIMXRegisterMap120_mBuildFieldId(tInterrupt2_Register::kOverflow_Interrupt_DisableId, kInterrupt2_RegisterId),
      kFIFO_Interrupt_DisableId         = nNIMXRegisterMap120_mBuildFieldId(tInterrupt2_Register::kFIFO_Interrupt_DisableId, kInterrupt2_RegisterId),
      kScanOverrun_Interrupt_DisableId  = nNIMXRegisterMap120_mBuildFieldId(tInterrupt2_Register::kScanOverrun_Interrupt_DisableId, kInterrupt2_RegisterId),
      kSC_PreWaitCountTC_Interrupt_DisableId        = nNIMXRegisterMap120_mBuildFieldId(tInterrupt2_Register::kSC_PreWaitCountTC_Interrupt_DisableId, kInterrupt2_RegisterId),
      kScanOverrun_Interrupt_Ack2Id     = nNIMXRegisterMap120_mBuildFieldId(tInterrupt2_Register::kScanOverrun_Interrupt_Ack2Id, kInterrupt2_RegisterId),
      kSC_TC_Error_Confirm2Id           = nNIMXRegisterMap120_mBuildFieldId(tInterrupt2_Register::kSC_TC_Error_Confirm2Id, kInterrupt2_RegisterId),
      kSC_TC_Interrupt_Ack2Id           = nNIMXRegisterMap120_mBuildFieldId(tInterrupt2_Register::kSC_TC_Interrupt_Ack2Id, kInterrupt2_RegisterId),
      kSTART1_Interrupt_Ack2Id          = nNIMXRegisterMap120_mBuildFieldId(tInterrupt2_Register::kSTART1_Interrupt_Ack2Id, kInterrupt2_RegisterId),
      kSTART2_Interrupt_Ack2Id          = nNIMXRegisterMap120_mBuildFieldId(tInterrupt2_Register::kSTART2_Interrupt_Ack2Id, kInterrupt2_RegisterId),
      kSTART_Interrupt_Ack2Id           = nNIMXRegisterMap120_mBuildFieldId(tInterrupt2_Register::kSTART_Interrupt_Ack2Id, kInterrupt2_RegisterId),
      kSTOP_Interrupt_Ack2Id            = nNIMXRegisterMap120_mBuildFieldId(tInterrupt2_Register::kSTOP_Interrupt_Ack2Id, kInterrupt2_RegisterId),
      kOverrun_Interrupt_Ack2Id         = nNIMXRegisterMap120_mBuildFieldId(tInterrupt2_Register::kOverrun_Interrupt_Ack2Id, kInterrupt2_RegisterId),
      kSC_PreWaitCountTC_Interrupt_Ack2Id     = nNIMXRegisterMap120_mBuildFieldId(tInterrupt2_Register::kSC_PreWaitCountTC_Interrupt_Ack2Id, kInterrupt2_RegisterId),
      kOverflow_Interrupt_Ack2Id        = nNIMXRegisterMap120_mBuildFieldId(tInterrupt2_Register::kOverflow_Interrupt_Ack2Id, kInterrupt2_RegisterId),

      kReset_RegisterId                 = 19,
      kResetId                          = nNIMXRegisterMap120_mBuildFieldId(tReset_Register::kResetId, kReset_RegisterId),
      kConfiguration_StartId            = nNIMXRegisterMap120_mBuildFieldId(tReset_Register::kConfiguration_StartId, kReset_RegisterId),
      kConfiguration_EndId              = nNIMXRegisterMap120_mBuildFieldId(tReset_Register::kConfiguration_EndId, kReset_RegisterId),
      kConfiguration_Memory_ClearId     = nNIMXRegisterMap120_mBuildFieldId(tReset_Register::kConfiguration_Memory_ClearId, kReset_RegisterId),
      kFIFO_ClearId                     = nNIMXRegisterMap120_mBuildFieldId(tReset_Register::kFIFO_ClearId, kReset_RegisterId),


      kMaxRegisterId = 19

   } tId;

   tInTimer(tBusSpaceReference addrSpace, nMDBG::tStatus2* statusChain = NULL);
   tInTimer();
   void initialize(tBusSpaceReference addrSpace, u32 addressOffset, nMDBG::tStatus2* statusChain = NULL);
   void reset(nMDBG::tStatus2* statusChain = NULL);
   virtual ~tInTimer();

   inline tBusSpaceReference getBusSpaceReference(void) const;

   inline void setAddressOffset(u32 value, nMDBG::tStatus2* statusChain = NULL);
   inline u32  getAddressOffset(nMDBG::tStatus2* statusChain = NULL);
   inline tBoolean isDirty(tId id, nMDBG::tStatus2* statusChain = NULL);
   inline void markDirty(tId id, nMDBG::tStatus2* statusChain = NULL);
   inline void markClean(tId id, nMDBG::tStatus2* statusChain = NULL);

   inline void markDirty(nMDBG::tStatus2* statusChain = NULL);
   inline void markClean(nMDBG::tStatus2* statusChain = NULL);

private:
   void _initialize(nMDBG::tStatus2* statusChain = NULL);
   tBusSpaceReference _addrSpace;
   u32 _addressOffset;
   u8 _dirtyVector[20];

};

#ifndef ___tInTimer_ipp___
#ifndef ___tInTimer_h_no_inline___
#include "tInTimer.ipp"
#endif

#endif

#endif


// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// This file is autogenerated!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!

