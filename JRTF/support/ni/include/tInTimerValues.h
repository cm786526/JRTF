// Copyright 2011 National Instruments
// License: NATIONAL INSTRUMENTS SOFTWARE LICENSE AGREEMENT
//   Refer to "MHDDK License Agreement.pdf" in the root of this distribution.

// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// This file is autogenerated!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!

#ifndef ___tInTimerValues_h___
#define ___tInTimerValues_h___

namespace nInTimer {
   typedef enum {
      kDisabled                          = 0,
      kEnabled                           = 1,
   } tInTimer_Disabled_Enabled_t;

   typedef enum {
      kDisarmed                          = 0,
      kArmed                             = 1,
   } tInTimer_Disarmed_Armed_t;

   typedef enum {
      kExtMuxPulseLong                   = 0,
      kExtMuxPulseShort                  = 1,
   } tInTimer_EXTMUX_CLK_Pulse_Width_t;

   typedef enum {
      kNO_ERROR                          = 0,
      kERROR                             = 1,
   } tInTimer_Error_t;

   typedef enum {
      kFree_Run                          = 0,
      kHalt_Gating                       = 1,
   } tInTimer_External_Gate_Mode_t;

   typedef enum {
      kEvery_Convert                     = 0,
      kDIV_TC_Converts                   = 1,
   } tInTimer_External_MUX_Present_t;

   typedef enum {
      kNot_Empty                         = 0,
      kEmpty                             = 1,
   } tInTimer_FIFO_Empty_St_t;

   typedef enum {
      kNot_Full                          = 0,
      kFull                              = 1,
   } tInTimer_FIFO_Full_St_t;

   typedef enum {
      kFifoMode_Not_Empty                = 0,
      kFifoMode_Half_Full                = 1,
      kFifoMode_Full                     = 2,
      kFifoMode_Half_Full_Until_Empty    = 3,
   } tInTimer_FIFO_Mode_t;

   typedef enum {
      kNot_Asserted                      = 0,
      kAsserted                          = 1,
   } tInTimer_FIFO_Request_St_t;

   typedef enum {
      kIdle                              = 0,
      kCounting                          = 1,
   } tInTimer_Idle_Counting_t;

   typedef enum {
      kLoad_A                            = 0,
      kLoad_B                            = 1,
   } tInTimer_Load_A_Load_B_t;

   typedef enum {
      kActive_High                       = 0,
      kActive_Low                        = 1,
   } tInTimer_Polarity_t;

   typedef enum {
      kPosttrigger                       = 0,
      kPretrigger                        = 1,
   } tInTimer_Pre_Trigger_t;

   typedef enum {
      kSC_Idle                           = 0,
      kSC_WaitforStart1                  = 1,
      kSC_PreCounting                    = 2,
      kSC_PreWait                        = 3,
      kSC_WaitForStartOfSample           = 4,
      kSC_Counting                       = 5,
   } tInTimer_SC_Q_St_t;

   typedef enum {
      kSC_Reload_No_Change               = 0,
      kSC_Reload_Switch                  = 1,
   } tInTimer_SC_Reload_Mode_t;

   typedef enum {
      kSI2_Reload_NoChange               = 0,
      kSI2_Reload_Alt_First_Period_Every_STOP        = 1,
   } tInTimer_SI2_Reload_Mode_t;

   typedef enum {
      kSI2_Src_Is_SI_Src                 = 0,
      kSI2_Src_IsTB3                     = 1,
   } tInTimer_SI2_Source_Select_t;

   typedef enum {
      kNo_Switch_Pending                 = 0,
      kSwitch_Pending                    = 1,
   } tInTimer_SI_Load_Switch_Pending_t;

   typedef enum {
      kSI_Reload_No_Change               = 0,
      kSI_Reload_Alt_First_Period_Every_STOP       = 4,
      kSI_Reload_Switch_Every_STOP       = 5,
      kSI_Reload_Alt_First_Period_Every_SCTC       = 6,
      kSI_Reload_Switch_Every_SCTC       = 7,
   } tInTimer_SI_Reload_Mode_t;

   typedef enum {
      kRising_Edge                       = 0,
      kFalling_Edge                      = 1,
   } tInTimer_SI_Source_Polarity_t;

   typedef enum {
      kSI_Src_TB3                        = 0,
      kSI_Src_PFI0                       = 1,
      kSI_Src_PFI1                       = 2,
      kSI_Src_PFI2                       = 3,
      kSI_Src_PFI3                       = 4,
      kSI_Src_PFI4                       = 5,
      kSI_Src_PFI5                       = 6,
      kSI_Src_PFI6                       = 7,
      kSI_Src_PFI7                       = 8,
      kSI_Src_PFI8                       = 9,
      kSI_Src_PFI9                       = 10,
      kSI_Src_RTSI0                      = 11,
      kSI_Src_RTSI1                      = 12,
      kSI_Src_RTSI2                      = 13,
      kSI_Src_RTSI3                      = 14,
      kSI_Src_RTSI4                      = 15,
      kSI_Src_RTSI5                      = 16,
      kSI_Src_RTSI6                      = 17,
      kSI_Src_TB2                        = 18,
      kSI_Src_DStarA                     = 19,
      kSI_Src_Star_Trigger               = 20,
      kSI_Src_PFI10                      = 21,
      kSI_Src_PFI11                      = 22,
      kSI_Src_PFI12                      = 23,
      kSI_Src_PFI13                      = 24,
      kSI_Src_PFI14                      = 25,
      kSI_Src_PFI15                      = 26,
      kSI_Src_RTSI7                      = 27,
      kSI_Src_TB1                        = 28,
      kSI_Src_PXI_Clk10                  = 29,
      kSI_Src_Analog_Trigger             = 30,
      kSI_Src_DStarB                     = 31,
   } tInTimer_SI_Source_Select_t;

   typedef enum {
      kAI_Start                          = 0,
      kSCAN_IN_PROG                      = 1,
   } tInTimer_START_Output_Select_t;

   typedef enum {
      kExportSynchronizedStart1          = 0,
      kExportEdgeDetectedStart1          = 1,
   } tInTimer_Start1_Export_Mode_t;

   typedef enum {
      kExportUnmaskedStart2              = 0,
      kExportMaskedStart2                = 1,
   } tInTimer_Start2_Export_Mode_t;

   typedef enum {
      kExportSynchronizedStart           = 0,
      kExportExtendedStart               = 1,
   } tInTimer_Start_Trigger_Length_t;

   typedef enum {
      kSyncDefault                       = 0,
      kSyncSlave                         = 1,
      kSyncMaster                        = 2,
   } tInTimer_SyncMode_t;

   namespace nCommand_Register {
      namespace nCONVERT_Pulse {
         enum {
            kMask = 0x1,
            kOffset = 0,
         };
      }

      namespace nSI_Cancel_Load_Switch {
         enum {
            kMask = 0x2,
            kOffset = 0x1,
         };
      }

      namespace nLOCALMUX_CLK_Pulse {
         enum {
            kMask = 0x4,
            kOffset = 0x2,
         };
      }

      namespace nEXTMUX_CLK_Pulse {
         enum {
            kMask = 0x8,
            kOffset = 0x3,
         };
      }

      namespace nSC_Load {
         enum {
            kMask = 0x20,
            kOffset = 0x5,
         };
      }

      namespace nSC_Arm {
         enum {
            kMask = 0x40,
            kOffset = 0x6,
         };
      }

      namespace nDIV_Load {
         enum {
            kMask = 0x80,
            kOffset = 0x7,
         };
      }

      namespace nDIV_Arm {
         enum {
            kMask = 0x100,
            kOffset = 0x8,
         };
      }

      namespace nSI_Load {
         enum {
            kMask = 0x200,
            kOffset = 0x9,
         };
      }

      namespace nSI_Arm {
         enum {
            kMask = 0x400,
            kOffset = 0xa,
         };
      }

      namespace nSI2_Load {
         enum {
            kMask = 0x800,
            kOffset = 0xb,
         };
      }

      namespace nSI2_Arm {
         enum {
            kMask = 0x1000,
            kOffset = 0xc,
         };
      }

      namespace nDisarm {
         enum {
            kMask = 0x2000,
            kOffset = 0xd,
         };
      }

      namespace nSTART1_Pulse {
         enum {
            kMask = 0x10000,
            kOffset = 0x10,
         };
      }

      namespace nSTART2_Pulse {
         enum {
            kMask = 0x20000,
            kOffset = 0x11,
         };
      }

      namespace nSTART_Pulse {
         enum {
            kMask = 0x40000,
            kOffset = 0x12,
         };
      }

      namespace nSC_Switch_Load_On_TC {
         enum {
            kMask = 0x100000,
            kOffset = 0x14,
         };
      }

      namespace nSI_Switch_Load_On_TC {
         enum {
            kMask = 0x800000,
            kOffset = 0x17,
         };
      }

      namespace nSI_Switch_Load_On_STOP {
         enum {
            kMask = 0x1000000,
            kOffset = 0x18,
         };
      }

      namespace nSI_Switch_Load_On_SC_TC {
         enum {
            kMask = 0x2000000,
            kOffset = 0x19,
         };
      }

      namespace nSC_PreWaitCountTC_ErrorAck {
         enum {
            kMask = 0x20000000,
            kOffset = 0x1d,
         };
      }

      namespace nEnd_On_End_Of_Scan {
         enum {
            kMask = 0x40000000,
            kOffset = 0x1e,
         };
      }

      namespace nEnd_On_SC_TC {
         enum {
            kMask = 0x80000000,
            kOffset = 0x1f,
         };
      }

   }

   namespace nStatus_1_Register {
      namespace nFIFO_Request_St {
         enum {
            kMask = 0x2,
            kOffset = 0x1,
         };
      }

      namespace nSTOP_St {
         enum {
            kMask = 0x10,
            kOffset = 0x4,
         };
      }

      namespace nSTART_St {
         enum {
            kMask = 0x20,
            kOffset = 0x5,
         };
      }

      namespace nSC_TC_St {
         enum {
            kMask = 0x40,
            kOffset = 0x6,
         };
      }

      namespace nSTART1_St {
         enum {
            kMask = 0x80,
            kOffset = 0x7,
         };
      }

      namespace nSTART2_St {
         enum {
            kMask = 0x100,
            kOffset = 0x8,
         };
      }

      namespace nSC_TC_Error_St {
         enum {
            kMask = 0x200,
            kOffset = 0x9,
         };
      }

      namespace nOverflow_St {
         enum {
            kMask = 0x400,
            kOffset = 0xa,
         };
      }

      namespace nOverrun_St {
         enum {
            kMask = 0x800,
            kOffset = 0xb,
         };
      }

      namespace nFIFO_Empty_St {
         enum {
            kMask = 0x1000,
            kOffset = 0xc,
         };
      }

      namespace nFIFO_Half_Full_St {
         enum {
            kMask = 0x2000,
            kOffset = 0xd,
         };
      }

      namespace nFIFO_Full_St {
         enum {
            kMask = 0x4000,
            kOffset = 0xe,
         };
      }

      namespace nScanOverrun_St {
         enum {
            kMask = 0x8000,
            kOffset = 0xf,
         };
      }

      namespace nSC_Armed_St {
         enum {
            kMask = 0x10000,
            kOffset = 0x10,
         };
      }

      namespace nSC_Next_Load_Source_St {
         enum {
            kMask = 0x20000,
            kOffset = 0x11,
         };
      }

      namespace nSI_Armed_St {
         enum {
            kMask = 0x80000,
            kOffset = 0x13,
         };
      }

      namespace nSI_Next_Load_Source_St {
         enum {
            kMask = 0x100000,
            kOffset = 0x14,
         };
      }

      namespace nSI_Counting_St {
         enum {
            kMask = 0x200000,
            kOffset = 0x15,
         };
      }

      namespace nSI2_Armed_St {
         enum {
            kMask = 0x400000,
            kOffset = 0x16,
         };
      }

      namespace nSI2_Next_Load_Source_St {
         enum {
            kMask = 0x800000,
            kOffset = 0x17,
         };
      }

      namespace nDIV_Armed_St {
         enum {
            kMask = 0x1000000,
            kOffset = 0x18,
         };
      }

      namespace nSC_Gate_St {
         enum {
            kMask = 0x2000000,
            kOffset = 0x19,
         };
      }

      namespace nStart_Stop_Gate_St {
         enum {
            kMask = 0x4000000,
            kOffset = 0x1a,
         };
      }

      namespace nSC_PreWaitCountTC_St {
         enum {
            kMask = 0x8000000,
            kOffset = 0x1b,
         };
      }

      namespace nScan_In_Progress_St {
         enum {
            kMask = 0x10000000,
            kOffset = 0x1c,
         };
      }

      namespace nExternal_Gate_St {
         enum {
            kMask = 0x20000000,
            kOffset = 0x1d,
         };
      }

      namespace nLast_Shiftin_St {
         enum {
            kMask = 0x40000000,
            kOffset = 0x1e,
         };
      }

      namespace nSC_PreWaitCountTC_ErrorSt {
         enum {
            kMask = 0x80000000,
            kOffset = 0x1f,
         };
      }

   }

   namespace nMode_1_Register {
      namespace nExportedConvertPolarity {
         enum {
            kMask = 0x1,
            kOffset = 0,
         };
      }

      namespace nSC_Reload_Mode {
         enum {
            kMask = 0x2,
            kOffset = 0x1,
         };
      }

      namespace nSC_Initial_Load_Source {
         enum {
            kMask = 0x4,
            kOffset = 0x2,
         };
      }

      namespace nSI_Reload_Mode {
         enum {
            kMask = 0x70,
            kOffset = 0x4,
         };
      }

      namespace nSI_Initial_Load_Source {
         enum {
            kMask = 0x80,
            kOffset = 0x7,
         };
      }

      namespace nSI2_Reload_Mode {
         enum {
            kMask = 0x100,
            kOffset = 0x8,
         };
      }

      namespace nSI2_Initial_Load_Source {
         enum {
            kMask = 0x200,
            kOffset = 0x9,
         };
      }

      namespace nExternal_MUX_Present {
         enum {
            kMask = 0x1000,
            kOffset = 0xc,
         };
      }

      namespace nPre_Trigger {
         enum {
            kMask = 0x2000,
            kOffset = 0xd,
         };
      }

      namespace nStart_Stop_Gate_Enable {
         enum {
            kMask = 0x4000,
            kOffset = 0xe,
         };
      }

      namespace nTrigger_Once {
         enum {
            kMask = 0x10000,
            kOffset = 0x10,
         };
      }

      namespace nContinuous {
         enum {
            kMask = 0x20000,
            kOffset = 0x11,
         };
      }

      namespace nSI_Source_Polarity {
         enum {
            kMask = 0x100000,
            kOffset = 0x14,
         };
      }

      namespace nSI_Source_Select {
         enum {
            kMask = 0x7c00000,
            kOffset = 0x16,
         };
      }

      namespace nSCAN_IN_PROG_Pulse {
         enum {
            kMask = 0x80000000,
            kOffset = 0x1f,
         };
      }

   }

   namespace nStatus_2_Register {
      namespace nSI_Load_Switch_Pending_St {
         enum {
            kMask = 0x1,
            kOffset = 0,
         };
      }

      namespace nSC_Q_St {
         enum {
            kMask = 0x1c,
            kOffset = 0x2,
         };
      }

      namespace nSI2_Q_St {
         enum {
            kMask = 0x300,
            kOffset = 0x8,
         };
      }

      namespace nSI_Q_St {
         enum {
            kMask = 0x3000,
            kOffset = 0xc,
         };
      }

      namespace nDIV_Q_St {
         enum {
            kMask = 0x8000,
            kOffset = 0xf,
         };
      }

   }

   namespace nMode_2_Register {
      namespace nEXTMUX_CLK_Pulse_Width {
         enum {
            kMask = 0x20,
            kOffset = 0x5,
         };
      }

      namespace nEXTMUX_CLK_Polarity {
         enum {
            kMask = 0x80,
            kOffset = 0x7,
         };
      }

      namespace nSCAN_IN_PROG_Polarity {
         enum {
            kMask = 0x200,
            kOffset = 0x9,
         };
      }

      namespace nSTART_Output_Select {
         enum {
            kMask = 0x400,
            kOffset = 0xa,
         };
      }

      namespace nStart2_Export_Mode {
         enum {
            kMask = 0x20000,
            kOffset = 0x11,
         };
      }

      namespace nStart1_Export_Mode {
         enum {
            kMask = 0x40000,
            kOffset = 0x12,
         };
      }

      namespace nStart_Trigger_Length {
         enum {
            kMask = 0x80000,
            kOffset = 0x13,
         };
      }

      namespace nSyncMode {
         enum {
            kMask = 0x300000,
            kOffset = 0x14,
         };
      }

      namespace nFIFO_Mode {
         enum {
            kMask = 0xc00000,
            kOffset = 0x16,
         };
      }

      namespace nExternal_Gate_Mode {
         enum {
            kMask = 0x1000000,
            kOffset = 0x18,
         };
      }

      namespace nSI2_Source_Select {
         enum {
            kMask = 0x8000000,
            kOffset = 0x1b,
         };
      }

      namespace nSoftware_Gate {
         enum {
            kMask = 0x20000000,
            kOffset = 0x1d,
         };
      }

      namespace nHaltOnError {
         enum {
            kMask = 0x40000000,
            kOffset = 0x1e,
         };
      }

   }

   namespace nSI_Save_Register {
      namespace nSI_Save_Value {
         enum {
            kMask = 0xffffffff,
            kOffset = 0,
         };
      }

   }

   namespace nSC_Save_Register {
      namespace nSC_Save_Value {
         enum {
            kMask = 0xffffffff,
            kOffset = 0,
         };
      }

   }

   namespace nSI_Load_A_Register {
      namespace nSI_Load_A {
         enum {
            kMask = 0xffffffff,
            kOffset = 0,
         };
      }

   }

   namespace nSI2_Save_Register {
      namespace nSI2_Save_Value {
         enum {
            kMask = 0xffffffff,
            kOffset = 0,
         };
      }

   }

   namespace nSI_Load_B_Register {
      namespace nSI_Load_B {
         enum {
            kMask = 0xffffffff,
            kOffset = 0,
         };
      }

   }

   namespace nDIV_Save_Register {
      namespace nDIV_Save_Value {
         enum {
            kMask = 0xffff,
            kOffset = 0,
         };
      }

   }

   namespace nSC_Load_A_Register {
      namespace nSC_Load_A {
         enum {
            kMask = 0xffffffff,
            kOffset = 0,
         };
      }

   }

   namespace nSC_Load_B_Register {
      namespace nSC_Load_B {
         enum {
            kMask = 0xffffffff,
            kOffset = 0,
         };
      }

   }

   namespace nSC_PreWaitCntRegister {
      namespace nSC_PreWaitCount {
         enum {
            kMask = 0xffffffff,
            kOffset = 0,
         };
      }

   }

   namespace nSI2_Load_A_Register {
      namespace nSI2_Load_A {
         enum {
            kMask = 0xffffffff,
            kOffset = 0,
         };
      }

   }

   namespace nSI2_Load_B_Register {
      namespace nSI2_Load_B {
         enum {
            kMask = 0xffffffff,
            kOffset = 0,
         };
      }

   }

   namespace nDIV_Load_A_Register {
      namespace nDIV_Load_A {
         enum {
            kMask = 0xffff,
            kOffset = 0,
         };
      }

   }

   namespace nInterrupt1_Register {
      namespace nSC_TC_Interrupt_Enable {
         enum {
            kMask = 0x1,
            kOffset = 0,
         };
      }

      namespace nSTART1_Interrupt_Enable {
         enum {
            kMask = 0x2,
            kOffset = 0x1,
         };
      }

      namespace nSTART2_Interrupt_Enable {
         enum {
            kMask = 0x4,
            kOffset = 0x2,
         };
      }

      namespace nSTART_Interrupt_Enable {
         enum {
            kMask = 0x8,
            kOffset = 0x3,
         };
      }

      namespace nSTOP_Interrupt_Enable {
         enum {
            kMask = 0x10,
            kOffset = 0x4,
         };
      }

      namespace nOverrun_Interrupt_Enable {
         enum {
            kMask = 0x20,
            kOffset = 0x5,
         };
      }

      namespace nOverflow_Interrupt_Enable {
         enum {
            kMask = 0x40,
            kOffset = 0x6,
         };
      }

      namespace nFIFO_Interrupt_Enable {
         enum {
            kMask = 0x80,
            kOffset = 0x7,
         };
      }

      namespace nScanOverrun_Interrupt_Enable {
         enum {
            kMask = 0x100,
            kOffset = 0x8,
         };
      }

      namespace nSC_PreWaitCountTC_Interrupt_Enable {
         enum {
            kMask = 0x200,
            kOffset = 0x9,
         };
      }

      namespace nScanOverrun_Interrupt_Ack {
         enum {
            kMask = 0x400000,
            kOffset = 0x16,
         };
      }

      namespace nSC_TC_Error_Confirm {
         enum {
            kMask = 0x800000,
            kOffset = 0x17,
         };
      }

      namespace nSC_TC_Interrupt_Ack {
         enum {
            kMask = 0x1000000,
            kOffset = 0x18,
         };
      }

      namespace nSTART1_Interrupt_Ack {
         enum {
            kMask = 0x2000000,
            kOffset = 0x19,
         };
      }

      namespace nSTART2_Interrupt_Ack {
         enum {
            kMask = 0x4000000,
            kOffset = 0x1a,
         };
      }

      namespace nSTART_Interrupt_Ack {
         enum {
            kMask = 0x8000000,
            kOffset = 0x1b,
         };
      }

      namespace nSTOP_Interrupt_Ack {
         enum {
            kMask = 0x10000000,
            kOffset = 0x1c,
         };
      }

      namespace nOverrun_Interrupt_Ack {
         enum {
            kMask = 0x20000000,
            kOffset = 0x1d,
         };
      }

      namespace nSC_PreWaitCountTC_Interrupt_Ack {
         enum {
            kMask = 0x40000000,
            kOffset = 0x1e,
         };
      }

      namespace nOverflow_Interrupt_Ack {
         enum {
            kMask = 0x80000000,
            kOffset = 0x1f,
         };
      }

   }

   namespace nInterrupt2_Register {
      namespace nSC_TC_Interrupt_Disable {
         enum {
            kMask = 0x1,
            kOffset = 0,
         };
      }

      namespace nSTART1_Interrupt_Disable {
         enum {
            kMask = 0x2,
            kOffset = 0x1,
         };
      }

      namespace nSTART2_Interrupt_Disable {
         enum {
            kMask = 0x4,
            kOffset = 0x2,
         };
      }

      namespace nSTART_Interrupt_Disable {
         enum {
            kMask = 0x8,
            kOffset = 0x3,
         };
      }

      namespace nSTOP_Interrupt_Disable {
         enum {
            kMask = 0x10,
            kOffset = 0x4,
         };
      }

      namespace nOverrun_Interrupt_Disable {
         enum {
            kMask = 0x20,
            kOffset = 0x5,
         };
      }

      namespace nOverflow_Interrupt_Disable {
         enum {
            kMask = 0x40,
            kOffset = 0x6,
         };
      }

      namespace nFIFO_Interrupt_Disable {
         enum {
            kMask = 0x80,
            kOffset = 0x7,
         };
      }

      namespace nScanOverrun_Interrupt_Disable {
         enum {
            kMask = 0x100,
            kOffset = 0x8,
         };
      }

      namespace nSC_PreWaitCountTC_Interrupt_Disable {
         enum {
            kMask = 0x200,
            kOffset = 0x9,
         };
      }

      namespace nScanOverrun_Interrupt_Ack2 {
         enum {
            kMask = 0x400000,
            kOffset = 0x16,
         };
      }

      namespace nSC_TC_Error_Confirm2 {
         enum {
            kMask = 0x800000,
            kOffset = 0x17,
         };
      }

      namespace nSC_TC_Interrupt_Ack2 {
         enum {
            kMask = 0x1000000,
            kOffset = 0x18,
         };
      }

      namespace nSTART1_Interrupt_Ack2 {
         enum {
            kMask = 0x2000000,
            kOffset = 0x19,
         };
      }

      namespace nSTART2_Interrupt_Ack2 {
         enum {
            kMask = 0x4000000,
            kOffset = 0x1a,
         };
      }

      namespace nSTART_Interrupt_Ack2 {
         enum {
            kMask = 0x8000000,
            kOffset = 0x1b,
         };
      }

      namespace nSTOP_Interrupt_Ack2 {
         enum {
            kMask = 0x10000000,
            kOffset = 0x1c,
         };
      }

      namespace nOverrun_Interrupt_Ack2 {
         enum {
            kMask = 0x20000000,
            kOffset = 0x1d,
         };
      }

      namespace nSC_PreWaitCountTC_Interrupt_Ack2 {
         enum {
            kMask = 0x40000000,
            kOffset = 0x1e,
         };
      }

      namespace nOverflow_Interrupt_Ack2 {
         enum {
            kMask = 0x80000000,
            kOffset = 0x1f,
         };
      }

   }

   namespace nReset_Register {
      namespace nReset {
         enum {
            kMask = 0x1,
            kOffset = 0,
         };
      }

      namespace nConfiguration_Start {
         enum {
            kMask = 0x2,
            kOffset = 0x1,
         };
      }

      namespace nConfiguration_End {
         enum {
            kMask = 0x4,
            kOffset = 0x2,
         };
      }

      namespace nConfiguration_Memory_Clear {
         enum {
            kMask = 0x8,
            kOffset = 0x3,
         };
      }

      namespace nFIFO_Clear {
         enum {
            kMask = 0x10,
            kOffset = 0x4,
         };
      }

   }

   using namespace nCommand_Register;
   using namespace nStatus_1_Register;
   using namespace nMode_1_Register;
   using namespace nStatus_2_Register;
   using namespace nMode_2_Register;
   using namespace nSI_Save_Register;
   using namespace nSC_Save_Register;
   using namespace nSI_Load_A_Register;
   using namespace nSI2_Save_Register;
   using namespace nSI_Load_B_Register;
   using namespace nDIV_Save_Register;
   using namespace nSC_Load_A_Register;
   using namespace nSC_Load_B_Register;
   using namespace nSC_PreWaitCntRegister;
   using namespace nSI2_Load_A_Register;
   using namespace nSI2_Load_B_Register;
   using namespace nDIV_Load_A_Register;
   using namespace nInterrupt1_Register;
   using namespace nInterrupt2_Register;
   using namespace nReset_Register;
}

#endif


// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// This file is autogenerated!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!

