// Copyright 2011 National Instruments
// License: NATIONAL INSTRUMENTS SOFTWARE LICENSE AGREEMENT
//   Refer to "MHDDK License Agreement.pdf" in the root of this distribution.

// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// This file is autogenerated!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!

#ifndef ___tOutTimer_h___
#define ___tOutTimer_h___

// includes
#include "osiTypes.h"
#include "osiBus.h"
#include "tOutTimerValues.h"


#ifndef ___tOutTimerValues_h___
#include "tOutTimerValues.h"
#endif

#ifndef nNIMXRegisterMap120_mBuildFieldId

// Algorithm:
//    Move lowermost 5 bits (4 through 0) of field id to uppermost 5 bits (31
//          through 27)
//    Move bit 5 of field id to bit 26
//    Move bit 6 of field id to bit 25
//    OR in the register id (which is allowed the remaining bits)
//
// Why not move the lowermost 7 bits directly to the uppermost 7 bits? Because
// we originally moved only the lowermost 5, and for backwards compatibility,
// we can't change where those 5 bits end up.
//
// For future expansion purposes, the bits beyond the first 5 are put in reverse
// order in the resulting combined id.
#define nNIMXRegisterMap120_mBuildFieldId(fieldId, regId) \
   ( \
     ((fieldId) << 27) | \
     ((((fieldId) >> 5) & 0x1) << 26) | \
     ((((fieldId) >> 6) & 0x1) << 25) | \
     (regId) \
   )

#endif

#ifndef nNIMXRegisterMap120_mExtractFieldId

// Algorithm: (basically the reverse of mBuildFieldId)
//    Move uppermost 5 bits (31 through 27) to lowermost 5 bits (4 through 0)
//    Move 26th bit to bit 5 (right-shifting by (26 - 5) is like right-shifting
//          by 26 then left-shifting by 5, but it's more efficient)
//    Move 25th bit to bit 6
#define nNIMXRegisterMap120_mExtractFieldId(id) \
   (unsigned int) \
   ( \
     (((id) >> 27) & 0x1F) | \
     (((id) & (0x1 << 26)) >> (26 - 5)) | \
     (((id) & (0x1 << 25)) >> (25 - 6)) \
   )

#endif

class tOutTimer
{
public:
   //---------------------------------------------------------------------------
   // IO Strategies
   //---------------------------------------------------------------------------
   class tReg16IODirect32
   {
   public:
      inline void write(
         tBusSpaceReference addrSpace,
         u32 offset,
         u16 value,
         nMDBG::tStatus2* statusChain = NULL);

      inline u16 read(
         tBusSpaceReference addrSpace,
         u32 offset,
         nMDBG::tStatus2* statusChain = NULL);
   };

   class tReg32IODirect32
   {
   public:
      inline void write(
         tBusSpaceReference addrSpace,
         u32 offset,
         u32 value,
         nMDBG::tStatus2* statusChain = NULL);

      inline u32 read(
         tBusSpaceReference addrSpace,
         u32 offset,
         nMDBG::tStatus2* statusChain = NULL);
   };

   //---------------------------------------------------------------------------
   // Command_1_Register
   //---------------------------------------------------------------------------
   class tCommand_1_Register : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tOutTimer tRegisterMap;

      enum {
         kOffset = 0x0,
         kId     = 0
      };
      tCommand_1_Register();


      typedef enum {
         kRegisterId                          = 0,
         kSTART1_PulseId                   = 1,
         kBC_Switch_Load_On_TCId           = 3,
         kUC_Switch_Load_On_TCId           = 4,
         kUC_Switch_Load_On_BC_TCId        = 5,
         kUI_Switch_Load_On_TCId           = 6,
         kUI_Switch_Load_On_UC_TCId        = 7,
         kUI_Switch_Load_On_BC_TCId        = 8,
         kUI_Cancel_Load_SwitchId          = 10,
         kEnd_On_UC_TCId                   = 12,
         kEnd_On_BC_TCId                   = 13,
         kUpdate_PulseId                   = 14,
         kBC_LoadId                        = 16,
         kBC_ArmId                         = 17,
         kUC_LoadId                        = 18,
         kUC_ArmId                         = 19,
         kUI_LoadId                        = 20,
         kUI_ArmId                         = 21,
         kDisarmId                         = 23,
         kMaxFieldId                          = 23
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Register Accessors (Compile-time selectable)

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);


      // Field Accessors (Compile-time selectable)
      inline void writeSTART1_Pulse(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeBC_Switch_Load_On_TC(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeUC_Switch_Load_On_TC(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeUC_Switch_Load_On_BC_TC(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeUI_Switch_Load_On_TC(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeUI_Switch_Load_On_UC_TC(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeUI_Switch_Load_On_BC_TC(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeUI_Cancel_Load_Switch(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeEnd_On_UC_TC(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeEnd_On_BC_TC(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeUpdate_Pulse(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeBC_Load(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeBC_Arm(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeUC_Load(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeUC_Arm(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeUI_Load(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeUI_Arm(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeDisarm(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      tRegisterMap* _regMap;

      // Usage guidelines
      tCommand_1_Register(const tCommand_1_Register&);
      tCommand_1_Register& operator=(const tCommand_1_Register&);

   };

   //---------------------------------------------------------------------------
   // Status_1_Register
   //---------------------------------------------------------------------------
   class tStatus_1_Register : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tOutTimer tRegisterMap;

      enum {
         kOffset = 0x0,
         kId     = 1
      };
      tStatus_1_Register();


      typedef enum {
         kRegisterId                          = 0,
         kBC_Armed_StId                    = 1,
         kBC_Next_Load_Source_StId         = 2,
         kWrite_Too_Fast_StId              = 3,
         kBC_Q_StId                        = 4,
         kBC_TC_Trigger_Error_StId         = 5,
         kUI_Armed_StId                    = 6,
         kUI_Next_Load_Source_StId         = 7,
         kUI_Load_Switch_Pending_StId      = 8,
         kUI_Count_Enabled_StId            = 9,
         kUI_Q_StId                        = 10,
         kTMRDACWRs_In_Progress_StId       = 11,
         kBC_Gate_StId                     = 12,
         kExternal_Gate_StId               = 13,
         kUC_Q_StId                        = 14,
         kUC_Armed_StId                    = 15,
         kUC_Next_Load_Source_StId         = 16,
         kFIFO_Request_StId                = 18,
         kUPDATE_StId                      = 20,
         kUC_TC_StId                       = 21,
         kBC_TC_StId                       = 22,
         kSTART1_StId                      = 23,
         kOverrun_StId                     = 24,
         kUnderflow_StId                   = 25,
         kBC_TC_Error_StId                 = 26,
         kFIFO_Empty_StId                  = 27,
         kFIFO_Half_Full_StId              = 28,
         kFIFO_Full_StId                   = 29,
         kMaxFieldId                          = 29
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Register Accessors (Compile-time selectable)
      inline tStatus_1_Register& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void refresh(nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tStatus_1_Register& setBC_Armed_St(nOutTimer::tOutTimer_Armed_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nOutTimer::tOutTimer_Armed_t getBC_Armed_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline nOutTimer::tOutTimer_Armed_t readBC_Armed_St(nMDBG::tStatus2* statusChain = NULL);

      inline tStatus_1_Register& setBC_Next_Load_Source_St(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getBC_Next_Load_Source_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u32 readBC_Next_Load_Source_St(nMDBG::tStatus2* statusChain = NULL);

      inline tStatus_1_Register& setWrite_Too_Fast_St(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getWrite_Too_Fast_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u32 readWrite_Too_Fast_St(nMDBG::tStatus2* statusChain = NULL);

      inline tStatus_1_Register& setBC_Q_St(nOutTimer::tOutTimer_BC_Q_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nOutTimer::tOutTimer_BC_Q_t getBC_Q_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline nOutTimer::tOutTimer_BC_Q_t readBC_Q_St(nMDBG::tStatus2* statusChain = NULL);

      inline tStatus_1_Register& setBC_TC_Trigger_Error_St(nOutTimer::tOutTimer_Error_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nOutTimer::tOutTimer_Error_t getBC_TC_Trigger_Error_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline nOutTimer::tOutTimer_Error_t readBC_TC_Trigger_Error_St(nMDBG::tStatus2* statusChain = NULL);

      inline tStatus_1_Register& setUI_Armed_St(nOutTimer::tOutTimer_Armed_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nOutTimer::tOutTimer_Armed_t getUI_Armed_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline nOutTimer::tOutTimer_Armed_t readUI_Armed_St(nMDBG::tStatus2* statusChain = NULL);

      inline tStatus_1_Register& setUI_Next_Load_Source_St(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getUI_Next_Load_Source_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u32 readUI_Next_Load_Source_St(nMDBG::tStatus2* statusChain = NULL);

      inline tStatus_1_Register& setUI_Load_Switch_Pending_St(nOutTimer::tOutTimer_UI_Load_Switch_Pending_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nOutTimer::tOutTimer_UI_Load_Switch_Pending_t getUI_Load_Switch_Pending_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline nOutTimer::tOutTimer_UI_Load_Switch_Pending_t readUI_Load_Switch_Pending_St(nMDBG::tStatus2* statusChain = NULL);

      inline tStatus_1_Register& setUI_Count_Enabled_St(nOutTimer::tOutTimer_UI_Count_Enabled_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nOutTimer::tOutTimer_UI_Count_Enabled_t getUI_Count_Enabled_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline nOutTimer::tOutTimer_UI_Count_Enabled_t readUI_Count_Enabled_St(nMDBG::tStatus2* statusChain = NULL);

      inline tStatus_1_Register& setUI_Q_St(nOutTimer::tOutTimer_UI_Q_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nOutTimer::tOutTimer_UI_Q_t getUI_Q_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline nOutTimer::tOutTimer_UI_Q_t readUI_Q_St(nMDBG::tStatus2* statusChain = NULL);

      inline tStatus_1_Register& setTMRDACWRs_In_Progress_St(nOutTimer::tOutTimer_TMRDACWRs_In_Progress_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nOutTimer::tOutTimer_TMRDACWRs_In_Progress_t getTMRDACWRs_In_Progress_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline nOutTimer::tOutTimer_TMRDACWRs_In_Progress_t readTMRDACWRs_In_Progress_St(nMDBG::tStatus2* statusChain = NULL);

      inline tStatus_1_Register& setBC_Gate_St(nOutTimer::tOutTimer_BC_Gate_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nOutTimer::tOutTimer_BC_Gate_t getBC_Gate_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline nOutTimer::tOutTimer_BC_Gate_t readBC_Gate_St(nMDBG::tStatus2* statusChain = NULL);

      inline tStatus_1_Register& setExternal_Gate_St(nOutTimer::tOutTimer_External_Gate_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nOutTimer::tOutTimer_External_Gate_t getExternal_Gate_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline nOutTimer::tOutTimer_External_Gate_t readExternal_Gate_St(nMDBG::tStatus2* statusChain = NULL);

      inline tStatus_1_Register& setUC_Q_St(nOutTimer::tOutTimer_UC_Q_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nOutTimer::tOutTimer_UC_Q_t getUC_Q_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline nOutTimer::tOutTimer_UC_Q_t readUC_Q_St(nMDBG::tStatus2* statusChain = NULL);

      inline tStatus_1_Register& setUC_Armed_St(nOutTimer::tOutTimer_Armed_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nOutTimer::tOutTimer_Armed_t getUC_Armed_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline nOutTimer::tOutTimer_Armed_t readUC_Armed_St(nMDBG::tStatus2* statusChain = NULL);

      inline tStatus_1_Register& setUC_Next_Load_Source_St(nOutTimer::tOutTimer_Load_Source_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nOutTimer::tOutTimer_Load_Source_t getUC_Next_Load_Source_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline nOutTimer::tOutTimer_Load_Source_t readUC_Next_Load_Source_St(nMDBG::tStatus2* statusChain = NULL);

      inline tStatus_1_Register& setFIFO_Request_St(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getFIFO_Request_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u32 readFIFO_Request_St(nMDBG::tStatus2* statusChain = NULL);

      inline tStatus_1_Register& setUPDATE_St(nOutTimer::tOutTimer_Trigger_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nOutTimer::tOutTimer_Trigger_t getUPDATE_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline nOutTimer::tOutTimer_Trigger_t readUPDATE_St(nMDBG::tStatus2* statusChain = NULL);

      inline tStatus_1_Register& setUC_TC_St(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getUC_TC_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u32 readUC_TC_St(nMDBG::tStatus2* statusChain = NULL);

      inline tStatus_1_Register& setBC_TC_St(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getBC_TC_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline u32 readBC_TC_St(nMDBG::tStatus2* statusChain = NULL);

      inline tStatus_1_Register& setSTART1_St(nOutTimer::tOutTimer_Trigger_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nOutTimer::tOutTimer_Trigger_t getSTART1_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline nOutTimer::tOutTimer_Trigger_t readSTART1_St(nMDBG::tStatus2* statusChain = NULL);

      inline tStatus_1_Register& setOverrun_St(nOutTimer::tOutTimer_Error_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nOutTimer::tOutTimer_Error_t getOverrun_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline nOutTimer::tOutTimer_Error_t readOverrun_St(nMDBG::tStatus2* statusChain = NULL);

      inline tStatus_1_Register& setUnderflow_St(nOutTimer::tOutTimer_Error_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nOutTimer::tOutTimer_Error_t getUnderflow_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline nOutTimer::tOutTimer_Error_t readUnderflow_St(nMDBG::tStatus2* statusChain = NULL);

      inline tStatus_1_Register& setBC_TC_Error_St(nOutTimer::tOutTimer_Error_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nOutTimer::tOutTimer_Error_t getBC_TC_Error_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline nOutTimer::tOutTimer_Error_t readBC_TC_Error_St(nMDBG::tStatus2* statusChain = NULL);

      inline tStatus_1_Register& setFIFO_Empty_St(nOutTimer::tOutTimer_FIFO_Empty_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nOutTimer::tOutTimer_FIFO_Empty_t getFIFO_Empty_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline nOutTimer::tOutTimer_FIFO_Empty_t readFIFO_Empty_St(nMDBG::tStatus2* statusChain = NULL);

      inline tStatus_1_Register& setFIFO_Half_Full_St(nOutTimer::tOutTimer_FIFO_Half_Full_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nOutTimer::tOutTimer_FIFO_Half_Full_t getFIFO_Half_Full_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline nOutTimer::tOutTimer_FIFO_Half_Full_t readFIFO_Half_Full_St(nMDBG::tStatus2* statusChain = NULL);

      inline tStatus_1_Register& setFIFO_Full_St(nOutTimer::tOutTimer_FIFO_Full_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nOutTimer::tOutTimer_FIFO_Full_t getFIFO_Full_St(nMDBG::tStatus2* statusChain = NULL) const;

      inline nOutTimer::tOutTimer_FIFO_Full_t readFIFO_Full_St(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tStatus_1_Register(const tStatus_1_Register&);
      tStatus_1_Register& operator=(const tStatus_1_Register&);

   };

   //---------------------------------------------------------------------------
   // UI_Load_A_Register
   //---------------------------------------------------------------------------
   class tUI_Load_A_Register : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tOutTimer tRegisterMap;

      enum {
         kOffset = 0x4,
         kId     = 2
      };
      tUI_Load_A_Register();


      typedef enum {
         kRegisterId                          = 0,
         kUI_Load_AId                      = 1,
         kMaxFieldId                          = 1
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Dirty Tracking
      inline tBoolean isDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markClean(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tUI_Load_A_Register& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tUI_Load_A_Register& setUI_Load_A(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getUI_Load_A(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeUI_Load_A(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u32 readUI_Load_A(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tUI_Load_A_Register(const tUI_Load_A_Register&);
      tUI_Load_A_Register& operator=(const tUI_Load_A_Register&);

   };

   //---------------------------------------------------------------------------
   // UI_Save_Register
   //---------------------------------------------------------------------------
   class tUI_Save_Register : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tOutTimer tRegisterMap;

      enum {
         kOffset = 0x4,
         kId     = 3
      };
      tUI_Save_Register();


      typedef enum {
         kRegisterId                          = 0,
         kUI_SaveId                        = 1,
         kMaxFieldId                          = 1
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Register Accessors (Compile-time selectable)
      inline tUI_Save_Register& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void refresh(nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tUI_Save_Register& setUI_Save(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getUI_Save(nMDBG::tStatus2* statusChain = NULL) const;

      inline u32 readUI_Save(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tUI_Save_Register(const tUI_Save_Register&);
      tUI_Save_Register& operator=(const tUI_Save_Register&);

   };

   //---------------------------------------------------------------------------
   // UI_Load_B_Register
   //---------------------------------------------------------------------------
   class tUI_Load_B_Register : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tOutTimer tRegisterMap;

      enum {
         kOffset = 0x8,
         kId     = 4
      };
      tUI_Load_B_Register();


      typedef enum {
         kRegisterId                          = 0,
         kUI_Load_BId                      = 1,
         kMaxFieldId                          = 1
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Dirty Tracking
      inline tBoolean isDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markClean(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tUI_Load_B_Register& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tUI_Load_B_Register& setUI_Load_B(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getUI_Load_B(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeUI_Load_B(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u32 readUI_Load_B(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tUI_Load_B_Register(const tUI_Load_B_Register&);
      tUI_Load_B_Register& operator=(const tUI_Load_B_Register&);

   };

   //---------------------------------------------------------------------------
   // UC_Load_A_Register
   //---------------------------------------------------------------------------
   class tUC_Load_A_Register : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tOutTimer tRegisterMap;

      enum {
         kOffset = 0xc,
         kId     = 5
      };
      tUC_Load_A_Register();


      typedef enum {
         kRegisterId                          = 0,
         kUC_Load_AId                      = 1,
         kMaxFieldId                          = 1
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Dirty Tracking
      inline tBoolean isDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markClean(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tUC_Load_A_Register& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tUC_Load_A_Register& setUC_Load_A(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getUC_Load_A(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeUC_Load_A(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u32 readUC_Load_A(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tUC_Load_A_Register(const tUC_Load_A_Register&);
      tUC_Load_A_Register& operator=(const tUC_Load_A_Register&);

   };

   //---------------------------------------------------------------------------
   // UC_Save_Register
   //---------------------------------------------------------------------------
   class tUC_Save_Register : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tOutTimer tRegisterMap;

      enum {
         kOffset = 0xc,
         kId     = 6
      };
      tUC_Save_Register();


      typedef enum {
         kRegisterId                          = 0,
         kUC_SaveId                        = 1,
         kMaxFieldId                          = 1
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Register Accessors (Compile-time selectable)
      inline tUC_Save_Register& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void refresh(nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tUC_Save_Register& setUC_Save(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getUC_Save(nMDBG::tStatus2* statusChain = NULL) const;

      inline u32 readUC_Save(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tUC_Save_Register(const tUC_Save_Register&);
      tUC_Save_Register& operator=(const tUC_Save_Register&);

   };

   //---------------------------------------------------------------------------
   // UC_Load_B_Register
   //---------------------------------------------------------------------------
   class tUC_Load_B_Register : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tOutTimer tRegisterMap;

      enum {
         kOffset = 0x10,
         kId     = 7
      };
      tUC_Load_B_Register();


      typedef enum {
         kRegisterId                          = 0,
         kUC_Load_BId                      = 1,
         kMaxFieldId                          = 1
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Dirty Tracking
      inline tBoolean isDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markClean(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tUC_Load_B_Register& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tUC_Load_B_Register& setUC_Load_B(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getUC_Load_B(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeUC_Load_B(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u32 readUC_Load_B(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tUC_Load_B_Register(const tUC_Load_B_Register&);
      tUC_Load_B_Register& operator=(const tUC_Load_B_Register&);

   };

   //---------------------------------------------------------------------------
   // BC_Load_A_Register
   //---------------------------------------------------------------------------
   class tBC_Load_A_Register : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tOutTimer tRegisterMap;

      enum {
         kOffset = 0x14,
         kId     = 8
      };
      tBC_Load_A_Register();


      typedef enum {
         kRegisterId                          = 0,
         kBC_Load_AId                      = 1,
         kMaxFieldId                          = 1
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Dirty Tracking
      inline tBoolean isDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markClean(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tBC_Load_A_Register& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tBC_Load_A_Register& setBC_Load_A(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getBC_Load_A(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeBC_Load_A(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u32 readBC_Load_A(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tBC_Load_A_Register(const tBC_Load_A_Register&);
      tBC_Load_A_Register& operator=(const tBC_Load_A_Register&);

   };

   //---------------------------------------------------------------------------
   // BC_Save_Register
   //---------------------------------------------------------------------------
   class tBC_Save_Register : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tOutTimer tRegisterMap;

      enum {
         kOffset = 0x14,
         kId     = 9
      };
      tBC_Save_Register();


      typedef enum {
         kRegisterId                          = 0,
         kBC_SaveId                        = 1,
         kMaxFieldId                          = 1
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Register Accessors (Compile-time selectable)
      inline tBC_Save_Register& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void refresh(nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tBC_Save_Register& setBC_Save(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getBC_Save(nMDBG::tStatus2* statusChain = NULL) const;

      inline u32 readBC_Save(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tBC_Save_Register(const tBC_Save_Register&);
      tBC_Save_Register& operator=(const tBC_Save_Register&);

   };

   //---------------------------------------------------------------------------
   // BC_Load_B_Register
   //---------------------------------------------------------------------------
   class tBC_Load_B_Register : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tOutTimer tRegisterMap;

      enum {
         kOffset = 0x18,
         kId     = 10
      };
      tBC_Load_B_Register();


      typedef enum {
         kRegisterId                          = 0,
         kBC_Load_BId                      = 1,
         kMaxFieldId                          = 1
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Dirty Tracking
      inline tBoolean isDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markClean(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tBC_Load_B_Register& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tBC_Load_B_Register& setBC_Load_B(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getBC_Load_B(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeBC_Load_B(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u32 readBC_Load_B(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tBC_Load_B_Register(const tBC_Load_B_Register&);
      tBC_Load_B_Register& operator=(const tBC_Load_B_Register&);

   };

   //---------------------------------------------------------------------------
   // Mode_1_Register
   //---------------------------------------------------------------------------
   class tMode_1_Register : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tOutTimer tRegisterMap;

      enum {
         kOffset = 0x1c,
         kId     = 11
      };
      tMode_1_Register();


      typedef enum {
         kRegisterId                          = 0,
         kBC_Write_SwitchId                = 1,
         kBC_Reload_ModeId                 = 2,
         kBC_Initial_Load_SourceId         = 3,
         kUI_Write_SwitchId                = 4,
         kUI_Reload_ModeId                 = 5,
         kUI_Initial_Load_SourceId         = 6,
         kUC_Write_SwitchId                = 8,
         kUC_Initial_Load_SourceId         = 9,
         kFIFO_Retransmit_EnableId         = 11,
         kFIFO_ModeId                      = 12,
         kTrigger_OnceId                   = 13,
         kContinuousId                     = 14,
         kUI_Source_PolarityId             = 16,
         kUI_Source_SelectId               = 18,
         kUC_Reload_ModeId                 = 19,
         kMaxFieldId                          = 19
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Dirty Tracking
      inline tBoolean isDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markClean(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tMode_1_Register& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tMode_1_Register& setBC_Write_Switch(nOutTimer::tOutTimer_Write_Switch_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nOutTimer::tOutTimer_Write_Switch_t getBC_Write_Switch(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeBC_Write_Switch(nOutTimer::tOutTimer_Write_Switch_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nOutTimer::tOutTimer_Write_Switch_t readBC_Write_Switch(nMDBG::tStatus2* statusChain = NULL);

      inline tMode_1_Register& setBC_Reload_Mode(nOutTimer::tOutTimer_BC_Reload_Mode_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nOutTimer::tOutTimer_BC_Reload_Mode_t getBC_Reload_Mode(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeBC_Reload_Mode(nOutTimer::tOutTimer_BC_Reload_Mode_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nOutTimer::tOutTimer_BC_Reload_Mode_t readBC_Reload_Mode(nMDBG::tStatus2* statusChain = NULL);

      inline tMode_1_Register& setBC_Initial_Load_Source(nOutTimer::tOutTimer_Load_Source_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nOutTimer::tOutTimer_Load_Source_t getBC_Initial_Load_Source(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeBC_Initial_Load_Source(nOutTimer::tOutTimer_Load_Source_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nOutTimer::tOutTimer_Load_Source_t readBC_Initial_Load_Source(nMDBG::tStatus2* statusChain = NULL);

      inline tMode_1_Register& setUI_Write_Switch(nOutTimer::tOutTimer_Write_Switch_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nOutTimer::tOutTimer_Write_Switch_t getUI_Write_Switch(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeUI_Write_Switch(nOutTimer::tOutTimer_Write_Switch_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nOutTimer::tOutTimer_Write_Switch_t readUI_Write_Switch(nMDBG::tStatus2* statusChain = NULL);

      inline tMode_1_Register& setUI_Reload_Mode(nOutTimer::tOutTimer_UI_Reload_Mode_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nOutTimer::tOutTimer_UI_Reload_Mode_t getUI_Reload_Mode(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeUI_Reload_Mode(nOutTimer::tOutTimer_UI_Reload_Mode_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nOutTimer::tOutTimer_UI_Reload_Mode_t readUI_Reload_Mode(nMDBG::tStatus2* statusChain = NULL);

      inline tMode_1_Register& setUI_Initial_Load_Source(nOutTimer::tOutTimer_Load_Source_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nOutTimer::tOutTimer_Load_Source_t getUI_Initial_Load_Source(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeUI_Initial_Load_Source(nOutTimer::tOutTimer_Load_Source_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nOutTimer::tOutTimer_Load_Source_t readUI_Initial_Load_Source(nMDBG::tStatus2* statusChain = NULL);

      inline tMode_1_Register& setUC_Write_Switch(nOutTimer::tOutTimer_Write_Switch_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nOutTimer::tOutTimer_Write_Switch_t getUC_Write_Switch(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeUC_Write_Switch(nOutTimer::tOutTimer_Write_Switch_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nOutTimer::tOutTimer_Write_Switch_t readUC_Write_Switch(nMDBG::tStatus2* statusChain = NULL);

      inline tMode_1_Register& setUC_Initial_Load_Source(nOutTimer::tOutTimer_Load_Source_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nOutTimer::tOutTimer_Load_Source_t getUC_Initial_Load_Source(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeUC_Initial_Load_Source(nOutTimer::tOutTimer_Load_Source_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nOutTimer::tOutTimer_Load_Source_t readUC_Initial_Load_Source(nMDBG::tStatus2* statusChain = NULL);

      inline tMode_1_Register& setFIFO_Retransmit_Enable(nOutTimer::tOutTimer_Disabled_Enabled_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nOutTimer::tOutTimer_Disabled_Enabled_t getFIFO_Retransmit_Enable(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeFIFO_Retransmit_Enable(nOutTimer::tOutTimer_Disabled_Enabled_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nOutTimer::tOutTimer_Disabled_Enabled_t readFIFO_Retransmit_Enable(nMDBG::tStatus2* statusChain = NULL);

      inline tMode_1_Register& setFIFO_Mode(nOutTimer::tOutTimer_FIFO_Mode_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nOutTimer::tOutTimer_FIFO_Mode_t getFIFO_Mode(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeFIFO_Mode(nOutTimer::tOutTimer_FIFO_Mode_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nOutTimer::tOutTimer_FIFO_Mode_t readFIFO_Mode(nMDBG::tStatus2* statusChain = NULL);

      inline tMode_1_Register& setTrigger_Once(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getTrigger_Once(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeTrigger_Once(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u32 readTrigger_Once(nMDBG::tStatus2* statusChain = NULL);

      inline tMode_1_Register& setContinuous(nOutTimer::tOutTimer_Continuous_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nOutTimer::tOutTimer_Continuous_t getContinuous(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeContinuous(nOutTimer::tOutTimer_Continuous_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nOutTimer::tOutTimer_Continuous_t readContinuous(nMDBG::tStatus2* statusChain = NULL);

      inline tMode_1_Register& setUI_Source_Polarity(nOutTimer::tOutTimer_Polarity_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nOutTimer::tOutTimer_Polarity_t getUI_Source_Polarity(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeUI_Source_Polarity(nOutTimer::tOutTimer_Polarity_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nOutTimer::tOutTimer_Polarity_t readUI_Source_Polarity(nMDBG::tStatus2* statusChain = NULL);

      inline tMode_1_Register& setUI_Source_Select(nOutTimer::tOutTimer_UI_Source_Select_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nOutTimer::tOutTimer_UI_Source_Select_t getUI_Source_Select(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeUI_Source_Select(nOutTimer::tOutTimer_UI_Source_Select_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nOutTimer::tOutTimer_UI_Source_Select_t readUI_Source_Select(nMDBG::tStatus2* statusChain = NULL);

      inline tMode_1_Register& setUC_Reload_Mode(nOutTimer::tOutTimer_UC_Reload_Mode_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nOutTimer::tOutTimer_UC_Reload_Mode_t getUC_Reload_Mode(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeUC_Reload_Mode(nOutTimer::tOutTimer_UC_Reload_Mode_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nOutTimer::tOutTimer_UC_Reload_Mode_t readUC_Reload_Mode(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tMode_1_Register(const tMode_1_Register&);
      tMode_1_Register& operator=(const tMode_1_Register&);

   };

   //---------------------------------------------------------------------------
   // Mode_2_Register
   //---------------------------------------------------------------------------
   class tMode_2_Register : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tOutTimer tRegisterMap;

      enum {
         kOffset = 0x20,
         kId     = 12
      };
      tMode_2_Register();


      typedef enum {
         kRegisterId                          = 0,
         kMute_AId                         = 2,
         kMute_BId                         = 3,
         kSyncModeId                       = 5,
         kSoftware_GateId                  = 7,
         kNot_An_UPDATEId                  = 8,
         kStop_On_BC_TC_ErrorId            = 9,
         kStop_On_BC_TC_Trigger_ErrorId    = 10,
         kStop_On_Overrun_ErrorId          = 11,
         kAOFREQ_EnableId                  = 12,
         kHold_BC_On_UC_ReadId             = 14,
         kStart1_Export_ModeId             = 15,
         kFIFO_EnableId                    = 17,
         kBC_Gate_EnableId                 = 18,
         kMaxFieldId                          = 18
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Dirty Tracking
      inline tBoolean isDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markClean(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tMode_2_Register& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tMode_2_Register& setMute_A(nOutTimer::tOutTimer_Mute_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nOutTimer::tOutTimer_Mute_t getMute_A(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeMute_A(nOutTimer::tOutTimer_Mute_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nOutTimer::tOutTimer_Mute_t readMute_A(nMDBG::tStatus2* statusChain = NULL);

      inline tMode_2_Register& setMute_B(nOutTimer::tOutTimer_Mute_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nOutTimer::tOutTimer_Mute_t getMute_B(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeMute_B(nOutTimer::tOutTimer_Mute_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nOutTimer::tOutTimer_Mute_t readMute_B(nMDBG::tStatus2* statusChain = NULL);

      inline tMode_2_Register& setSyncMode(nOutTimer::tOutTimerSyncMode_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nOutTimer::tOutTimerSyncMode_t getSyncMode(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeSyncMode(nOutTimer::tOutTimerSyncMode_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nOutTimer::tOutTimerSyncMode_t readSyncMode(nMDBG::tStatus2* statusChain = NULL);

      inline tMode_2_Register& setSoftware_Gate(nOutTimer::tOutTimer_Software_Gate_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nOutTimer::tOutTimer_Software_Gate_t getSoftware_Gate(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeSoftware_Gate(nOutTimer::tOutTimer_Software_Gate_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nOutTimer::tOutTimer_Software_Gate_t readSoftware_Gate(nMDBG::tStatus2* statusChain = NULL);

      inline tMode_2_Register& setNot_An_UPDATE(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getNot_An_UPDATE(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeNot_An_UPDATE(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u32 readNot_An_UPDATE(nMDBG::tStatus2* statusChain = NULL);

      inline tMode_2_Register& setStop_On_BC_TC_Error(nOutTimer::tOutTimer_Stop_On_Error_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nOutTimer::tOutTimer_Stop_On_Error_t getStop_On_BC_TC_Error(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeStop_On_BC_TC_Error(nOutTimer::tOutTimer_Stop_On_Error_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nOutTimer::tOutTimer_Stop_On_Error_t readStop_On_BC_TC_Error(nMDBG::tStatus2* statusChain = NULL);

      inline tMode_2_Register& setStop_On_BC_TC_Trigger_Error(nOutTimer::tOutTimer_Stop_On_Error_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nOutTimer::tOutTimer_Stop_On_Error_t getStop_On_BC_TC_Trigger_Error(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeStop_On_BC_TC_Trigger_Error(nOutTimer::tOutTimer_Stop_On_Error_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nOutTimer::tOutTimer_Stop_On_Error_t readStop_On_BC_TC_Trigger_Error(nMDBG::tStatus2* statusChain = NULL);

      inline tMode_2_Register& setStop_On_Overrun_Error(nOutTimer::tOutTimer_Stop_On_Error_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nOutTimer::tOutTimer_Stop_On_Error_t getStop_On_Overrun_Error(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeStop_On_Overrun_Error(nOutTimer::tOutTimer_Stop_On_Error_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nOutTimer::tOutTimer_Stop_On_Error_t readStop_On_Overrun_Error(nMDBG::tStatus2* statusChain = NULL);

      inline tMode_2_Register& setAOFREQ_Enable(nOutTimer::tOutTimer_Disabled_Enabled_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nOutTimer::tOutTimer_Disabled_Enabled_t getAOFREQ_Enable(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAOFREQ_Enable(nOutTimer::tOutTimer_Disabled_Enabled_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nOutTimer::tOutTimer_Disabled_Enabled_t readAOFREQ_Enable(nMDBG::tStatus2* statusChain = NULL);

      inline tMode_2_Register& setHold_BC_On_UC_Read(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getHold_BC_On_UC_Read(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeHold_BC_On_UC_Read(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u32 readHold_BC_On_UC_Read(nMDBG::tStatus2* statusChain = NULL);

      inline tMode_2_Register& setStart1_Export_Mode(nOutTimer::tOutTimer_Start1_Export_Mode_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nOutTimer::tOutTimer_Start1_Export_Mode_t getStart1_Export_Mode(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeStart1_Export_Mode(nOutTimer::tOutTimer_Start1_Export_Mode_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nOutTimer::tOutTimer_Start1_Export_Mode_t readStart1_Export_Mode(nMDBG::tStatus2* statusChain = NULL);

      inline tMode_2_Register& setFIFO_Enable(nOutTimer::tOutTimer_Disabled_Enabled_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nOutTimer::tOutTimer_Disabled_Enabled_t getFIFO_Enable(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeFIFO_Enable(nOutTimer::tOutTimer_Disabled_Enabled_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nOutTimer::tOutTimer_Disabled_Enabled_t readFIFO_Enable(nMDBG::tStatus2* statusChain = NULL);

      inline tMode_2_Register& setBC_Gate_Enable(nOutTimer::tOutTimer_Disabled_Enabled_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nOutTimer::tOutTimer_Disabled_Enabled_t getBC_Gate_Enable(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeBC_Gate_Enable(nOutTimer::tOutTimer_Disabled_Enabled_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nOutTimer::tOutTimer_Disabled_Enabled_t readBC_Gate_Enable(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tMode_2_Register(const tMode_2_Register&);
      tMode_2_Register& operator=(const tMode_2_Register&);

   };

   //---------------------------------------------------------------------------
   // Output_Control_Register
   //---------------------------------------------------------------------------
   class tOutput_Control_Register : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tOutTimer tRegisterMap;

      enum {
         kOffset = 0x26,
         kId     = 13
      };
      tOutput_Control_Register();


      typedef enum {
         kRegisterId                          = 0,
         kExportedUpdatePolarityId         = 1,
         kNumber_Of_ChannelsId             = 3,
         kMaxFieldId                          = 3
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Dirty Tracking
      inline tBoolean isDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markClean(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tOutput_Control_Register& setRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline void writeRegister(u16 value, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u16 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tOutput_Control_Register& setExportedUpdatePolarity(nOutTimer::tOutTimer_Polarity_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nOutTimer::tOutTimer_Polarity_t getExportedUpdatePolarity(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeExportedUpdatePolarity(nOutTimer::tOutTimer_Polarity_t fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline nOutTimer::tOutTimer_Polarity_t readExportedUpdatePolarity(nMDBG::tStatus2* statusChain = NULL);

      inline tOutput_Control_Register& setNumber_Of_Channels(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u16 getNumber_Of_Channels(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeNumber_Of_Channels(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u16 readNumber_Of_Channels(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u16 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tOutput_Control_Register(const tOutput_Control_Register&);
      tOutput_Control_Register& operator=(const tOutput_Control_Register&);

   };

   //---------------------------------------------------------------------------
   // Interrupt1_Register
   //---------------------------------------------------------------------------
   class tInterrupt1_Register : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tOutTimer tRegisterMap;

      enum {
         kOffset = 0x28,
         kId     = 14
      };
      tInterrupt1_Register();


      typedef enum {
         kRegisterId                          = 0,
         kBC_TC_Interrupt_EnableId         = 1,
         kSTART1_Interrupt_EnableId        = 2,
         kUPDATE_Interrupt_EnableId        = 3,
         kError_Interrupt_EnableId         = 5,
         kUC_TC_Interrupt_EnableId         = 6,
         kFIFO_Interrupt_EnableId          = 8,
         kWrite_Too_Fast_Interrupt_EnableId    = 9,
         kWrite_Too_Fast_Interrupt_AckId   = 11,
         kBC_TC_Trigger_Error_ConfirmId    = 13,
         kBC_TC_Error_ConfirmId            = 14,
         kUC_TC_Interrupt_AckId            = 16,
         kBC_TC_Interrupt_AckId            = 17,
         kSTART1_Interrupt_AckId           = 18,
         kUPDATE_Interrupt_AckId           = 19,
         kError_Interrupt_AckId            = 21,
         kMaxFieldId                          = 21
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Register Accessors (Compile-time selectable)

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);


      // Field Accessors (Compile-time selectable)
      inline void writeBC_TC_Interrupt_Enable(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeSTART1_Interrupt_Enable(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeUPDATE_Interrupt_Enable(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeError_Interrupt_Enable(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeUC_TC_Interrupt_Enable(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeFIFO_Interrupt_Enable(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeWrite_Too_Fast_Interrupt_Enable(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeWrite_Too_Fast_Interrupt_Ack(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeBC_TC_Trigger_Error_Confirm(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeBC_TC_Error_Confirm(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeUC_TC_Interrupt_Ack(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeBC_TC_Interrupt_Ack(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeSTART1_Interrupt_Ack(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeUPDATE_Interrupt_Ack(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeError_Interrupt_Ack(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      tRegisterMap* _regMap;

      // Usage guidelines
      tInterrupt1_Register(const tInterrupt1_Register&);
      tInterrupt1_Register& operator=(const tInterrupt1_Register&);

   };

   //---------------------------------------------------------------------------
   // Interrupt2_Register
   //---------------------------------------------------------------------------
   class tInterrupt2_Register : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tOutTimer tRegisterMap;

      enum {
         kOffset = 0x2c,
         kId     = 15
      };
      tInterrupt2_Register();


      typedef enum {
         kRegisterId                          = 0,
         kBC_TC_Interrupt_DisableId        = 1,
         kSTART1_Interrupt_DisableId       = 2,
         kUPDATE_Interrupt_DisableId       = 3,
         kError_Interrupt_DisableId        = 5,
         kUC_TC_Interrupt_DisableId        = 6,
         kFIFO_Interrupt_DisableId         = 8,
         kWrite_Too_Fast_Interrupt_DisableId     = 9,
         kWrite_Too_Fast_Interrupt_Ack2Id  = 11,
         kBC_TC_Trigger_Error_Confirm2Id   = 13,
         kBC_TC_Error_Confirm2Id           = 14,
         kUC_TC_Interrupt_Ack2Id           = 16,
         kBC_TC_Interrupt_Ack2Id           = 17,
         kSTART1_Interrupt_Ack2Id          = 18,
         kUPDATE_Interrupt_Ack2Id          = 19,
         kError_Interrupt_Ack2Id           = 21,
         kMaxFieldId                          = 21
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Register Accessors (Compile-time selectable)

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);


      // Field Accessors (Compile-time selectable)
      inline void writeBC_TC_Interrupt_Disable(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeSTART1_Interrupt_Disable(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeUPDATE_Interrupt_Disable(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeError_Interrupt_Disable(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeUC_TC_Interrupt_Disable(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeFIFO_Interrupt_Disable(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeWrite_Too_Fast_Interrupt_Disable(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeWrite_Too_Fast_Interrupt_Ack2(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeBC_TC_Trigger_Error_Confirm2(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeBC_TC_Error_Confirm2(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeUC_TC_Interrupt_Ack2(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeBC_TC_Interrupt_Ack2(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeSTART1_Interrupt_Ack2(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeUPDATE_Interrupt_Ack2(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeError_Interrupt_Ack2(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      tRegisterMap* _regMap;

      // Usage guidelines
      tInterrupt2_Register(const tInterrupt2_Register&);
      tInterrupt2_Register& operator=(const tInterrupt2_Register&);

   };

   //---------------------------------------------------------------------------
   // Reset_Register
   //---------------------------------------------------------------------------
   class tReset_Register : public tReg16IODirect32
   {
   public:
      typedef tReg16IODirect32 tIOStrategy;
      typedef tOutTimer tRegisterMap;

      enum {
         kOffset = 0x34,
         kId     = 16
      };
      tReset_Register();


      typedef enum {
         kRegisterId                          = 0,
         kResetId                          = 1,
         kConfiguration_StartId            = 2,
         kConfiguration_EndId              = 3,
         kFIFO_ClearId                     = 4,
         kMaxFieldId                          = 4
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Register Accessors (Compile-time selectable)

      inline void writeRegister(u16 value, nMDBG::tStatus2* statusChain = NULL);


      // Field Accessors (Compile-time selectable)
      inline void writeReset(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeConfiguration_Start(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeConfiguration_End(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeFIFO_Clear(u16 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      tRegisterMap* _regMap;

      // Usage guidelines
      tReset_Register(const tReset_Register&);
      tReset_Register& operator=(const tReset_Register&);

   };

   //---------------------------------------------------------------------------
   // Command_1_Register
   //---------------------------------------------------------------------------
   tCommand_1_Register Command_1_Register;

   //---------------------------------------------------------------------------
   // Status_1_Register
   //---------------------------------------------------------------------------
   tStatus_1_Register Status_1_Register;

   //---------------------------------------------------------------------------
   // UI_Load_A_Register
   //---------------------------------------------------------------------------
   tUI_Load_A_Register UI_Load_A_Register;

   //---------------------------------------------------------------------------
   // UI_Save_Register
   //---------------------------------------------------------------------------
   tUI_Save_Register UI_Save_Register;

   //---------------------------------------------------------------------------
   // UI_Load_B_Register
   //---------------------------------------------------------------------------
   tUI_Load_B_Register UI_Load_B_Register;

   //---------------------------------------------------------------------------
   // UC_Load_A_Register
   //---------------------------------------------------------------------------
   tUC_Load_A_Register UC_Load_A_Register;

   //---------------------------------------------------------------------------
   // UC_Save_Register
   //---------------------------------------------------------------------------
   tUC_Save_Register UC_Save_Register;

   //---------------------------------------------------------------------------
   // UC_Load_B_Register
   //---------------------------------------------------------------------------
   tUC_Load_B_Register UC_Load_B_Register;

   //---------------------------------------------------------------------------
   // BC_Load_A_Register
   //---------------------------------------------------------------------------
   tBC_Load_A_Register BC_Load_A_Register;

   //---------------------------------------------------------------------------
   // BC_Save_Register
   //---------------------------------------------------------------------------
   tBC_Save_Register BC_Save_Register;

   //---------------------------------------------------------------------------
   // BC_Load_B_Register
   //---------------------------------------------------------------------------
   tBC_Load_B_Register BC_Load_B_Register;

   //---------------------------------------------------------------------------
   // Mode_1_Register
   //---------------------------------------------------------------------------
   tMode_1_Register Mode_1_Register;

   //---------------------------------------------------------------------------
   // Mode_2_Register
   //---------------------------------------------------------------------------
   tMode_2_Register Mode_2_Register;

   //---------------------------------------------------------------------------
   // Output_Control_Register
   //---------------------------------------------------------------------------
   tOutput_Control_Register Output_Control_Register;

   //---------------------------------------------------------------------------
   // Interrupt1_Register
   //---------------------------------------------------------------------------
   tInterrupt1_Register Interrupt1_Register;

   //---------------------------------------------------------------------------
   // Interrupt2_Register
   //---------------------------------------------------------------------------
   tInterrupt2_Register Interrupt2_Register;

   //---------------------------------------------------------------------------
   // Reset_Register
   //---------------------------------------------------------------------------
   tReset_Register Reset_Register;

   //---------------------------------------------------------------------------
   // Register Groups
   //---------------------------------------------------------------------------

   //----------------------------------------
   // Register/Field Ids
   //----------------------------------------
   typedef enum {
      kCommand_1_RegisterId             = 0,
      kSTART1_PulseId                   = nNIMXRegisterMap120_mBuildFieldId(tCommand_1_Register::kSTART1_PulseId, kCommand_1_RegisterId),
      kBC_Switch_Load_On_TCId           = nNIMXRegisterMap120_mBuildFieldId(tCommand_1_Register::kBC_Switch_Load_On_TCId, kCommand_1_RegisterId),
      kUC_Switch_Load_On_TCId           = nNIMXRegisterMap120_mBuildFieldId(tCommand_1_Register::kUC_Switch_Load_On_TCId, kCommand_1_RegisterId),
      kUC_Switch_Load_On_BC_TCId        = nNIMXRegisterMap120_mBuildFieldId(tCommand_1_Register::kUC_Switch_Load_On_BC_TCId, kCommand_1_RegisterId),
      kUI_Switch_Load_On_TCId           = nNIMXRegisterMap120_mBuildFieldId(tCommand_1_Register::kUI_Switch_Load_On_TCId, kCommand_1_RegisterId),
      kUI_Switch_Load_On_UC_TCId        = nNIMXRegisterMap120_mBuildFieldId(tCommand_1_Register::kUI_Switch_Load_On_UC_TCId, kCommand_1_RegisterId),
      kUI_Switch_Load_On_BC_TCId        = nNIMXRegisterMap120_mBuildFieldId(tCommand_1_Register::kUI_Switch_Load_On_BC_TCId, kCommand_1_RegisterId),
      kUI_Cancel_Load_SwitchId          = nNIMXRegisterMap120_mBuildFieldId(tCommand_1_Register::kUI_Cancel_Load_SwitchId, kCommand_1_RegisterId),
      kEnd_On_UC_TCId                   = nNIMXRegisterMap120_mBuildFieldId(tCommand_1_Register::kEnd_On_UC_TCId, kCommand_1_RegisterId),
      kEnd_On_BC_TCId                   = nNIMXRegisterMap120_mBuildFieldId(tCommand_1_Register::kEnd_On_BC_TCId, kCommand_1_RegisterId),
      kUpdate_PulseId                   = nNIMXRegisterMap120_mBuildFieldId(tCommand_1_Register::kUpdate_PulseId, kCommand_1_RegisterId),
      kBC_LoadId                        = nNIMXRegisterMap120_mBuildFieldId(tCommand_1_Register::kBC_LoadId, kCommand_1_RegisterId),
      kBC_ArmId                         = nNIMXRegisterMap120_mBuildFieldId(tCommand_1_Register::kBC_ArmId, kCommand_1_RegisterId),
      kUC_LoadId                        = nNIMXRegisterMap120_mBuildFieldId(tCommand_1_Register::kUC_LoadId, kCommand_1_RegisterId),
      kUC_ArmId                         = nNIMXRegisterMap120_mBuildFieldId(tCommand_1_Register::kUC_ArmId, kCommand_1_RegisterId),
      kUI_LoadId                        = nNIMXRegisterMap120_mBuildFieldId(tCommand_1_Register::kUI_LoadId, kCommand_1_RegisterId),
      kUI_ArmId                         = nNIMXRegisterMap120_mBuildFieldId(tCommand_1_Register::kUI_ArmId, kCommand_1_RegisterId),
      kDisarmId                         = nNIMXRegisterMap120_mBuildFieldId(tCommand_1_Register::kDisarmId, kCommand_1_RegisterId),

      kStatus_1_RegisterId              = 1,
      kBC_Armed_StId                    = nNIMXRegisterMap120_mBuildFieldId(tStatus_1_Register::kBC_Armed_StId, kStatus_1_RegisterId),
      kBC_Next_Load_Source_StId         = nNIMXRegisterMap120_mBuildFieldId(tStatus_1_Register::kBC_Next_Load_Source_StId, kStatus_1_RegisterId),
      kWrite_Too_Fast_StId              = nNIMXRegisterMap120_mBuildFieldId(tStatus_1_Register::kWrite_Too_Fast_StId, kStatus_1_RegisterId),
      kBC_Q_StId                        = nNIMXRegisterMap120_mBuildFieldId(tStatus_1_Register::kBC_Q_StId, kStatus_1_RegisterId),
      kBC_TC_Trigger_Error_StId         = nNIMXRegisterMap120_mBuildFieldId(tStatus_1_Register::kBC_TC_Trigger_Error_StId, kStatus_1_RegisterId),
      kUI_Armed_StId                    = nNIMXRegisterMap120_mBuildFieldId(tStatus_1_Register::kUI_Armed_StId, kStatus_1_RegisterId),
      kUI_Next_Load_Source_StId         = nNIMXRegisterMap120_mBuildFieldId(tStatus_1_Register::kUI_Next_Load_Source_StId, kStatus_1_RegisterId),
      kUI_Load_Switch_Pending_StId      = nNIMXRegisterMap120_mBuildFieldId(tStatus_1_Register::kUI_Load_Switch_Pending_StId, kStatus_1_RegisterId),
      kUI_Count_Enabled_StId            = nNIMXRegisterMap120_mBuildFieldId(tStatus_1_Register::kUI_Count_Enabled_StId, kStatus_1_RegisterId),
      kUI_Q_StId                        = nNIMXRegisterMap120_mBuildFieldId(tStatus_1_Register::kUI_Q_StId, kStatus_1_RegisterId),
      kTMRDACWRs_In_Progress_StId       = nNIMXRegisterMap120_mBuildFieldId(tStatus_1_Register::kTMRDACWRs_In_Progress_StId, kStatus_1_RegisterId),
      kBC_Gate_StId                     = nNIMXRegisterMap120_mBuildFieldId(tStatus_1_Register::kBC_Gate_StId, kStatus_1_RegisterId),
      kExternal_Gate_StId               = nNIMXRegisterMap120_mBuildFieldId(tStatus_1_Register::kExternal_Gate_StId, kStatus_1_RegisterId),
      kUC_Q_StId                        = nNIMXRegisterMap120_mBuildFieldId(tStatus_1_Register::kUC_Q_StId, kStatus_1_RegisterId),
      kUC_Armed_StId                    = nNIMXRegisterMap120_mBuildFieldId(tStatus_1_Register::kUC_Armed_StId, kStatus_1_RegisterId),
      kUC_Next_Load_Source_StId         = nNIMXRegisterMap120_mBuildFieldId(tStatus_1_Register::kUC_Next_Load_Source_StId, kStatus_1_RegisterId),
      kFIFO_Request_StId                = nNIMXRegisterMap120_mBuildFieldId(tStatus_1_Register::kFIFO_Request_StId, kStatus_1_RegisterId),
      kUPDATE_StId                      = nNIMXRegisterMap120_mBuildFieldId(tStatus_1_Register::kUPDATE_StId, kStatus_1_RegisterId),
      kUC_TC_StId                       = nNIMXRegisterMap120_mBuildFieldId(tStatus_1_Register::kUC_TC_StId, kStatus_1_RegisterId),
      kBC_TC_StId                       = nNIMXRegisterMap120_mBuildFieldId(tStatus_1_Register::kBC_TC_StId, kStatus_1_RegisterId),
      kSTART1_StId                      = nNIMXRegisterMap120_mBuildFieldId(tStatus_1_Register::kSTART1_StId, kStatus_1_RegisterId),
      kOverrun_StId                     = nNIMXRegisterMap120_mBuildFieldId(tStatus_1_Register::kOverrun_StId, kStatus_1_RegisterId),
      kUnderflow_StId                   = nNIMXRegisterMap120_mBuildFieldId(tStatus_1_Register::kUnderflow_StId, kStatus_1_RegisterId),
      kBC_TC_Error_StId                 = nNIMXRegisterMap120_mBuildFieldId(tStatus_1_Register::kBC_TC_Error_StId, kStatus_1_RegisterId),
      kFIFO_Empty_StId                  = nNIMXRegisterMap120_mBuildFieldId(tStatus_1_Register::kFIFO_Empty_StId, kStatus_1_RegisterId),
      kFIFO_Half_Full_StId              = nNIMXRegisterMap120_mBuildFieldId(tStatus_1_Register::kFIFO_Half_Full_StId, kStatus_1_RegisterId),
      kFIFO_Full_StId                   = nNIMXRegisterMap120_mBuildFieldId(tStatus_1_Register::kFIFO_Full_StId, kStatus_1_RegisterId),

      kUI_Load_A_RegisterId             = 2,
      kUI_Load_AId                      = nNIMXRegisterMap120_mBuildFieldId(tUI_Load_A_Register::kUI_Load_AId, kUI_Load_A_RegisterId),

      kUI_Save_RegisterId               = 3,
      kUI_SaveId                        = nNIMXRegisterMap120_mBuildFieldId(tUI_Save_Register::kUI_SaveId, kUI_Save_RegisterId),

      kUI_Load_B_RegisterId             = 4,
      kUI_Load_BId                      = nNIMXRegisterMap120_mBuildFieldId(tUI_Load_B_Register::kUI_Load_BId, kUI_Load_B_RegisterId),

      kUC_Load_A_RegisterId             = 5,
      kUC_Load_AId                      = nNIMXRegisterMap120_mBuildFieldId(tUC_Load_A_Register::kUC_Load_AId, kUC_Load_A_RegisterId),

      kUC_Save_RegisterId               = 6,
      kUC_SaveId                        = nNIMXRegisterMap120_mBuildFieldId(tUC_Save_Register::kUC_SaveId, kUC_Save_RegisterId),

      kUC_Load_B_RegisterId             = 7,
      kUC_Load_BId                      = nNIMXRegisterMap120_mBuildFieldId(tUC_Load_B_Register::kUC_Load_BId, kUC_Load_B_RegisterId),

      kBC_Load_A_RegisterId             = 8,
      kBC_Load_AId                      = nNIMXRegisterMap120_mBuildFieldId(tBC_Load_A_Register::kBC_Load_AId, kBC_Load_A_RegisterId),

      kBC_Save_RegisterId               = 9,
      kBC_SaveId                        = nNIMXRegisterMap120_mBuildFieldId(tBC_Save_Register::kBC_SaveId, kBC_Save_RegisterId),

      kBC_Load_B_RegisterId             = 10,
      kBC_Load_BId                      = nNIMXRegisterMap120_mBuildFieldId(tBC_Load_B_Register::kBC_Load_BId, kBC_Load_B_RegisterId),

      kMode_1_RegisterId                = 11,
      kBC_Write_SwitchId                = nNIMXRegisterMap120_mBuildFieldId(tMode_1_Register::kBC_Write_SwitchId, kMode_1_RegisterId),
      kBC_Reload_ModeId                 = nNIMXRegisterMap120_mBuildFieldId(tMode_1_Register::kBC_Reload_ModeId, kMode_1_RegisterId),
      kBC_Initial_Load_SourceId         = nNIMXRegisterMap120_mBuildFieldId(tMode_1_Register::kBC_Initial_Load_SourceId, kMode_1_RegisterId),
      kUI_Write_SwitchId                = nNIMXRegisterMap120_mBuildFieldId(tMode_1_Register::kUI_Write_SwitchId, kMode_1_RegisterId),
      kUI_Reload_ModeId                 = nNIMXRegisterMap120_mBuildFieldId(tMode_1_Register::kUI_Reload_ModeId, kMode_1_RegisterId),
      kUI_Initial_Load_SourceId         = nNIMXRegisterMap120_mBuildFieldId(tMode_1_Register::kUI_Initial_Load_SourceId, kMode_1_RegisterId),
      kUC_Write_SwitchId                = nNIMXRegisterMap120_mBuildFieldId(tMode_1_Register::kUC_Write_SwitchId, kMode_1_RegisterId),
      kUC_Initial_Load_SourceId         = nNIMXRegisterMap120_mBuildFieldId(tMode_1_Register::kUC_Initial_Load_SourceId, kMode_1_RegisterId),
      kFIFO_Retransmit_EnableId         = nNIMXRegisterMap120_mBuildFieldId(tMode_1_Register::kFIFO_Retransmit_EnableId, kMode_1_RegisterId),
      kFIFO_ModeId                      = nNIMXRegisterMap120_mBuildFieldId(tMode_1_Register::kFIFO_ModeId, kMode_1_RegisterId),
      kTrigger_OnceId                   = nNIMXRegisterMap120_mBuildFieldId(tMode_1_Register::kTrigger_OnceId, kMode_1_RegisterId),
      kContinuousId                     = nNIMXRegisterMap120_mBuildFieldId(tMode_1_Register::kContinuousId, kMode_1_RegisterId),
      kUI_Source_PolarityId             = nNIMXRegisterMap120_mBuildFieldId(tMode_1_Register::kUI_Source_PolarityId, kMode_1_RegisterId),
      kUI_Source_SelectId               = nNIMXRegisterMap120_mBuildFieldId(tMode_1_Register::kUI_Source_SelectId, kMode_1_RegisterId),
      kUC_Reload_ModeId                 = nNIMXRegisterMap120_mBuildFieldId(tMode_1_Register::kUC_Reload_ModeId, kMode_1_RegisterId),

      kMode_2_RegisterId                = 12,
      kMute_AId                         = nNIMXRegisterMap120_mBuildFieldId(tMode_2_Register::kMute_AId, kMode_2_RegisterId),
      kMute_BId                         = nNIMXRegisterMap120_mBuildFieldId(tMode_2_Register::kMute_BId, kMode_2_RegisterId),
      kSyncModeId                       = nNIMXRegisterMap120_mBuildFieldId(tMode_2_Register::kSyncModeId, kMode_2_RegisterId),
      kSoftware_GateId                  = nNIMXRegisterMap120_mBuildFieldId(tMode_2_Register::kSoftware_GateId, kMode_2_RegisterId),
      kNot_An_UPDATEId                  = nNIMXRegisterMap120_mBuildFieldId(tMode_2_Register::kNot_An_UPDATEId, kMode_2_RegisterId),
      kStop_On_BC_TC_ErrorId            = nNIMXRegisterMap120_mBuildFieldId(tMode_2_Register::kStop_On_BC_TC_ErrorId, kMode_2_RegisterId),
      kStop_On_BC_TC_Trigger_ErrorId    = nNIMXRegisterMap120_mBuildFieldId(tMode_2_Register::kStop_On_BC_TC_Trigger_ErrorId, kMode_2_RegisterId),
      kStop_On_Overrun_ErrorId          = nNIMXRegisterMap120_mBuildFieldId(tMode_2_Register::kStop_On_Overrun_ErrorId, kMode_2_RegisterId),
      kAOFREQ_EnableId                  = nNIMXRegisterMap120_mBuildFieldId(tMode_2_Register::kAOFREQ_EnableId, kMode_2_RegisterId),
      kHold_BC_On_UC_ReadId             = nNIMXRegisterMap120_mBuildFieldId(tMode_2_Register::kHold_BC_On_UC_ReadId, kMode_2_RegisterId),
      kStart1_Export_ModeId             = nNIMXRegisterMap120_mBuildFieldId(tMode_2_Register::kStart1_Export_ModeId, kMode_2_RegisterId),
      kFIFO_EnableId                    = nNIMXRegisterMap120_mBuildFieldId(tMode_2_Register::kFIFO_EnableId, kMode_2_RegisterId),
      kBC_Gate_EnableId                 = nNIMXRegisterMap120_mBuildFieldId(tMode_2_Register::kBC_Gate_EnableId, kMode_2_RegisterId),

      kOutput_Control_RegisterId        = 13,
      kExportedUpdatePolarityId         = nNIMXRegisterMap120_mBuildFieldId(tOutput_Control_Register::kExportedUpdatePolarityId, kOutput_Control_RegisterId),
      kNumber_Of_ChannelsId             = nNIMXRegisterMap120_mBuildFieldId(tOutput_Control_Register::kNumber_Of_ChannelsId, kOutput_Control_RegisterId),

      kInterrupt1_RegisterId            = 14,
      kBC_TC_Interrupt_EnableId         = nNIMXRegisterMap120_mBuildFieldId(tInterrupt1_Register::kBC_TC_Interrupt_EnableId, kInterrupt1_RegisterId),
      kSTART1_Interrupt_EnableId        = nNIMXRegisterMap120_mBuildFieldId(tInterrupt1_Register::kSTART1_Interrupt_EnableId, kInterrupt1_RegisterId),
      kUPDATE_Interrupt_EnableId        = nNIMXRegisterMap120_mBuildFieldId(tInterrupt1_Register::kUPDATE_Interrupt_EnableId, kInterrupt1_RegisterId),
      kError_Interrupt_EnableId         = nNIMXRegisterMap120_mBuildFieldId(tInterrupt1_Register::kError_Interrupt_EnableId, kInterrupt1_RegisterId),
      kUC_TC_Interrupt_EnableId         = nNIMXRegisterMap120_mBuildFieldId(tInterrupt1_Register::kUC_TC_Interrupt_EnableId, kInterrupt1_RegisterId),
      kFIFO_Interrupt_EnableId          = nNIMXRegisterMap120_mBuildFieldId(tInterrupt1_Register::kFIFO_Interrupt_EnableId, kInterrupt1_RegisterId),
      kWrite_Too_Fast_Interrupt_EnableId    = nNIMXRegisterMap120_mBuildFieldId(tInterrupt1_Register::kWrite_Too_Fast_Interrupt_EnableId, kInterrupt1_RegisterId),
      kWrite_Too_Fast_Interrupt_AckId   = nNIMXRegisterMap120_mBuildFieldId(tInterrupt1_Register::kWrite_Too_Fast_Interrupt_AckId, kInterrupt1_RegisterId),
      kBC_TC_Trigger_Error_ConfirmId    = nNIMXRegisterMap120_mBuildFieldId(tInterrupt1_Register::kBC_TC_Trigger_Error_ConfirmId, kInterrupt1_RegisterId),
      kBC_TC_Error_ConfirmId            = nNIMXRegisterMap120_mBuildFieldId(tInterrupt1_Register::kBC_TC_Error_ConfirmId, kInterrupt1_RegisterId),
      kUC_TC_Interrupt_AckId            = nNIMXRegisterMap120_mBuildFieldId(tInterrupt1_Register::kUC_TC_Interrupt_AckId, kInterrupt1_RegisterId),
      kBC_TC_Interrupt_AckId            = nNIMXRegisterMap120_mBuildFieldId(tInterrupt1_Register::kBC_TC_Interrupt_AckId, kInterrupt1_RegisterId),
      kSTART1_Interrupt_AckId           = nNIMXRegisterMap120_mBuildFieldId(tInterrupt1_Register::kSTART1_Interrupt_AckId, kInterrupt1_RegisterId),
      kUPDATE_Interrupt_AckId           = nNIMXRegisterMap120_mBuildFieldId(tInterrupt1_Register::kUPDATE_Interrupt_AckId, kInterrupt1_RegisterId),
      kError_Interrupt_AckId            = nNIMXRegisterMap120_mBuildFieldId(tInterrupt1_Register::kError_Interrupt_AckId, kInterrupt1_RegisterId),

      kInterrupt2_RegisterId            = 15,
      kBC_TC_Interrupt_DisableId        = nNIMXRegisterMap120_mBuildFieldId(tInterrupt2_Register::kBC_TC_Interrupt_DisableId, kInterrupt2_RegisterId),
      kSTART1_Interrupt_DisableId       = nNIMXRegisterMap120_mBuildFieldId(tInterrupt2_Register::kSTART1_Interrupt_DisableId, kInterrupt2_RegisterId),
      kUPDATE_Interrupt_DisableId       = nNIMXRegisterMap120_mBuildFieldId(tInterrupt2_Register::kUPDATE_Interrupt_DisableId, kInterrupt2_RegisterId),
      kError_Interrupt_DisableId        = nNIMXRegisterMap120_mBuildFieldId(tInterrupt2_Register::kError_Interrupt_DisableId, kInterrupt2_RegisterId),
      kUC_TC_Interrupt_DisableId        = nNIMXRegisterMap120_mBuildFieldId(tInterrupt2_Register::kUC_TC_Interrupt_DisableId, kInterrupt2_RegisterId),
      kFIFO_Interrupt_DisableId         = nNIMXRegisterMap120_mBuildFieldId(tInterrupt2_Register::kFIFO_Interrupt_DisableId, kInterrupt2_RegisterId),
      kWrite_Too_Fast_Interrupt_DisableId     = nNIMXRegisterMap120_mBuildFieldId(tInterrupt2_Register::kWrite_Too_Fast_Interrupt_DisableId, kInterrupt2_RegisterId),
      kWrite_Too_Fast_Interrupt_Ack2Id  = nNIMXRegisterMap120_mBuildFieldId(tInterrupt2_Register::kWrite_Too_Fast_Interrupt_Ack2Id, kInterrupt2_RegisterId),
      kBC_TC_Trigger_Error_Confirm2Id   = nNIMXRegisterMap120_mBuildFieldId(tInterrupt2_Register::kBC_TC_Trigger_Error_Confirm2Id, kInterrupt2_RegisterId),
      kBC_TC_Error_Confirm2Id           = nNIMXRegisterMap120_mBuildFieldId(tInterrupt2_Register::kBC_TC_Error_Confirm2Id, kInterrupt2_RegisterId),
      kUC_TC_Interrupt_Ack2Id           = nNIMXRegisterMap120_mBuildFieldId(tInterrupt2_Register::kUC_TC_Interrupt_Ack2Id, kInterrupt2_RegisterId),
      kBC_TC_Interrupt_Ack2Id           = nNIMXRegisterMap120_mBuildFieldId(tInterrupt2_Register::kBC_TC_Interrupt_Ack2Id, kInterrupt2_RegisterId),
      kSTART1_Interrupt_Ack2Id          = nNIMXRegisterMap120_mBuildFieldId(tInterrupt2_Register::kSTART1_Interrupt_Ack2Id, kInterrupt2_RegisterId),
      kUPDATE_Interrupt_Ack2Id          = nNIMXRegisterMap120_mBuildFieldId(tInterrupt2_Register::kUPDATE_Interrupt_Ack2Id, kInterrupt2_RegisterId),
      kError_Interrupt_Ack2Id           = nNIMXRegisterMap120_mBuildFieldId(tInterrupt2_Register::kError_Interrupt_Ack2Id, kInterrupt2_RegisterId),

      kReset_RegisterId                 = 16,
      kResetId                          = nNIMXRegisterMap120_mBuildFieldId(tReset_Register::kResetId, kReset_RegisterId),
      kConfiguration_StartId            = nNIMXRegisterMap120_mBuildFieldId(tReset_Register::kConfiguration_StartId, kReset_RegisterId),
      kConfiguration_EndId              = nNIMXRegisterMap120_mBuildFieldId(tReset_Register::kConfiguration_EndId, kReset_RegisterId),
      kFIFO_ClearId                     = nNIMXRegisterMap120_mBuildFieldId(tReset_Register::kFIFO_ClearId, kReset_RegisterId),


      kMaxRegisterId = 16

   } tId;

   tOutTimer(tBusSpaceReference addrSpace, nMDBG::tStatus2* statusChain = NULL);
   tOutTimer();
   void initialize(tBusSpaceReference addrSpace, u32 addressOffset, nMDBG::tStatus2* statusChain = NULL);
   void reset(nMDBG::tStatus2* statusChain = NULL);
   virtual ~tOutTimer();

   inline tBusSpaceReference getBusSpaceReference(void) const;

   inline void setAddressOffset(u32 value, nMDBG::tStatus2* statusChain = NULL);
   inline u32  getAddressOffset(nMDBG::tStatus2* statusChain = NULL);
   inline tBoolean isDirty(tId id, nMDBG::tStatus2* statusChain = NULL);
   inline void markDirty(tId id, nMDBG::tStatus2* statusChain = NULL);
   inline void markClean(tId id, nMDBG::tStatus2* statusChain = NULL);

   inline void markDirty(nMDBG::tStatus2* statusChain = NULL);
   inline void markClean(nMDBG::tStatus2* statusChain = NULL);

private:
   void _initialize(nMDBG::tStatus2* statusChain = NULL);
   tBusSpaceReference _addrSpace;
   u32 _addressOffset;
   u8 _dirtyVector[17];

};

#ifndef ___tOutTimer_ipp___
#ifndef ___tOutTimer_h_no_inline___
#include "tOutTimer.ipp"
#endif

#endif

#endif


// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// This file is autogenerated!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!

