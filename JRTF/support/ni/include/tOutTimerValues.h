// Copyright 2011 National Instruments
// License: NATIONAL INSTRUMENTS SOFTWARE LICENSE AGREEMENT
//   Refer to "MHDDK License Agreement.pdf" in the root of this distribution.

// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// This file is autogenerated!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!

#ifndef ___tOutTimerValues_h___
#define ___tOutTimerValues_h___

namespace nOutTimer {
   typedef enum {
      kSyncDefault                       = 0,
      kSyncSlave                         = 1,
      kSyncMaster                        = 2,
   } tOutTimerSyncMode_t;

   typedef enum {
      kDisarmed                          = 0,
      kArmed                             = 1,
   } tOutTimer_Armed_t;

   typedef enum {
      kBC_Gate_Inactive                  = 0,
      kBC_Gate_Active                    = 1,
   } tOutTimer_BC_Gate_t;

   typedef enum {
      kBC_St_WAIT                        = 0,
      kBC_St_CNT                         = 1,
   } tOutTimer_BC_Q_t;

   typedef enum {
      kBC_Reload_No_Change               = 0,
      kBC_Reload_Switch_On_BC_TC         = 1,
   } tOutTimer_BC_Reload_Mode_t;

   typedef enum {
      kFiniteOp                          = 0,
      kContinuousOp                      = 1,
   } tOutTimer_Continuous_t;

   typedef enum {
      kDisabled                          = 0,
      kEnabled                           = 1,
   } tOutTimer_Disabled_Enabled_t;

   typedef enum {
      kNo_error                          = 0,
      kError                             = 1,
   } tOutTimer_Error_t;

   typedef enum {
      kExtGate_Pause_Operation           = 0,
      kExtGate_Enable_Operation          = 1,
   } tOutTimer_External_Gate_t;

   typedef enum {
      kNot_empty                         = 0,
      kEmpty                             = 1,
   } tOutTimer_FIFO_Empty_t;

   typedef enum {
      kNot_full                          = 0,
      kFull                              = 1,
   } tOutTimer_FIFO_Full_t;

   typedef enum {
      kHalf_full_or_less                 = 0,
      kMore_than_half_full               = 1,
   } tOutTimer_FIFO_Half_Full_t;

   typedef enum {
      kFifoMode_Empty                    = 0,
      kFifoMode_Less_Than_Half_Full      = 1,
      kFifoMode_Less_Than_Full           = 2,
      kFifoMode_Less_Than_Half_Full_to_Full      = 3,
   } tOutTimer_FIFO_Mode_t;

   typedef enum {
      kReg_A                             = 0,
      kReg_B                             = 1,
   } tOutTimer_Load_Source_t;

   typedef enum {
      kNormal_buffer                     = 0,
      kMute_buffer                       = 1,
   } tOutTimer_Mute_t;

   typedef enum {
      kRising_Edge                       = 0,
      kFalling_Edge                      = 1,
   } tOutTimer_Polarity_t;

   typedef enum {
      kSwGate_Enable_operation           = 0,
      kSwGate_Pause_operation            = 1,
   } tOutTimer_Software_Gate_t;

   typedef enum {
      kExportSynchronizedTriggers        = 0,
      kExportEdgeDetectedTriggers        = 1,
   } tOutTimer_Start1_Export_Mode_t;

   typedef enum {
      kContinue_on_Error                 = 0,
      kStop_on_Error                     = 1,
   } tOutTimer_Stop_On_Error_t;

   typedef enum {
      kWritesCompleted                   = 0,
      kWritesInProgress                  = 1,
   } tOutTimer_TMRDACWRs_In_Progress_t;

   typedef enum {
      kHas_Not_Happened                  = 0,
      kHas_Happened                      = 1,
   } tOutTimer_Trigger_t;

   typedef enum {
      kUC_Idle                           = 0,
      kUC_Counting                       = 1,
   } tOutTimer_UC_Q_t;

   typedef enum {
      kNo_Change                         = 0,
      kSwitch_Every_UC_TC                = 1,
      kSwitch_Every_BC_TC                = 2,
      kAlternate_First_Period_Every_BC_TC    = 3,
   } tOutTimer_UC_Reload_Mode_t;

   typedef enum {
      kUI_CountNotEnabled                = 0,
      kUI_CoundIsEnabled                 = 1,
   } tOutTimer_UI_Count_Enabled_t;

   typedef enum {
      kNo_Switch_Pending                 = 0,
      kSwitch_Pending                    = 1,
   } tOutTimer_UI_Load_Switch_Pending_t;

   typedef enum {
      kUI_St_WAIT                        = 0,
      kUI_St_CNT                         = 1,
   } tOutTimer_UI_Q_t;

   typedef enum {
      kUI_Reload_No_Change               = 0,
      kUI_Reload_Switch_On_UC_TC_First   = 4,
      kUI_Reload_Switch_On_UC_TC         = 5,
      kUI_Reload_Switch_On_BC_TC_First   = 6,
      kUI_Reload_Switch_On_BC_TC         = 7,
   } tOutTimer_UI_Reload_Mode_t;

   typedef enum {
      kUI_Src_TB3                        = 0,
      kUI_Src_PFI0                       = 1,
      kUI_Src_PFI1                       = 2,
      kUI_Src_PFI2                       = 3,
      kUI_Src_PFI3                       = 4,
      kUI_Src_PFI4                       = 5,
      kUI_Src_PFI5                       = 6,
      kUI_Src_PFI6                       = 7,
      kUI_Src_PFI7                       = 8,
      kUI_Src_PFI8                       = 9,
      kUI_Src_PFI9                       = 10,
      kUI_Src_RTSI0                      = 11,
      kUI_Src_RTSI1                      = 12,
      kUI_Src_RTSI2                      = 13,
      kUI_Src_RTSI3                      = 14,
      kUI_Src_RTSI4                      = 15,
      kUI_Src_RTSI5                      = 16,
      kUI_Src_RTSI6                      = 17,
      kUI_Src_DStarA                     = 18,
      kUI_Src_TB2                        = 19,
      kUI_Src_Star_Trigger               = 20,
      kUI_Src_PFI10                      = 21,
      kUI_Src_PFI11                      = 22,
      kUI_Src_PFI12                      = 23,
      kUI_Src_PFI13                      = 24,
      kUI_Src_PFI14                      = 25,
      kUI_Src_PFI15                      = 26,
      kUI_Src_RTSI7                      = 27,
      kUI_Src_TB1                        = 28,
      kUI_Src_PXI_Clk10                  = 29,
      kUI_Src_Analog_Trigger             = 30,
      kUI_Src_DStarB                     = 31,
   } tOutTimer_UI_Source_Select_t;

   typedef enum {
      kWrite_A                           = 0,
      kWrite_Inactive_Register           = 1,
   } tOutTimer_Write_Switch_t;

   namespace nCommand_1_Register {
      namespace nSTART1_Pulse {
         enum {
            kMask = 0x1,
            kOffset = 0,
         };
      }

      namespace nBC_Switch_Load_On_TC {
         enum {
            kMask = 0x10,
            kOffset = 0x4,
         };
      }

      namespace nUC_Switch_Load_On_TC {
         enum {
            kMask = 0x20,
            kOffset = 0x5,
         };
      }

      namespace nUC_Switch_Load_On_BC_TC {
         enum {
            kMask = 0x40,
            kOffset = 0x6,
         };
      }

      namespace nUI_Switch_Load_On_TC {
         enum {
            kMask = 0x80,
            kOffset = 0x7,
         };
      }

      namespace nUI_Switch_Load_On_UC_TC {
         enum {
            kMask = 0x100,
            kOffset = 0x8,
         };
      }

      namespace nUI_Switch_Load_On_BC_TC {
         enum {
            kMask = 0x200,
            kOffset = 0x9,
         };
      }

      namespace nUI_Cancel_Load_Switch {
         enum {
            kMask = 0x1000,
            kOffset = 0xc,
         };
      }

      namespace nEnd_On_UC_TC {
         enum {
            kMask = 0x4000,
            kOffset = 0xe,
         };
      }

      namespace nEnd_On_BC_TC {
         enum {
            kMask = 0x8000,
            kOffset = 0xf,
         };
      }

      namespace nUpdate_Pulse {
         enum {
            kMask = 0x10000,
            kOffset = 0x10,
         };
      }

      namespace nBC_Load {
         enum {
            kMask = 0x200000,
            kOffset = 0x15,
         };
      }

      namespace nBC_Arm {
         enum {
            kMask = 0x400000,
            kOffset = 0x16,
         };
      }

      namespace nUC_Load {
         enum {
            kMask = 0x800000,
            kOffset = 0x17,
         };
      }

      namespace nUC_Arm {
         enum {
            kMask = 0x1000000,
            kOffset = 0x18,
         };
      }

      namespace nUI_Load {
         enum {
            kMask = 0x2000000,
            kOffset = 0x19,
         };
      }

      namespace nUI_Arm {
         enum {
            kMask = 0x4000000,
            kOffset = 0x1a,
         };
      }

      namespace nDisarm {
         enum {
            kMask = 0x20000000,
            kOffset = 0x1d,
         };
      }

   }

   namespace nStatus_1_Register {
      namespace nBC_Armed_St {
         enum {
            kMask = 0x1,
            kOffset = 0,
         };
      }

      namespace nBC_Next_Load_Source_St {
         enum {
            kMask = 0x2,
            kOffset = 0x1,
         };
      }

      namespace nWrite_Too_Fast_St {
         enum {
            kMask = 0x4,
            kOffset = 0x2,
         };
      }

      namespace nBC_Q_St {
         enum {
            kMask = 0x8,
            kOffset = 0x3,
         };
      }

      namespace nBC_TC_Trigger_Error_St {
         enum {
            kMask = 0x10,
            kOffset = 0x4,
         };
      }

      namespace nUI_Armed_St {
         enum {
            kMask = 0x20,
            kOffset = 0x5,
         };
      }

      namespace nUI_Next_Load_Source_St {
         enum {
            kMask = 0x40,
            kOffset = 0x6,
         };
      }

      namespace nUI_Load_Switch_Pending_St {
         enum {
            kMask = 0x80,
            kOffset = 0x7,
         };
      }

      namespace nUI_Count_Enabled_St {
         enum {
            kMask = 0x100,
            kOffset = 0x8,
         };
      }

      namespace nUI_Q_St {
         enum {
            kMask = 0x200,
            kOffset = 0x9,
         };
      }

      namespace nTMRDACWRs_In_Progress_St {
         enum {
            kMask = 0x400,
            kOffset = 0xa,
         };
      }

      namespace nBC_Gate_St {
         enum {
            kMask = 0x800,
            kOffset = 0xb,
         };
      }

      namespace nExternal_Gate_St {
         enum {
            kMask = 0x1000,
            kOffset = 0xc,
         };
      }

      namespace nUC_Q_St {
         enum {
            kMask = 0x2000,
            kOffset = 0xd,
         };
      }

      namespace nUC_Armed_St {
         enum {
            kMask = 0x4000,
            kOffset = 0xe,
         };
      }

      namespace nUC_Next_Load_Source_St {
         enum {
            kMask = 0x8000,
            kOffset = 0xf,
         };
      }

      namespace nFIFO_Request_St {
         enum {
            kMask = 0x20000,
            kOffset = 0x11,
         };
      }

      namespace nUPDATE_St {
         enum {
            kMask = 0x200000,
            kOffset = 0x15,
         };
      }

      namespace nUC_TC_St {
         enum {
            kMask = 0x400000,
            kOffset = 0x16,
         };
      }

      namespace nBC_TC_St {
         enum {
            kMask = 0x800000,
            kOffset = 0x17,
         };
      }

      namespace nSTART1_St {
         enum {
            kMask = 0x1000000,
            kOffset = 0x18,
         };
      }

      namespace nOverrun_St {
         enum {
            kMask = 0x2000000,
            kOffset = 0x19,
         };
      }

      namespace nUnderflow_St {
         enum {
            kMask = 0x4000000,
            kOffset = 0x1a,
         };
      }

      namespace nBC_TC_Error_St {
         enum {
            kMask = 0x8000000,
            kOffset = 0x1b,
         };
      }

      namespace nFIFO_Empty_St {
         enum {
            kMask = 0x10000000,
            kOffset = 0x1c,
         };
      }

      namespace nFIFO_Half_Full_St {
         enum {
            kMask = 0x20000000,
            kOffset = 0x1d,
         };
      }

      namespace nFIFO_Full_St {
         enum {
            kMask = 0x40000000,
            kOffset = 0x1e,
         };
      }

   }

   namespace nUI_Load_A_Register {
      namespace nUI_Load_A {
         enum {
            kMask = 0xffffffff,
            kOffset = 0,
         };
      }

   }

   namespace nUI_Save_Register {
      namespace nUI_Save {
         enum {
            kMask = 0xffffffff,
            kOffset = 0,
         };
      }

   }

   namespace nUI_Load_B_Register {
      namespace nUI_Load_B {
         enum {
            kMask = 0xffffffff,
            kOffset = 0,
         };
      }

   }

   namespace nUC_Load_A_Register {
      namespace nUC_Load_A {
         enum {
            kMask = 0xffffffff,
            kOffset = 0,
         };
      }

   }

   namespace nUC_Save_Register {
      namespace nUC_Save {
         enum {
            kMask = 0xffffffff,
            kOffset = 0,
         };
      }

   }

   namespace nUC_Load_B_Register {
      namespace nUC_Load_B {
         enum {
            kMask = 0xffffffff,
            kOffset = 0,
         };
      }

   }

   namespace nBC_Load_A_Register {
      namespace nBC_Load_A {
         enum {
            kMask = 0xffffffff,
            kOffset = 0,
         };
      }

   }

   namespace nBC_Save_Register {
      namespace nBC_Save {
         enum {
            kMask = 0xffffffff,
            kOffset = 0,
         };
      }

   }

   namespace nBC_Load_B_Register {
      namespace nBC_Load_B {
         enum {
            kMask = 0xffffffff,
            kOffset = 0,
         };
      }

   }

   namespace nMode_1_Register {
      namespace nBC_Write_Switch {
         enum {
            kMask = 0x1,
            kOffset = 0,
         };
      }

      namespace nBC_Reload_Mode {
         enum {
            kMask = 0x2,
            kOffset = 0x1,
         };
      }

      namespace nBC_Initial_Load_Source {
         enum {
            kMask = 0x4,
            kOffset = 0x2,
         };
      }

      namespace nUI_Write_Switch {
         enum {
            kMask = 0x8,
            kOffset = 0x3,
         };
      }

      namespace nUI_Reload_Mode {
         enum {
            kMask = 0x70,
            kOffset = 0x4,
         };
      }

      namespace nUI_Initial_Load_Source {
         enum {
            kMask = 0x80,
            kOffset = 0x7,
         };
      }

      namespace nUC_Write_Switch {
         enum {
            kMask = 0x400,
            kOffset = 0xa,
         };
      }

      namespace nUC_Initial_Load_Source {
         enum {
            kMask = 0x800,
            kOffset = 0xb,
         };
      }

      namespace nFIFO_Retransmit_Enable {
         enum {
            kMask = 0x2000,
            kOffset = 0xd,
         };
      }

      namespace nFIFO_Mode {
         enum {
            kMask = 0xc000,
            kOffset = 0xe,
         };
      }

      namespace nTrigger_Once {
         enum {
            kMask = 0x10000,
            kOffset = 0x10,
         };
      }

      namespace nContinuous {
         enum {
            kMask = 0x20000,
            kOffset = 0x11,
         };
      }

      namespace nUI_Source_Polarity {
         enum {
            kMask = 0x80000,
            kOffset = 0x13,
         };
      }

      namespace nUI_Source_Select {
         enum {
            kMask = 0x7c00000,
            kOffset = 0x16,
         };
      }

      namespace nUC_Reload_Mode {
         enum {
            kMask = 0x18000000,
            kOffset = 0x1b,
         };
      }

   }

   namespace nMode_2_Register {
      namespace nMute_A {
         enum {
            kMask = 0x4,
            kOffset = 0x2,
         };
      }

      namespace nMute_B {
         enum {
            kMask = 0x8,
            kOffset = 0x3,
         };
      }

      namespace nSyncMode {
         enum {
            kMask = 0x180,
            kOffset = 0x7,
         };
      }

      namespace nSoftware_Gate {
         enum {
            kMask = 0x20000,
            kOffset = 0x11,
         };
      }

      namespace nNot_An_UPDATE {
         enum {
            kMask = 0x40000,
            kOffset = 0x12,
         };
      }

      namespace nStop_On_BC_TC_Error {
         enum {
            kMask = 0x80000,
            kOffset = 0x13,
         };
      }

      namespace nStop_On_BC_TC_Trigger_Error {
         enum {
            kMask = 0x100000,
            kOffset = 0x14,
         };
      }

      namespace nStop_On_Overrun_Error {
         enum {
            kMask = 0x200000,
            kOffset = 0x15,
         };
      }

      namespace nAOFREQ_Enable {
         enum {
            kMask = 0x400000,
            kOffset = 0x16,
         };
      }

      namespace nHold_BC_On_UC_Read {
         enum {
            kMask = 0x4000000,
            kOffset = 0x1a,
         };
      }

      namespace nStart1_Export_Mode {
         enum {
            kMask = 0x8000000,
            kOffset = 0x1b,
         };
      }

      namespace nFIFO_Enable {
         enum {
            kMask = 0x20000000,
            kOffset = 0x1d,
         };
      }

      namespace nBC_Gate_Enable {
         enum {
            kMask = 0x40000000,
            kOffset = 0x1e,
         };
      }

   }

   namespace nOutput_Control_Register {
      namespace nExportedUpdatePolarity {
         enum {
            kMask = 0x1,
            kOffset = 0,
         };
      }

      namespace nNumber_Of_Channels {
         enum {
            kMask = 0xff00,
            kOffset = 0x8,
         };
      }

   }

   namespace nInterrupt1_Register {
      namespace nBC_TC_Interrupt_Enable {
         enum {
            kMask = 0x1,
            kOffset = 0,
         };
      }

      namespace nSTART1_Interrupt_Enable {
         enum {
            kMask = 0x2,
            kOffset = 0x1,
         };
      }

      namespace nUPDATE_Interrupt_Enable {
         enum {
            kMask = 0x4,
            kOffset = 0x2,
         };
      }

      namespace nError_Interrupt_Enable {
         enum {
            kMask = 0x20,
            kOffset = 0x5,
         };
      }

      namespace nUC_TC_Interrupt_Enable {
         enum {
            kMask = 0x40,
            kOffset = 0x6,
         };
      }

      namespace nFIFO_Interrupt_Enable {
         enum {
            kMask = 0x100,
            kOffset = 0x8,
         };
      }

      namespace nWrite_Too_Fast_Interrupt_Enable {
         enum {
            kMask = 0x200,
            kOffset = 0x9,
         };
      }

      namespace nWrite_Too_Fast_Interrupt_Ack {
         enum {
            kMask = 0x10000,
            kOffset = 0x10,
         };
      }

      namespace nBC_TC_Trigger_Error_Confirm {
         enum {
            kMask = 0x80000,
            kOffset = 0x13,
         };
      }

      namespace nBC_TC_Error_Confirm {
         enum {
            kMask = 0x100000,
            kOffset = 0x14,
         };
      }

      namespace nUC_TC_Interrupt_Ack {
         enum {
            kMask = 0x800000,
            kOffset = 0x17,
         };
      }

      namespace nBC_TC_Interrupt_Ack {
         enum {
            kMask = 0x1000000,
            kOffset = 0x18,
         };
      }

      namespace nSTART1_Interrupt_Ack {
         enum {
            kMask = 0x2000000,
            kOffset = 0x19,
         };
      }

      namespace nUPDATE_Interrupt_Ack {
         enum {
            kMask = 0x4000000,
            kOffset = 0x1a,
         };
      }

      namespace nError_Interrupt_Ack {
         enum {
            kMask = 0x20000000,
            kOffset = 0x1d,
         };
      }

   }

   namespace nInterrupt2_Register {
      namespace nBC_TC_Interrupt_Disable {
         enum {
            kMask = 0x1,
            kOffset = 0,
         };
      }

      namespace nSTART1_Interrupt_Disable {
         enum {
            kMask = 0x2,
            kOffset = 0x1,
         };
      }

      namespace nUPDATE_Interrupt_Disable {
         enum {
            kMask = 0x4,
            kOffset = 0x2,
         };
      }

      namespace nError_Interrupt_Disable {
         enum {
            kMask = 0x20,
            kOffset = 0x5,
         };
      }

      namespace nUC_TC_Interrupt_Disable {
         enum {
            kMask = 0x40,
            kOffset = 0x6,
         };
      }

      namespace nFIFO_Interrupt_Disable {
         enum {
            kMask = 0x100,
            kOffset = 0x8,
         };
      }

      namespace nWrite_Too_Fast_Interrupt_Disable {
         enum {
            kMask = 0x200,
            kOffset = 0x9,
         };
      }

      namespace nWrite_Too_Fast_Interrupt_Ack2 {
         enum {
            kMask = 0x10000,
            kOffset = 0x10,
         };
      }

      namespace nBC_TC_Trigger_Error_Confirm2 {
         enum {
            kMask = 0x80000,
            kOffset = 0x13,
         };
      }

      namespace nBC_TC_Error_Confirm2 {
         enum {
            kMask = 0x100000,
            kOffset = 0x14,
         };
      }

      namespace nUC_TC_Interrupt_Ack2 {
         enum {
            kMask = 0x800000,
            kOffset = 0x17,
         };
      }

      namespace nBC_TC_Interrupt_Ack2 {
         enum {
            kMask = 0x1000000,
            kOffset = 0x18,
         };
      }

      namespace nSTART1_Interrupt_Ack2 {
         enum {
            kMask = 0x2000000,
            kOffset = 0x19,
         };
      }

      namespace nUPDATE_Interrupt_Ack2 {
         enum {
            kMask = 0x4000000,
            kOffset = 0x1a,
         };
      }

      namespace nError_Interrupt_Ack2 {
         enum {
            kMask = 0x20000000,
            kOffset = 0x1d,
         };
      }

   }

   namespace nReset_Register {
      namespace nReset {
         enum {
            kMask = 0x1,
            kOffset = 0,
         };
      }

      namespace nConfiguration_Start {
         enum {
            kMask = 0x2,
            kOffset = 0x1,
         };
      }

      namespace nConfiguration_End {
         enum {
            kMask = 0x4,
            kOffset = 0x2,
         };
      }

      namespace nFIFO_Clear {
         enum {
            kMask = 0x8,
            kOffset = 0x3,
         };
      }

   }

   using namespace nCommand_1_Register;
   using namespace nStatus_1_Register;
   using namespace nUI_Load_A_Register;
   using namespace nUI_Save_Register;
   using namespace nUI_Load_B_Register;
   using namespace nUC_Load_A_Register;
   using namespace nUC_Save_Register;
   using namespace nUC_Load_B_Register;
   using namespace nBC_Load_A_Register;
   using namespace nBC_Save_Register;
   using namespace nBC_Load_B_Register;
   using namespace nMode_1_Register;
   using namespace nMode_2_Register;
   using namespace nOutput_Control_Register;
   using namespace nInterrupt1_Register;
   using namespace nInterrupt2_Register;
   using namespace nReset_Register;
}

#endif


// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// This file is autogenerated!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!

