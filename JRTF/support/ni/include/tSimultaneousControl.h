// Copyright 2011 National Instruments
// License: NATIONAL INSTRUMENTS SOFTWARE LICENSE AGREEMENT
//   Refer to "MHDDK License Agreement.pdf" in the root of this distribution.

// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// This file is autogenerated!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!

#ifndef ___tSimultaneousControl_h___
#define ___tSimultaneousControl_h___

// includes
#include "osiTypes.h"
#include "osiBus.h"
#include "tSimultaneousControlValues.h"


#ifndef ___tSimultaneousControlValues_h___
#include "tSimultaneousControlValues.h"
#endif

#ifndef nNIMXRegisterMap120_mBuildFieldId

// Algorithm:
//    Move lowermost 5 bits (4 through 0) of field id to uppermost 5 bits (31
//          through 27)
//    Move bit 5 of field id to bit 26
//    Move bit 6 of field id to bit 25
//    OR in the register id (which is allowed the remaining bits)
//
// Why not move the lowermost 7 bits directly to the uppermost 7 bits? Because
// we originally moved only the lowermost 5, and for backwards compatibility,
// we can't change where those 5 bits end up.
//
// For future expansion purposes, the bits beyond the first 5 are put in reverse
// order in the resulting combined id.
#define nNIMXRegisterMap120_mBuildFieldId(fieldId, regId) \
   ( \
     ((fieldId) << 27) | \
     ((((fieldId) >> 5) & 0x1) << 26) | \
     ((((fieldId) >> 6) & 0x1) << 25) | \
     (regId) \
   )

#endif

#ifndef nNIMXRegisterMap120_mExtractFieldId

// Algorithm: (basically the reverse of mBuildFieldId)
//    Move uppermost 5 bits (31 through 27) to lowermost 5 bits (4 through 0)
//    Move 26th bit to bit 5 (right-shifting by (26 - 5) is like right-shifting
//          by 26 then left-shifting by 5, but it's more efficient)
//    Move 25th bit to bit 6
#define nNIMXRegisterMap120_mExtractFieldId(id) \
   (unsigned int) \
   ( \
     (((id) >> 27) & 0x1F) | \
     (((id) & (0x1 << 26)) >> (26 - 5)) | \
     (((id) & (0x1 << 25)) >> (25 - 6)) \
   )

#endif

class tSimultaneousControl
{
public:
   //---------------------------------------------------------------------------
   // IO Strategies
   //---------------------------------------------------------------------------
   class tReg8IODirect32
   {
   public:
      inline void write(
         tBusSpaceReference addrSpace,
         u32 offset,
         u8 value,
         nMDBG::tStatus2* statusChain = NULL);

      inline u8 read(
         tBusSpaceReference addrSpace,
         u32 offset,
         nMDBG::tStatus2* statusChain = NULL);
   };

   //---------------------------------------------------------------------------
   // AISetChannelOrder
   //---------------------------------------------------------------------------
   class tAISetChannelOrder : public tReg8IODirect32
   {
   public:
      typedef tReg8IODirect32 tIOStrategy;
      typedef tSimultaneousControl tRegisterMap;

      enum {
         kOffset = 0xd,
         kId     = 0
      };
      tAISetChannelOrder();


      typedef enum {
         kRegisterId                          = 0,
         kAiChannelId                      = 1,
         kMaxFieldId                          = 1
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Register Accessors (Compile-time selectable)

      inline void writeRegister(u8 value, nMDBG::tStatus2* statusChain = NULL);


      // Field Accessors (Compile-time selectable)
      inline void writeAiChannel(u8 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      tRegisterMap* _regMap;

      // Usage guidelines
      tAISetChannelOrder(const tAISetChannelOrder&);
      tAISetChannelOrder& operator=(const tAISetChannelOrder&);

   };

   //---------------------------------------------------------------------------
   // AIChanConfigCtrlStat
   //---------------------------------------------------------------------------
   class tAIChanConfigCtrlStat : public tReg8IODirect32
   {
   public:
      typedef tReg8IODirect32 tIOStrategy;
      typedef tSimultaneousControl tRegisterMap;

      enum {
         kOffset = 0xe,
         kId     = 1
      };
      tAIChanConfigCtrlStat();


      typedef enum {
         kRegisterId                          = 0,
         kAiGainId                         = 1,
         kMaxFieldId                          = 1
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Register Accessors (Compile-time selectable)

      inline void writeRegister(u8 value, nMDBG::tStatus2* statusChain = NULL);

      inline u8 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline void writeAiGain(u8 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u8 readAiGain(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      tRegisterMap* _regMap;

      // Usage guidelines
      tAIChanConfigCtrlStat(const tAIChanConfigCtrlStat&);
      tAIChanConfigCtrlStat& operator=(const tAIChanConfigCtrlStat&);

   };

   //---------------------------------------------------------------------------
   // AIClearChannelOrder
   //---------------------------------------------------------------------------
   class tAIClearChannelOrder : public tReg8IODirect32
   {
   public:
      typedef tReg8IODirect32 tIOStrategy;
      typedef tSimultaneousControl tRegisterMap;

      enum {
         kOffset = 0xf,
         kId     = 2
      };
      tAIClearChannelOrder();


      typedef enum {
         kRegisterId                          = 0,
         kAiClearConfigId                  = 1,
         kMaxFieldId                          = 1
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Register Accessors (Compile-time selectable)

      inline void writeRegister(u8 value, nMDBG::tStatus2* statusChain = NULL);


      // Field Accessors (Compile-time selectable)
      inline void writeAiClearConfig(u8 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      tRegisterMap* _regMap;

      // Usage guidelines
      tAIClearChannelOrder(const tAIClearChannelOrder&);
      tAIClearChannelOrder& operator=(const tAIClearChannelOrder&);

   };

   //---------------------------------------------------------------------------
   // AITriggerConfigCtrlStat
   //---------------------------------------------------------------------------
   class tAITriggerConfigCtrlStat : public tReg8IODirect32
   {
   public:
      typedef tReg8IODirect32 tIOStrategy;
      typedef tSimultaneousControl tRegisterMap;

      enum {
         kOffset = 0x10,
         kId     = 3
      };
      tAITriggerConfigCtrlStat();


      typedef enum {
         kRegisterId                          = 0,
         kAiTrigSelId                      = 1,
         kMaxFieldId                          = 1
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Dirty Tracking
      inline tBoolean isDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markClean(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tAITriggerConfigCtrlStat& setRegister(u8 value, nMDBG::tStatus2* statusChain = NULL);
      inline u8 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline void writeRegister(u8 value, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline void refresh(nMDBG::tStatus2* statusChain = NULL);

      inline u8 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tAITriggerConfigCtrlStat& setAiTrigSel(u8 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u8 getAiTrigSel(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeAiTrigSel(u8 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u8 readAiTrigSel(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u8 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tAITriggerConfigCtrlStat(const tAITriggerConfigCtrlStat&);
      tAITriggerConfigCtrlStat& operator=(const tAITriggerConfigCtrlStat&);

   };

   //---------------------------------------------------------------------------
   // AcquisitionCtrl
   //---------------------------------------------------------------------------
   class tAcquisitionCtrl : public tReg8IODirect32
   {
   public:
      typedef tReg8IODirect32 tIOStrategy;
      typedef tSimultaneousControl tRegisterMap;

      enum {
         kOffset = 0x1b,
         kId     = 4
      };
      tAcquisitionCtrl();


      typedef enum {
         kRegisterId                          = 0,
         kAcquisitionDoneId                = 1,
         kExtendedChannelsPresentId        = 2,
         kMaxFieldId                          = 2
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Register Accessors (Compile-time selectable)

      inline void writeRegister(u8 value, nMDBG::tStatus2* statusChain = NULL);

      inline u8 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline void writeAcquisitionDone(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readAcquisitionDone(nMDBG::tStatus2* statusChain = NULL);

      inline void writeExtendedChannelsPresent(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readExtendedChannelsPresent(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      tRegisterMap* _regMap;

      // Usage guidelines
      tAcquisitionCtrl(const tAcquisitionCtrl&);
      tAcquisitionCtrl& operator=(const tAcquisitionCtrl&);

   };

   //---------------------------------------------------------------------------
   // AiFifoCtrlStat
   //---------------------------------------------------------------------------
   class tAiFifoCtrlStat : public tReg8IODirect32
   {
   public:
      typedef tReg8IODirect32 tIOStrategy;
      typedef tSimultaneousControl tRegisterMap;

      enum {
         kOffset = 0x14,
         kId     = 5
      };
      tAiFifoCtrlStat();


      typedef enum {
         kRegisterId                          = 0,
         kSampleStrandedId                 = 1,
         kNotEmptyId                       = 2,
         kSetFifoIn16BitModeId             = 3,
         kClrFifoIn16BitModeId             = 4,
         kResetAiFifoId                    = 7,
         kMaxFieldId                          = 7
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Register Accessors (Compile-time selectable)

      inline void writeRegister(u8 value, nMDBG::tStatus2* statusChain = NULL);

      inline u8 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline void writeSampleStranded(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readSampleStranded(nMDBG::tStatus2* statusChain = NULL);

      inline void writeNotEmpty(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readNotEmpty(nMDBG::tStatus2* statusChain = NULL);

      inline void writeSetFifoIn16BitMode(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readSetFifoIn16BitMode(nMDBG::tStatus2* statusChain = NULL);

      inline void writeClrFifoIn16BitMode(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readClrFifoIn16BitMode(nMDBG::tStatus2* statusChain = NULL);

      inline void writeResetAiFifo(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readResetAiFifo(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      tRegisterMap* _regMap;

      // Usage guidelines
      tAiFifoCtrlStat(const tAiFifoCtrlStat&);
      tAiFifoCtrlStat& operator=(const tAiFifoCtrlStat&);

   };

   //---------------------------------------------------------------------------
   // LoopbackCtrlStat
   //---------------------------------------------------------------------------
   class tLoopbackCtrlStat : public tReg8IODirect32
   {
   public:
      typedef tReg8IODirect32 tIOStrategy;
      typedef tSimultaneousControl tRegisterMap;

      enum {
         kOffset = 0x15,
         kId     = 6
      };
      tLoopbackCtrlStat();


      typedef enum {
         kRegisterId                          = 0,
         kSetLoopNegId                     = 1,
         kClrLoopNegId                     = 2,
         kSetLoopPosId                     = 3,
         kClrLoopPosId                     = 4,
         kMaxFieldId                          = 4
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Register Accessors (Compile-time selectable)

      inline void writeRegister(u8 value, nMDBG::tStatus2* statusChain = NULL);

      inline u8 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline void writeSetLoopNeg(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readSetLoopNeg(nMDBG::tStatus2* statusChain = NULL);

      inline void writeClrLoopNeg(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readClrLoopNeg(nMDBG::tStatus2* statusChain = NULL);

      inline void writeSetLoopPos(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readSetLoopPos(nMDBG::tStatus2* statusChain = NULL);

      inline void writeClrLoopPos(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readClrLoopPos(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      tRegisterMap* _regMap;

      // Usage guidelines
      tLoopbackCtrlStat(const tLoopbackCtrlStat&);
      tLoopbackCtrlStat& operator=(const tLoopbackCtrlStat&);

   };

   //---------------------------------------------------------------------------
   // LoopbackSourceSel
   //---------------------------------------------------------------------------
   class tLoopbackSourceSel : public tReg8IODirect32
   {
   public:
      typedef tReg8IODirect32 tIOStrategy;
      typedef tSimultaneousControl tRegisterMap;

      enum {
         kOffset = 0x16,
         kId     = 7
      };
      tLoopbackSourceSel();


      typedef enum {
         kRegisterId                          = 0,
         kLoopbackMuxSelId                 = 1,
         kMaxFieldId                          = 1
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Dirty Tracking
      inline tBoolean isDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markClean(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tLoopbackSourceSel& setRegister(u8 value, nMDBG::tStatus2* statusChain = NULL);
      inline u8 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline void writeRegister(u8 value, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline void refresh(nMDBG::tStatus2* statusChain = NULL);

      inline u8 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tLoopbackSourceSel& setLoopbackMuxSel(u8 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u8 getLoopbackMuxSel(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeLoopbackMuxSel(u8 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u8 readLoopbackMuxSel(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u8 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tLoopbackSourceSel(const tLoopbackSourceSel&);
      tLoopbackSourceSel& operator=(const tLoopbackSourceSel&);

   };

   //---------------------------------------------------------------------------
   // DcmCtrlStat
   //---------------------------------------------------------------------------
   class tDcmCtrlStat : public tReg8IODirect32
   {
   public:
      typedef tReg8IODirect32 tIOStrategy;
      typedef tSimultaneousControl tRegisterMap;

      enum {
         kOffset = 0x1c,
         kId     = 8
      };
      tDcmCtrlStat();


      typedef enum {
         kRegisterId                          = 0,
         kSetExtDcmResetId                 = 1,
         kClrExtDcmResetId                 = 2,
         kExtDcmResetStatusId              = 3,
         kExtDcmIsLockedId                 = 4,
         kSetStc3DcmResetId                = 5,
         kClrStc3DcmResetId                = 6,
         kStc3DcmResetStatusId             = 7,
         kStc3DcmIsLockedId                = 8,
         kMaxFieldId                          = 8
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Register Accessors (Compile-time selectable)

      inline void writeRegister(u8 value, nMDBG::tStatus2* statusChain = NULL);

      inline u8 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline void writeSetExtDcmReset(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readSetExtDcmReset(nMDBG::tStatus2* statusChain = NULL);

      inline void writeClrExtDcmReset(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readClrExtDcmReset(nMDBG::tStatus2* statusChain = NULL);

      inline void writeExtDcmResetStatus(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readExtDcmResetStatus(nMDBG::tStatus2* statusChain = NULL);

      inline void writeExtDcmIsLocked(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readExtDcmIsLocked(nMDBG::tStatus2* statusChain = NULL);

      inline void writeSetStc3DcmReset(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readSetStc3DcmReset(nMDBG::tStatus2* statusChain = NULL);

      inline void writeClrStc3DcmReset(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readClrStc3DcmReset(nMDBG::tStatus2* statusChain = NULL);

      inline void writeStc3DcmResetStatus(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readStc3DcmResetStatus(nMDBG::tStatus2* statusChain = NULL);

      inline void writeStc3DcmIsLocked(tBoolean fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readStc3DcmIsLocked(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      tRegisterMap* _regMap;

      // Usage guidelines
      tDcmCtrlStat(const tDcmCtrlStat&);
      tDcmCtrlStat& operator=(const tDcmCtrlStat&);

   };

   //---------------------------------------------------------------------------
   // InterruptControl
   //---------------------------------------------------------------------------
   class tInterruptControl : public tReg8IODirect32
   {
   public:
      typedef tReg8IODirect32 tIOStrategy;
      typedef tSimultaneousControl tRegisterMap;

      enum {
         kOffset = 0x1a,
         kId     = 9
      };
      tInterruptControl();


      typedef enum {
         kRegisterId                          = 0,
         kAiFifoOverflowInterruptAckId     = 2,
         kAiFifoOverflowInterruptDisableId   = 3,
         kAiFifoOverflowInterruptEnableId  = 4,
         kGlobalInterruptDisableId         = 6,
         kGlobalInterruptEnableId          = 7,
         kMaxFieldId                          = 7
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Register Accessors (Compile-time selectable)

      inline void writeRegister(u8 value, nMDBG::tStatus2* statusChain = NULL);


      // Field Accessors (Compile-time selectable)
      inline void writeAiFifoOverflowInterruptAck(u8 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeAiFifoOverflowInterruptDisable(u8 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeAiFifoOverflowInterruptEnable(u8 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeGlobalInterruptDisable(u8 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline void writeGlobalInterruptEnable(u8 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      tRegisterMap* _regMap;

      // Usage guidelines
      tInterruptControl(const tInterruptControl&);
      tInterruptControl& operator=(const tInterruptControl&);

   };

   //---------------------------------------------------------------------------
   // InterruptStatus
   //---------------------------------------------------------------------------
   class tInterruptStatus : public tReg8IODirect32
   {
   public:
      typedef tReg8IODirect32 tIOStrategy;
      typedef tSimultaneousControl tRegisterMap;

      enum {
         kOffset = 0x1a,
         kId     = 10
      };
      tInterruptStatus();


      typedef enum {
         kRegisterId                          = 0,
         kAiFifoOverflowInterruptConditionId     = 1,
         kAiFifoOverflowInterruptStatusId  = 2,
         kAiFifoOverflowInterruptEnabledId   = 4,
         kGlobalInterruptConditionId       = 5,
         kGlobalInterruptStatusId          = 6,
         kGlobalInterruptEnabledId         = 7,
         kMaxFieldId                          = 7
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Register Accessors (Compile-time selectable)

      inline u8 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tBoolean readAiFifoOverflowInterruptCondition(nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readAiFifoOverflowInterruptStatus(nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readAiFifoOverflowInterruptEnabled(nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readGlobalInterruptCondition(nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readGlobalInterruptStatus(nMDBG::tStatus2* statusChain = NULL);

      inline tBoolean readGlobalInterruptEnabled(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      tRegisterMap* _regMap;

      // Usage guidelines
      tInterruptStatus(const tInterruptStatus&);
      tInterruptStatus& operator=(const tInterruptStatus&);

   };

   //---------------------------------------------------------------------------
   // SignatureYear
   //---------------------------------------------------------------------------
   class tSignatureYear : public tReg8IODirect32
   {
   public:
      typedef tReg8IODirect32 tIOStrategy;
      typedef tSimultaneousControl tRegisterMap;

      enum {
         kOffset = 0x0,
         kId     = 11
      };
      tSignatureYear();


      typedef enum {
         kRegisterId                          = 0,
         kDefaultId                        = 1,
         kMaxFieldId                          = 1
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Register Accessors (Compile-time selectable)
      inline tSignatureYear& setRegister(u8 value, nMDBG::tStatus2* statusChain = NULL);
      inline u8 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void refresh(nMDBG::tStatus2* statusChain = NULL);

      inline u8 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tSignatureYear& set(u8 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u8 get(nMDBG::tStatus2* statusChain = NULL) const;

      inline u8 read(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u8 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tSignatureYear(const tSignatureYear&);
      tSignatureYear& operator=(const tSignatureYear&);

   };

   //---------------------------------------------------------------------------
   // SignatureMonth
   //---------------------------------------------------------------------------
   class tSignatureMonth : public tReg8IODirect32
   {
   public:
      typedef tReg8IODirect32 tIOStrategy;
      typedef tSimultaneousControl tRegisterMap;

      enum {
         kOffset = 0x1,
         kId     = 12
      };
      tSignatureMonth();


      typedef enum {
         kRegisterId                          = 0,
         kDefaultId                        = 1,
         kMaxFieldId                          = 1
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Register Accessors (Compile-time selectable)
      inline tSignatureMonth& setRegister(u8 value, nMDBG::tStatus2* statusChain = NULL);
      inline u8 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void refresh(nMDBG::tStatus2* statusChain = NULL);

      inline u8 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tSignatureMonth& set(u8 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u8 get(nMDBG::tStatus2* statusChain = NULL) const;

      inline u8 read(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u8 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tSignatureMonth(const tSignatureMonth&);
      tSignatureMonth& operator=(const tSignatureMonth&);

   };

   //---------------------------------------------------------------------------
   // SignatureDay
   //---------------------------------------------------------------------------
   class tSignatureDay : public tReg8IODirect32
   {
   public:
      typedef tReg8IODirect32 tIOStrategy;
      typedef tSimultaneousControl tRegisterMap;

      enum {
         kOffset = 0x2,
         kId     = 13
      };
      tSignatureDay();


      typedef enum {
         kRegisterId                          = 0,
         kDefaultId                        = 1,
         kMaxFieldId                          = 1
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Register Accessors (Compile-time selectable)
      inline tSignatureDay& setRegister(u8 value, nMDBG::tStatus2* statusChain = NULL);
      inline u8 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void refresh(nMDBG::tStatus2* statusChain = NULL);

      inline u8 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tSignatureDay& set(u8 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u8 get(nMDBG::tStatus2* statusChain = NULL) const;

      inline u8 read(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u8 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tSignatureDay(const tSignatureDay&);
      tSignatureDay& operator=(const tSignatureDay&);

   };

   //---------------------------------------------------------------------------
   // SignatureHour
   //---------------------------------------------------------------------------
   class tSignatureHour : public tReg8IODirect32
   {
   public:
      typedef tReg8IODirect32 tIOStrategy;
      typedef tSimultaneousControl tRegisterMap;

      enum {
         kOffset = 0x3,
         kId     = 14
      };
      tSignatureHour();


      typedef enum {
         kRegisterId                          = 0,
         kDefaultId                        = 1,
         kMaxFieldId                          = 1
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Register Accessors (Compile-time selectable)
      inline tSignatureHour& setRegister(u8 value, nMDBG::tStatus2* statusChain = NULL);
      inline u8 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void refresh(nMDBG::tStatus2* statusChain = NULL);

      inline u8 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tSignatureHour& set(u8 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u8 get(nMDBG::tStatus2* statusChain = NULL) const;

      inline u8 read(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u8 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tSignatureHour(const tSignatureHour&);
      tSignatureHour& operator=(const tSignatureHour&);

   };

   //---------------------------------------------------------------------------
   // Scratch
   //---------------------------------------------------------------------------
   class tScratch : public tReg8IODirect32
   {
   public:
      typedef tReg8IODirect32 tIOStrategy;
      typedef tSimultaneousControl tRegisterMap;

      enum {
         kOffset = 0xc,
         kId     = 15
      };
      tScratch();


      typedef enum {
         kRegisterId                          = 0,
         kDefaultId                        = 1,
         kMaxFieldId                          = 1
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Dirty Tracking
      inline tBoolean isDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markClean(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tScratch& setRegister(u8 value, nMDBG::tStatus2* statusChain = NULL);
      inline u8 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline void writeRegister(u8 value, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline void refresh(nMDBG::tStatus2* statusChain = NULL);

      inline u8 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tScratch& set(u8 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u8 get(nMDBG::tStatus2* statusChain = NULL) const;

      inline void write(u8 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u8 read(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u8 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tScratch(const tScratch&);
      tScratch& operator=(const tScratch&);

   };

   //---------------------------------------------------------------------------
   // TempSensorCtrlStat
   //---------------------------------------------------------------------------
   class tTempSensorCtrlStat : public tReg8IODirect32
   {
   public:
      typedef tReg8IODirect32 tIOStrategy;
      typedef tSimultaneousControl tRegisterMap;

      enum {
         kOffset = 0x17,
         kId     = 16
      };
      tTempSensorCtrlStat();


      typedef enum {
         kRegisterId                          = 0,
         kTempStartId                      = 1,
         kTempReadyId                      = 2,
         kMaxFieldId                          = 2
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Register Accessors (Compile-time selectable)

      inline void writeRegister(u8 value, nMDBG::tStatus2* statusChain = NULL);

      inline u8 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline void writeTempStart(u8 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u8 readTempStart(nMDBG::tStatus2* statusChain = NULL);

      inline void writeTempReady(u8 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u8 readTempReady(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      tRegisterMap* _regMap;

      // Usage guidelines
      tTempSensorCtrlStat(const tTempSensorCtrlStat&);
      tTempSensorCtrlStat& operator=(const tTempSensorCtrlStat&);

   };

   //---------------------------------------------------------------------------
   // TempSensorDataHi
   //---------------------------------------------------------------------------
   class tTempSensorDataHi : public tReg8IODirect32
   {
   public:
      typedef tReg8IODirect32 tIOStrategy;
      typedef tSimultaneousControl tRegisterMap;

      enum {
         kOffset = 0x18,
         kId     = 17
      };
      tTempSensorDataHi();


      typedef enum {
         kRegisterId                          = 0,
         kTempUpperByteId                  = 1,
         kMaxFieldId                          = 1
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Register Accessors (Compile-time selectable)
      inline tTempSensorDataHi& setRegister(u8 value, nMDBG::tStatus2* statusChain = NULL);
      inline u8 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void refresh(nMDBG::tStatus2* statusChain = NULL);

      inline u8 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tTempSensorDataHi& setTempUpperByte(u8 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u8 getTempUpperByte(nMDBG::tStatus2* statusChain = NULL) const;

      inline u8 readTempUpperByte(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u8 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tTempSensorDataHi(const tTempSensorDataHi&);
      tTempSensorDataHi& operator=(const tTempSensorDataHi&);

   };

   //---------------------------------------------------------------------------
   // TempSensorDataLo
   //---------------------------------------------------------------------------
   class tTempSensorDataLo : public tReg8IODirect32
   {
   public:
      typedef tReg8IODirect32 tIOStrategy;
      typedef tSimultaneousControl tRegisterMap;

      enum {
         kOffset = 0x19,
         kId     = 18
      };
      tTempSensorDataLo();


      typedef enum {
         kRegisterId                          = 0,
         kTempLowerByteId                  = 1,
         kMaxFieldId                          = 1
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Register Accessors (Compile-time selectable)
      inline tTempSensorDataLo& setRegister(u8 value, nMDBG::tStatus2* statusChain = NULL);
      inline u8 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void refresh(nMDBG::tStatus2* statusChain = NULL);

      inline u8 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tTempSensorDataLo& setTempLowerByte(u8 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u8 getTempLowerByte(nMDBG::tStatus2* statusChain = NULL) const;

      inline u8 readTempLowerByte(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u8 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tTempSensorDataLo(const tTempSensorDataLo&);
      tTempSensorDataLo& operator=(const tTempSensorDataLo&);

   };

   //---------------------------------------------------------------------------
   // AISetChannelOrder
   //---------------------------------------------------------------------------
   tAISetChannelOrder AISetChannelOrder;

   //---------------------------------------------------------------------------
   // AIChanConfigCtrlStat
   //---------------------------------------------------------------------------
   tAIChanConfigCtrlStat AIChanConfigCtrlStat;

   //---------------------------------------------------------------------------
   // AIClearChannelOrder
   //---------------------------------------------------------------------------
   tAIClearChannelOrder AIClearChannelOrder;

   //---------------------------------------------------------------------------
   // AITriggerConfigCtrlStat
   //---------------------------------------------------------------------------
   tAITriggerConfigCtrlStat AITriggerConfigCtrlStat;

   //---------------------------------------------------------------------------
   // AcquisitionCtrl
   //---------------------------------------------------------------------------
   tAcquisitionCtrl AcquisitionCtrl;

   //---------------------------------------------------------------------------
   // AiFifoCtrlStat
   //---------------------------------------------------------------------------
   tAiFifoCtrlStat AiFifoCtrlStat;

   //---------------------------------------------------------------------------
   // LoopbackCtrlStat
   //---------------------------------------------------------------------------
   tLoopbackCtrlStat LoopbackCtrlStat;

   //---------------------------------------------------------------------------
   // LoopbackSourceSel
   //---------------------------------------------------------------------------
   tLoopbackSourceSel LoopbackSourceSel;

   //---------------------------------------------------------------------------
   // DcmCtrlStat
   //---------------------------------------------------------------------------
   tDcmCtrlStat DcmCtrlStat;

   //---------------------------------------------------------------------------
   // InterruptControl
   //---------------------------------------------------------------------------
   tInterruptControl InterruptControl;

   //---------------------------------------------------------------------------
   // InterruptStatus
   //---------------------------------------------------------------------------
   tInterruptStatus InterruptStatus;

   //---------------------------------------------------------------------------
   // SignatureYear
   //---------------------------------------------------------------------------
   tSignatureYear SignatureYear;

   //---------------------------------------------------------------------------
   // SignatureMonth
   //---------------------------------------------------------------------------
   tSignatureMonth SignatureMonth;

   //---------------------------------------------------------------------------
   // SignatureDay
   //---------------------------------------------------------------------------
   tSignatureDay SignatureDay;

   //---------------------------------------------------------------------------
   // SignatureHour
   //---------------------------------------------------------------------------
   tSignatureHour SignatureHour;

   //---------------------------------------------------------------------------
   // Scratch
   //---------------------------------------------------------------------------
   tScratch Scratch;

   //---------------------------------------------------------------------------
   // TempSensorCtrlStat
   //---------------------------------------------------------------------------
   tTempSensorCtrlStat TempSensorCtrlStat;

   //---------------------------------------------------------------------------
   // TempSensorDataHi
   //---------------------------------------------------------------------------
   tTempSensorDataHi TempSensorDataHi;

   //---------------------------------------------------------------------------
   // TempSensorDataLo
   //---------------------------------------------------------------------------
   tTempSensorDataLo TempSensorDataLo;

   //---------------------------------------------------------------------------
   // Register Groups
   //---------------------------------------------------------------------------

   //----------------------------------------
   // Register/Field Ids
   //----------------------------------------
   typedef enum {
      kAISetChannelOrderId              = 0,
      kAiChannelId                      = nNIMXRegisterMap120_mBuildFieldId(tAISetChannelOrder::kAiChannelId, kAISetChannelOrderId),

      kAIChanConfigCtrlStatId           = 1,
      kAiGainId                         = nNIMXRegisterMap120_mBuildFieldId(tAIChanConfigCtrlStat::kAiGainId, kAIChanConfigCtrlStatId),

      kAIClearChannelOrderId            = 2,
      kAiClearConfigId                  = nNIMXRegisterMap120_mBuildFieldId(tAIClearChannelOrder::kAiClearConfigId, kAIClearChannelOrderId),

      kAITriggerConfigCtrlStatId        = 3,
      kAiTrigSelId                      = nNIMXRegisterMap120_mBuildFieldId(tAITriggerConfigCtrlStat::kAiTrigSelId, kAITriggerConfigCtrlStatId),

      kAcquisitionCtrlId                = 4,
      kAcquisitionDoneId                = nNIMXRegisterMap120_mBuildFieldId(tAcquisitionCtrl::kAcquisitionDoneId, kAcquisitionCtrlId),
      kExtendedChannelsPresentId        = nNIMXRegisterMap120_mBuildFieldId(tAcquisitionCtrl::kExtendedChannelsPresentId, kAcquisitionCtrlId),

      kAiFifoCtrlStatId                 = 5,
      kSampleStrandedId                 = nNIMXRegisterMap120_mBuildFieldId(tAiFifoCtrlStat::kSampleStrandedId, kAiFifoCtrlStatId),
      kNotEmptyId                       = nNIMXRegisterMap120_mBuildFieldId(tAiFifoCtrlStat::kNotEmptyId, kAiFifoCtrlStatId),
      kSetFifoIn16BitModeId             = nNIMXRegisterMap120_mBuildFieldId(tAiFifoCtrlStat::kSetFifoIn16BitModeId, kAiFifoCtrlStatId),
      kClrFifoIn16BitModeId             = nNIMXRegisterMap120_mBuildFieldId(tAiFifoCtrlStat::kClrFifoIn16BitModeId, kAiFifoCtrlStatId),
      kResetAiFifoId                    = nNIMXRegisterMap120_mBuildFieldId(tAiFifoCtrlStat::kResetAiFifoId, kAiFifoCtrlStatId),

      kLoopbackCtrlStatId               = 6,
      kSetLoopNegId                     = nNIMXRegisterMap120_mBuildFieldId(tLoopbackCtrlStat::kSetLoopNegId, kLoopbackCtrlStatId),
      kClrLoopNegId                     = nNIMXRegisterMap120_mBuildFieldId(tLoopbackCtrlStat::kClrLoopNegId, kLoopbackCtrlStatId),
      kSetLoopPosId                     = nNIMXRegisterMap120_mBuildFieldId(tLoopbackCtrlStat::kSetLoopPosId, kLoopbackCtrlStatId),
      kClrLoopPosId                     = nNIMXRegisterMap120_mBuildFieldId(tLoopbackCtrlStat::kClrLoopPosId, kLoopbackCtrlStatId),

      kLoopbackSourceSelId              = 7,
      kLoopbackMuxSelId                 = nNIMXRegisterMap120_mBuildFieldId(tLoopbackSourceSel::kLoopbackMuxSelId, kLoopbackSourceSelId),

      kDcmCtrlStatId                    = 8,
      kSetExtDcmResetId                 = nNIMXRegisterMap120_mBuildFieldId(tDcmCtrlStat::kSetExtDcmResetId, kDcmCtrlStatId),
      kClrExtDcmResetId                 = nNIMXRegisterMap120_mBuildFieldId(tDcmCtrlStat::kClrExtDcmResetId, kDcmCtrlStatId),
      kExtDcmResetStatusId              = nNIMXRegisterMap120_mBuildFieldId(tDcmCtrlStat::kExtDcmResetStatusId, kDcmCtrlStatId),
      kExtDcmIsLockedId                 = nNIMXRegisterMap120_mBuildFieldId(tDcmCtrlStat::kExtDcmIsLockedId, kDcmCtrlStatId),
      kSetStc3DcmResetId                = nNIMXRegisterMap120_mBuildFieldId(tDcmCtrlStat::kSetStc3DcmResetId, kDcmCtrlStatId),
      kClrStc3DcmResetId                = nNIMXRegisterMap120_mBuildFieldId(tDcmCtrlStat::kClrStc3DcmResetId, kDcmCtrlStatId),
      kStc3DcmResetStatusId             = nNIMXRegisterMap120_mBuildFieldId(tDcmCtrlStat::kStc3DcmResetStatusId, kDcmCtrlStatId),
      kStc3DcmIsLockedId                = nNIMXRegisterMap120_mBuildFieldId(tDcmCtrlStat::kStc3DcmIsLockedId, kDcmCtrlStatId),

      kInterruptControlId               = 9,
      kAiFifoOverflowInterruptAckId     = nNIMXRegisterMap120_mBuildFieldId(tInterruptControl::kAiFifoOverflowInterruptAckId, kInterruptControlId),
      kAiFifoOverflowInterruptDisableId   = nNIMXRegisterMap120_mBuildFieldId(tInterruptControl::kAiFifoOverflowInterruptDisableId, kInterruptControlId),
      kAiFifoOverflowInterruptEnableId  = nNIMXRegisterMap120_mBuildFieldId(tInterruptControl::kAiFifoOverflowInterruptEnableId, kInterruptControlId),
      kGlobalInterruptDisableId         = nNIMXRegisterMap120_mBuildFieldId(tInterruptControl::kGlobalInterruptDisableId, kInterruptControlId),
      kGlobalInterruptEnableId          = nNIMXRegisterMap120_mBuildFieldId(tInterruptControl::kGlobalInterruptEnableId, kInterruptControlId),

      kInterruptStatusId                = 10,
      kAiFifoOverflowInterruptConditionId     = nNIMXRegisterMap120_mBuildFieldId(tInterruptStatus::kAiFifoOverflowInterruptConditionId, kInterruptStatusId),
      kAiFifoOverflowInterruptStatusId  = nNIMXRegisterMap120_mBuildFieldId(tInterruptStatus::kAiFifoOverflowInterruptStatusId, kInterruptStatusId),
      kAiFifoOverflowInterruptEnabledId   = nNIMXRegisterMap120_mBuildFieldId(tInterruptStatus::kAiFifoOverflowInterruptEnabledId, kInterruptStatusId),
      kGlobalInterruptConditionId       = nNIMXRegisterMap120_mBuildFieldId(tInterruptStatus::kGlobalInterruptConditionId, kInterruptStatusId),
      kGlobalInterruptStatusId          = nNIMXRegisterMap120_mBuildFieldId(tInterruptStatus::kGlobalInterruptStatusId, kInterruptStatusId),
      kGlobalInterruptEnabledId         = nNIMXRegisterMap120_mBuildFieldId(tInterruptStatus::kGlobalInterruptEnabledId, kInterruptStatusId),

      kSignatureYearId                  = 11,
      kSignatureYear_DefaultId          = nNIMXRegisterMap120_mBuildFieldId(tSignatureYear::kDefaultId, kSignatureYearId),

      kSignatureMonthId                 = 12,
      kSignatureMonth_DefaultId         = nNIMXRegisterMap120_mBuildFieldId(tSignatureMonth::kDefaultId, kSignatureMonthId),

      kSignatureDayId                   = 13,
      kSignatureDay_DefaultId           = nNIMXRegisterMap120_mBuildFieldId(tSignatureDay::kDefaultId, kSignatureDayId),

      kSignatureHourId                  = 14,
      kSignatureHour_DefaultId          = nNIMXRegisterMap120_mBuildFieldId(tSignatureHour::kDefaultId, kSignatureHourId),

      kScratchId                        = 15,
      kScratch_DefaultId                = nNIMXRegisterMap120_mBuildFieldId(tScratch::kDefaultId, kScratchId),

      kTempSensorCtrlStatId             = 16,
      kTempStartId                      = nNIMXRegisterMap120_mBuildFieldId(tTempSensorCtrlStat::kTempStartId, kTempSensorCtrlStatId),
      kTempReadyId                      = nNIMXRegisterMap120_mBuildFieldId(tTempSensorCtrlStat::kTempReadyId, kTempSensorCtrlStatId),

      kTempSensorDataHiId               = 17,
      kTempUpperByteId                  = nNIMXRegisterMap120_mBuildFieldId(tTempSensorDataHi::kTempUpperByteId, kTempSensorDataHiId),

      kTempSensorDataLoId               = 18,
      kTempLowerByteId                  = nNIMXRegisterMap120_mBuildFieldId(tTempSensorDataLo::kTempLowerByteId, kTempSensorDataLoId),


      kMaxRegisterId = 18

   } tId;

   tSimultaneousControl(tBusSpaceReference addrSpace, nMDBG::tStatus2* statusChain = NULL);
   tSimultaneousControl();
   void initialize(tBusSpaceReference addrSpace, u32 addressOffset, nMDBG::tStatus2* statusChain = NULL);
   void reset(nMDBG::tStatus2* statusChain = NULL);
   virtual ~tSimultaneousControl();

   inline tBusSpaceReference getBusSpaceReference(void) const;

   inline void setAddressOffset(u32 value, nMDBG::tStatus2* statusChain = NULL);
   inline u32  getAddressOffset(nMDBG::tStatus2* statusChain = NULL);
   inline tBoolean isDirty(tId id, nMDBG::tStatus2* statusChain = NULL);
   inline void markDirty(tId id, nMDBG::tStatus2* statusChain = NULL);
   inline void markClean(tId id, nMDBG::tStatus2* statusChain = NULL);

   inline void markDirty(nMDBG::tStatus2* statusChain = NULL);
   inline void markClean(nMDBG::tStatus2* statusChain = NULL);

private:
   void _initialize(nMDBG::tStatus2* statusChain = NULL);
   tBusSpaceReference _addrSpace;
   u32 _addressOffset;
   u8 _dirtyVector[19];

};

#ifndef ___tSimultaneousControl_ipp___
#ifndef ___tSimultaneousControl_h_no_inline___
#include "tSimultaneousControl.ipp"
#endif

#endif

#endif


// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// This file is autogenerated!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!

