// Copyright 2011 National Instruments
// License: NATIONAL INSTRUMENTS SOFTWARE LICENSE AGREEMENT
//   Refer to "MHDDK License Agreement.pdf" in the root of this distribution.

// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// This file is autogenerated!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!

#ifndef ___tSimultaneousControl_ipp___
#define ___tSimultaneousControl_ipp___

#ifndef ___tSimultaneousControl_h___
#include "tSimultaneousControl.h"
#endif

#ifndef ___nNIMXRegistermap_tStatus2Ptr_ipp___
#define ___nNIMXRegistermap_tStatus2Ptr_ipp___

typedef nMDBG::tStatus2 nNIMXRegisterMap120_tStatus2;


namespace nNIMXRegisterMap120 {
namespace {

typedef nNIMXRegisterMap120_tStatus2 tStatus2;

inline void setStatus(tStatus2* s, tStatus newStatus)
{
   if (s) s->setCode(newStatus);
}

inline tStatus* toPALStatusPtr(tStatus2* s)
{
   return s ? s->operator tStatus*() : ((tStatus*)NULL);
}

inline tBoolean statusIsFatal(tStatus2* s)
{
   return s && s->isFatal();
}

} // unnamed namespace
} // namespace nNIMXRegisterMap120

#endif // ___nNIMXRegistermap_tStatus2Ptr_ipp___


inline void tSimultaneousControl::tReg8IODirect32::write(
   tBusSpaceReference addrSpace,
   u32 offset,
   u8 value,
   nMDBG::tStatus2* s)
{
   if (s && s->isFatal()) return;
   addrSpace.write8(offset, value);
}
inline u8 tSimultaneousControl::tReg8IODirect32::read(
   tBusSpaceReference addrSpace,
   u32 offset,
   nMDBG::tStatus2* s)
{
   u8 value = (u8)~0;
   if (s && s->isFatal()) return value;
   value = (u8)addrSpace.read8(offset);
   return value;
}

inline tBusSpaceReference tSimultaneousControl::getBusSpaceReference(void) const
{
   return _addrSpace;
}

inline void tSimultaneousControl::setAddressOffset(u32 value, nMDBG::tStatus2* s)
{
   if (s && s->isFatal()) return;
   _addressOffset = value;
}
inline u32 tSimultaneousControl::getAddressOffset(nMDBG::tStatus2* s)
{
   if (s && s->isFatal()) return 0UL;
   return _addressOffset;
}
inline tBoolean tSimultaneousControl::isDirty(tId id, nMDBG::tStatus2* s)
{
   if (s && s->isFatal()) return kFalse;
   u32 regId = id&0x01FFFFFF;
   if (regId > kMaxRegisterId) {
      nNIMXRegisterMap120::setStatus(s, kStatusBadSelector);
      return kFalse;
   }

   return _dirtyVector[regId];
}

inline void tSimultaneousControl::markDirty(tId id, nMDBG::tStatus2* s)
{
   if (s && s->isFatal()) return;
   u32 regId = id&0x01FFFFFF;

   if (regId > kMaxRegisterId) {
      nNIMXRegisterMap120::setStatus(s, kStatusBadSelector);
      return;
   }

   _dirtyVector[regId] = 1;
}

inline void tSimultaneousControl::markClean(tId id, nMDBG::tStatus2* s)
{
   if (s && s->isFatal()) return;
   u32 regId = id&0x01FFFFFF;

   if (regId > kMaxRegisterId) {
      nNIMXRegisterMap120::setStatus(s, kStatusBadSelector);
      return;
   }

   _dirtyVector[regId] = 0;
}

inline void tSimultaneousControl::markDirty(nMDBG::tStatus2* s)
{
   if (s && s->isFatal()) return;
   unsigned int i;
   for (i = 0; i < sizeof(_dirtyVector)/sizeof(_dirtyVector[0]); i++) {
      _dirtyVector[i] = 1;
   }
}

inline void tSimultaneousControl::markClean(nMDBG::tStatus2* s)
{
   if (s && s->isFatal()) return;
   for (unsigned int i = 0; i < sizeof(_dirtyVector)/sizeof(_dirtyVector[0]); i++) {
      _dirtyVector[i] = 0;
   }
}

inline tSimultaneousControl::tAISetChannelOrder::tAISetChannelOrder()
{
}

inline tSimultaneousControl::tAISetChannelOrder::tRegisterMap* tSimultaneousControl::tAISetChannelOrder::registerMap(void)
{
   return _regMap;
}

inline void tSimultaneousControl::tAISetChannelOrder::setRegisterMap(tRegisterMap* pRegMap)
{
   _regMap = pRegMap;
}

inline void tSimultaneousControl::tAISetChannelOrder::writeRegister(u8 fieldValue, nMDBG::tStatus2* s)
{
   if (s && s->isFatal()) return;
   tIOStrategy::write(_regMap->getBusSpaceReference(), kOffset + _regMap->getAddressOffset(s), fieldValue, s);
}

inline void tSimultaneousControl::tAISetChannelOrder::writeAiChannel(u8 fieldValue, nMDBG::tStatus2* s)
{
   writeRegister((u8(fieldValue) << 0x0) & ~0xf0,s);
}
inline tSimultaneousControl::tAIChanConfigCtrlStat::tAIChanConfigCtrlStat()
{
}

inline tSimultaneousControl::tAIChanConfigCtrlStat::tRegisterMap* tSimultaneousControl::tAIChanConfigCtrlStat::registerMap(void)
{
   return _regMap;
}

inline void tSimultaneousControl::tAIChanConfigCtrlStat::setRegisterMap(tRegisterMap* pRegMap)
{
   _regMap = pRegMap;
}

inline void tSimultaneousControl::tAIChanConfigCtrlStat::writeRegister(u8 fieldValue, nMDBG::tStatus2* s)
{
   if (s && s->isFatal()) return;
   tIOStrategy::write(_regMap->getBusSpaceReference(), kOffset + _regMap->getAddressOffset(s), fieldValue, s);
}

inline u8 tSimultaneousControl::tAIChanConfigCtrlStat::readRegister(nMDBG::tStatus2* s)
{
   u8 fieldValue;
   fieldValue = tIOStrategy::read(_regMap->getBusSpaceReference(), kOffset + _regMap->getAddressOffset(s), s);
   return fieldValue;
}

inline void tSimultaneousControl::tAIChanConfigCtrlStat::writeAiGain(u8 fieldValue, nMDBG::tStatus2* s)
{
   writeRegister((u8(fieldValue) << 0x0) & ~0xfc,s);
}
inline u8 tSimultaneousControl::tAIChanConfigCtrlStat::readAiGain(nMDBG::tStatus2* s)
{
   u8 value = readRegister(s);
   return u8((value & ~0xfc) >> 0x0);
}

inline tSimultaneousControl::tAIClearChannelOrder::tAIClearChannelOrder()
{
}

inline tSimultaneousControl::tAIClearChannelOrder::tRegisterMap* tSimultaneousControl::tAIClearChannelOrder::registerMap(void)
{
   return _regMap;
}

inline void tSimultaneousControl::tAIClearChannelOrder::setRegisterMap(tRegisterMap* pRegMap)
{
   _regMap = pRegMap;
}

inline void tSimultaneousControl::tAIClearChannelOrder::writeRegister(u8 fieldValue, nMDBG::tStatus2* s)
{
   if (s && s->isFatal()) return;
   tIOStrategy::write(_regMap->getBusSpaceReference(), kOffset + _regMap->getAddressOffset(s), fieldValue, s);
}

inline void tSimultaneousControl::tAIClearChannelOrder::writeAiClearConfig(u8 fieldValue, nMDBG::tStatus2* s)
{
   writeRegister((u8(fieldValue) << 0x0) & ~0xfe,s);
}
inline tSimultaneousControl::tAITriggerConfigCtrlStat::tAITriggerConfigCtrlStat()
{
   _softCopy = u8(0x0);
}

inline tSimultaneousControl::tAITriggerConfigCtrlStat::tRegisterMap* tSimultaneousControl::tAITriggerConfigCtrlStat::registerMap(void)
{
   return _regMap;
}

inline void tSimultaneousControl::tAITriggerConfigCtrlStat::setRegisterMap(tRegisterMap* pRegMap)
{
   _regMap = pRegMap;
}

inline tBoolean tSimultaneousControl::tAITriggerConfigCtrlStat::isDirty(nMDBG::tStatus2* s)
{
   return _regMap->isDirty((tSimultaneousControl::tId)kId, s);
}

inline void tSimultaneousControl::tAITriggerConfigCtrlStat::markDirty(nMDBG::tStatus2* s)
{
   _regMap->markDirty((tSimultaneousControl::tId)kId, s);
}

inline void tSimultaneousControl::tAITriggerConfigCtrlStat::markClean(nMDBG::tStatus2* s)
{
   _regMap->markClean((tSimultaneousControl::tId)kId, s);
}

inline tSimultaneousControl::tAITriggerConfigCtrlStat& tSimultaneousControl::tAITriggerConfigCtrlStat::setRegister(u8 fieldValue, nMDBG::tStatus2* s)
{
   if (s && s->isFatal()) return *this;
   if (_softCopy != fieldValue) {
      _softCopy = fieldValue;
      markDirty(s);
   }
   return *this;
}

inline u8 tSimultaneousControl::tAITriggerConfigCtrlStat::getRegister(nMDBG::tStatus2*) const
{
   return _softCopy;
}

inline void tSimultaneousControl::tAITriggerConfigCtrlStat::flush(nMDBG::tStatus2* s, tBoolean force)
{
   if (s && s->isFatal()) return;
   if (force || isDirty(s)) {
      tIOStrategy::write(_regMap->getBusSpaceReference(), kOffset + _regMap->getAddressOffset(s), _softCopy, s);
      _softCopy &= u8(0xff);
      _softCopy |= u8(0x0);
      markClean(s);
   }
}

inline void tSimultaneousControl::tAITriggerConfigCtrlStat::writeRegister(u8 fieldValue, nMDBG::tStatus2* s, tBoolean force)
{
   if (s && s->isFatal()) return;
   force = force || (_softCopy != fieldValue);
   _softCopy = fieldValue;
   flush(s, force);
}

inline void tSimultaneousControl::tAITriggerConfigCtrlStat::refresh(nMDBG::tStatus2* s)
{
   _softCopy = tIOStrategy::read(_regMap->getBusSpaceReference(), kOffset + _regMap->getAddressOffset(s), s);
}

inline u8 tSimultaneousControl::tAITriggerConfigCtrlStat::readRegister(nMDBG::tStatus2* s)
{
   refresh(s);
   return _softCopy;
}

inline tSimultaneousControl::tAITriggerConfigCtrlStat& tSimultaneousControl::tAITriggerConfigCtrlStat::setAiTrigSel(u8 fieldValue, nMDBG::tStatus2* s)
{
   if (s && s->isFatal()) return *this;
   u8 newValue;   newValue = (_softCopy & 0xe0) | ((u8(fieldValue) << 0x0) & ~0xe0);
   setRegister(newValue, s);
   return *this;
}

inline u8 tSimultaneousControl::tAITriggerConfigCtrlStat::getAiTrigSel(nMDBG::tStatus2*) const
{
   return u8((_softCopy & ~0xe0) >> 0x0);
}

inline void tSimultaneousControl::tAITriggerConfigCtrlStat::writeAiTrigSel(u8 fieldValue, nMDBG::tStatus2* s, tBoolean force)
{
   setAiTrigSel(fieldValue, s);
   flush(s, force);
}
inline u8 tSimultaneousControl::tAITriggerConfigCtrlStat::readAiTrigSel(nMDBG::tStatus2* s)
{
   refresh(s);
   return getAiTrigSel(s);
}

inline tSimultaneousControl::tAcquisitionCtrl::tAcquisitionCtrl()
{
}

inline tSimultaneousControl::tAcquisitionCtrl::tRegisterMap* tSimultaneousControl::tAcquisitionCtrl::registerMap(void)
{
   return _regMap;
}

inline void tSimultaneousControl::tAcquisitionCtrl::setRegisterMap(tRegisterMap* pRegMap)
{
   _regMap = pRegMap;
}

inline void tSimultaneousControl::tAcquisitionCtrl::writeRegister(u8 fieldValue, nMDBG::tStatus2* s)
{
   if (s && s->isFatal()) return;
   tIOStrategy::write(_regMap->getBusSpaceReference(), kOffset + _regMap->getAddressOffset(s), fieldValue, s);
}

inline u8 tSimultaneousControl::tAcquisitionCtrl::readRegister(nMDBG::tStatus2* s)
{
   u8 fieldValue;
   fieldValue = tIOStrategy::read(_regMap->getBusSpaceReference(), kOffset + _regMap->getAddressOffset(s), s);
   return fieldValue;
}

inline void tSimultaneousControl::tAcquisitionCtrl::writeAcquisitionDone(tBoolean fieldValue, nMDBG::tStatus2* s)
{
   writeRegister((u8(fieldValue) << 0x0) & ~0xfe,s);
}
inline tBoolean tSimultaneousControl::tAcquisitionCtrl::readAcquisitionDone(nMDBG::tStatus2* s)
{
   u8 value = readRegister(s);
   return tBoolean((value & ~0xfe) >> 0x0);
}

inline void tSimultaneousControl::tAcquisitionCtrl::writeExtendedChannelsPresent(tBoolean fieldValue, nMDBG::tStatus2* s)
{
   writeRegister((u8(fieldValue) << 0x1) & ~0xfd,s);
}
inline tBoolean tSimultaneousControl::tAcquisitionCtrl::readExtendedChannelsPresent(nMDBG::tStatus2* s)
{
   u8 value = readRegister(s);
   return tBoolean((value & ~0xfd) >> 0x1);
}

inline tSimultaneousControl::tAiFifoCtrlStat::tAiFifoCtrlStat()
{
}

inline tSimultaneousControl::tAiFifoCtrlStat::tRegisterMap* tSimultaneousControl::tAiFifoCtrlStat::registerMap(void)
{
   return _regMap;
}

inline void tSimultaneousControl::tAiFifoCtrlStat::setRegisterMap(tRegisterMap* pRegMap)
{
   _regMap = pRegMap;
}

inline void tSimultaneousControl::tAiFifoCtrlStat::writeRegister(u8 fieldValue, nMDBG::tStatus2* s)
{
   if (s && s->isFatal()) return;
   tIOStrategy::write(_regMap->getBusSpaceReference(), kOffset + _regMap->getAddressOffset(s), fieldValue, s);
}

inline u8 tSimultaneousControl::tAiFifoCtrlStat::readRegister(nMDBG::tStatus2* s)
{
   u8 fieldValue;
   fieldValue = tIOStrategy::read(_regMap->getBusSpaceReference(), kOffset + _regMap->getAddressOffset(s), s);
   return fieldValue;
}

inline void tSimultaneousControl::tAiFifoCtrlStat::writeSampleStranded(tBoolean fieldValue, nMDBG::tStatus2* s)
{
   writeRegister((u8(fieldValue) << 0x0) & ~0xfe,s);
}
inline tBoolean tSimultaneousControl::tAiFifoCtrlStat::readSampleStranded(nMDBG::tStatus2* s)
{
   u8 value = readRegister(s);
   return tBoolean((value & ~0xfe) >> 0x0);
}

inline void tSimultaneousControl::tAiFifoCtrlStat::writeNotEmpty(tBoolean fieldValue, nMDBG::tStatus2* s)
{
   writeRegister((u8(fieldValue) << 0x1) & ~0xfd,s);
}
inline tBoolean tSimultaneousControl::tAiFifoCtrlStat::readNotEmpty(nMDBG::tStatus2* s)
{
   u8 value = readRegister(s);
   return tBoolean((value & ~0xfd) >> 0x1);
}

inline void tSimultaneousControl::tAiFifoCtrlStat::writeSetFifoIn16BitMode(tBoolean fieldValue, nMDBG::tStatus2* s)
{
   writeRegister((u8(fieldValue) << 0x2) & ~0xfb,s);
}
inline tBoolean tSimultaneousControl::tAiFifoCtrlStat::readSetFifoIn16BitMode(nMDBG::tStatus2* s)
{
   u8 value = readRegister(s);
   return tBoolean((value & ~0xfb) >> 0x2);
}

inline void tSimultaneousControl::tAiFifoCtrlStat::writeClrFifoIn16BitMode(tBoolean fieldValue, nMDBG::tStatus2* s)
{
   writeRegister((u8(fieldValue) << 0x3) & ~0xf7,s);
}
inline tBoolean tSimultaneousControl::tAiFifoCtrlStat::readClrFifoIn16BitMode(nMDBG::tStatus2* s)
{
   u8 value = readRegister(s);
   return tBoolean((value & ~0xf7) >> 0x3);
}

inline void tSimultaneousControl::tAiFifoCtrlStat::writeResetAiFifo(tBoolean fieldValue, nMDBG::tStatus2* s)
{
   writeRegister((u8(fieldValue) << 0x7) & ~0x7f,s);
}
inline tBoolean tSimultaneousControl::tAiFifoCtrlStat::readResetAiFifo(nMDBG::tStatus2* s)
{
   u8 value = readRegister(s);
   return tBoolean((value & ~0x7f) >> 0x7);
}

inline tSimultaneousControl::tLoopbackCtrlStat::tLoopbackCtrlStat()
{
}

inline tSimultaneousControl::tLoopbackCtrlStat::tRegisterMap* tSimultaneousControl::tLoopbackCtrlStat::registerMap(void)
{
   return _regMap;
}

inline void tSimultaneousControl::tLoopbackCtrlStat::setRegisterMap(tRegisterMap* pRegMap)
{
   _regMap = pRegMap;
}

inline void tSimultaneousControl::tLoopbackCtrlStat::writeRegister(u8 fieldValue, nMDBG::tStatus2* s)
{
   if (s && s->isFatal()) return;
   tIOStrategy::write(_regMap->getBusSpaceReference(), kOffset + _regMap->getAddressOffset(s), fieldValue, s);
}

inline u8 tSimultaneousControl::tLoopbackCtrlStat::readRegister(nMDBG::tStatus2* s)
{
   u8 fieldValue;
   fieldValue = tIOStrategy::read(_regMap->getBusSpaceReference(), kOffset + _regMap->getAddressOffset(s), s);
   return fieldValue;
}

inline void tSimultaneousControl::tLoopbackCtrlStat::writeSetLoopNeg(tBoolean fieldValue, nMDBG::tStatus2* s)
{
   writeRegister((u8(fieldValue) << 0x0) & ~0xfe,s);
}
inline tBoolean tSimultaneousControl::tLoopbackCtrlStat::readSetLoopNeg(nMDBG::tStatus2* s)
{
   u8 value = readRegister(s);
   return tBoolean((value & ~0xfe) >> 0x0);
}

inline void tSimultaneousControl::tLoopbackCtrlStat::writeClrLoopNeg(tBoolean fieldValue, nMDBG::tStatus2* s)
{
   writeRegister((u8(fieldValue) << 0x1) & ~0xfd,s);
}
inline tBoolean tSimultaneousControl::tLoopbackCtrlStat::readClrLoopNeg(nMDBG::tStatus2* s)
{
   u8 value = readRegister(s);
   return tBoolean((value & ~0xfd) >> 0x1);
}

inline void tSimultaneousControl::tLoopbackCtrlStat::writeSetLoopPos(tBoolean fieldValue, nMDBG::tStatus2* s)
{
   writeRegister((u8(fieldValue) << 0x2) & ~0xfb,s);
}
inline tBoolean tSimultaneousControl::tLoopbackCtrlStat::readSetLoopPos(nMDBG::tStatus2* s)
{
   u8 value = readRegister(s);
   return tBoolean((value & ~0xfb) >> 0x2);
}

inline void tSimultaneousControl::tLoopbackCtrlStat::writeClrLoopPos(tBoolean fieldValue, nMDBG::tStatus2* s)
{
   writeRegister((u8(fieldValue) << 0x3) & ~0xf7,s);
}
inline tBoolean tSimultaneousControl::tLoopbackCtrlStat::readClrLoopPos(nMDBG::tStatus2* s)
{
   u8 value = readRegister(s);
   return tBoolean((value & ~0xf7) >> 0x3);
}

inline tSimultaneousControl::tLoopbackSourceSel::tLoopbackSourceSel()
{
   _softCopy = u8(0x0);
}

inline tSimultaneousControl::tLoopbackSourceSel::tRegisterMap* tSimultaneousControl::tLoopbackSourceSel::registerMap(void)
{
   return _regMap;
}

inline void tSimultaneousControl::tLoopbackSourceSel::setRegisterMap(tRegisterMap* pRegMap)
{
   _regMap = pRegMap;
}

inline tBoolean tSimultaneousControl::tLoopbackSourceSel::isDirty(nMDBG::tStatus2* s)
{
   return _regMap->isDirty((tSimultaneousControl::tId)kId, s);
}

inline void tSimultaneousControl::tLoopbackSourceSel::markDirty(nMDBG::tStatus2* s)
{
   _regMap->markDirty((tSimultaneousControl::tId)kId, s);
}

inline void tSimultaneousControl::tLoopbackSourceSel::markClean(nMDBG::tStatus2* s)
{
   _regMap->markClean((tSimultaneousControl::tId)kId, s);
}

inline tSimultaneousControl::tLoopbackSourceSel& tSimultaneousControl::tLoopbackSourceSel::setRegister(u8 fieldValue, nMDBG::tStatus2* s)
{
   if (s && s->isFatal()) return *this;
   if (_softCopy != fieldValue) {
      _softCopy = fieldValue;
      markDirty(s);
   }
   return *this;
}

inline u8 tSimultaneousControl::tLoopbackSourceSel::getRegister(nMDBG::tStatus2*) const
{
   return _softCopy;
}

inline void tSimultaneousControl::tLoopbackSourceSel::flush(nMDBG::tStatus2* s, tBoolean force)
{
   if (s && s->isFatal()) return;
   if (force || isDirty(s)) {
      tIOStrategy::write(_regMap->getBusSpaceReference(), kOffset + _regMap->getAddressOffset(s), _softCopy, s);
      _softCopy &= u8(0xff);
      _softCopy |= u8(0x0);
      markClean(s);
   }
}

inline void tSimultaneousControl::tLoopbackSourceSel::writeRegister(u8 fieldValue, nMDBG::tStatus2* s, tBoolean force)
{
   if (s && s->isFatal()) return;
   force = force || (_softCopy != fieldValue);
   _softCopy = fieldValue;
   flush(s, force);
}

inline void tSimultaneousControl::tLoopbackSourceSel::refresh(nMDBG::tStatus2* s)
{
   _softCopy = tIOStrategy::read(_regMap->getBusSpaceReference(), kOffset + _regMap->getAddressOffset(s), s);
}

inline u8 tSimultaneousControl::tLoopbackSourceSel::readRegister(nMDBG::tStatus2* s)
{
   refresh(s);
   return _softCopy;
}

inline tSimultaneousControl::tLoopbackSourceSel& tSimultaneousControl::tLoopbackSourceSel::setLoopbackMuxSel(u8 fieldValue, nMDBG::tStatus2* s)
{
   if (s && s->isFatal()) return *this;
   u8 newValue;   newValue = (_softCopy & 0xe0) | ((u8(fieldValue) << 0x0) & ~0xe0);
   setRegister(newValue, s);
   return *this;
}

inline u8 tSimultaneousControl::tLoopbackSourceSel::getLoopbackMuxSel(nMDBG::tStatus2*) const
{
   return u8((_softCopy & ~0xe0) >> 0x0);
}

inline void tSimultaneousControl::tLoopbackSourceSel::writeLoopbackMuxSel(u8 fieldValue, nMDBG::tStatus2* s, tBoolean force)
{
   setLoopbackMuxSel(fieldValue, s);
   flush(s, force);
}
inline u8 tSimultaneousControl::tLoopbackSourceSel::readLoopbackMuxSel(nMDBG::tStatus2* s)
{
   refresh(s);
   return getLoopbackMuxSel(s);
}

inline tSimultaneousControl::tDcmCtrlStat::tDcmCtrlStat()
{
}

inline tSimultaneousControl::tDcmCtrlStat::tRegisterMap* tSimultaneousControl::tDcmCtrlStat::registerMap(void)
{
   return _regMap;
}

inline void tSimultaneousControl::tDcmCtrlStat::setRegisterMap(tRegisterMap* pRegMap)
{
   _regMap = pRegMap;
}

inline void tSimultaneousControl::tDcmCtrlStat::writeRegister(u8 fieldValue, nMDBG::tStatus2* s)
{
   if (s && s->isFatal()) return;
   tIOStrategy::write(_regMap->getBusSpaceReference(), kOffset + _regMap->getAddressOffset(s), fieldValue, s);
}

inline u8 tSimultaneousControl::tDcmCtrlStat::readRegister(nMDBG::tStatus2* s)
{
   u8 fieldValue;
   fieldValue = tIOStrategy::read(_regMap->getBusSpaceReference(), kOffset + _regMap->getAddressOffset(s), s);
   return fieldValue;
}

inline void tSimultaneousControl::tDcmCtrlStat::writeSetExtDcmReset(tBoolean fieldValue, nMDBG::tStatus2* s)
{
   writeRegister((u8(fieldValue) << 0x0) & ~0xfe,s);
}
inline tBoolean tSimultaneousControl::tDcmCtrlStat::readSetExtDcmReset(nMDBG::tStatus2* s)
{
   u8 value = readRegister(s);
   return tBoolean((value & ~0xfe) >> 0x0);
}

inline void tSimultaneousControl::tDcmCtrlStat::writeClrExtDcmReset(tBoolean fieldValue, nMDBG::tStatus2* s)
{
   writeRegister((u8(fieldValue) << 0x1) & ~0xfd,s);
}
inline tBoolean tSimultaneousControl::tDcmCtrlStat::readClrExtDcmReset(nMDBG::tStatus2* s)
{
   u8 value = readRegister(s);
   return tBoolean((value & ~0xfd) >> 0x1);
}

inline void tSimultaneousControl::tDcmCtrlStat::writeExtDcmResetStatus(tBoolean fieldValue, nMDBG::tStatus2* s)
{
   writeRegister((u8(fieldValue) << 0x2) & ~0xfb,s);
}
inline tBoolean tSimultaneousControl::tDcmCtrlStat::readExtDcmResetStatus(nMDBG::tStatus2* s)
{
   u8 value = readRegister(s);
   return tBoolean((value & ~0xfb) >> 0x2);
}

inline void tSimultaneousControl::tDcmCtrlStat::writeExtDcmIsLocked(tBoolean fieldValue, nMDBG::tStatus2* s)
{
   writeRegister((u8(fieldValue) << 0x3) & ~0xf7,s);
}
inline tBoolean tSimultaneousControl::tDcmCtrlStat::readExtDcmIsLocked(nMDBG::tStatus2* s)
{
   u8 value = readRegister(s);
   return tBoolean((value & ~0xf7) >> 0x3);
}

inline void tSimultaneousControl::tDcmCtrlStat::writeSetStc3DcmReset(tBoolean fieldValue, nMDBG::tStatus2* s)
{
   writeRegister((u8(fieldValue) << 0x4) & ~0xef,s);
}
inline tBoolean tSimultaneousControl::tDcmCtrlStat::readSetStc3DcmReset(nMDBG::tStatus2* s)
{
   u8 value = readRegister(s);
   return tBoolean((value & ~0xef) >> 0x4);
}

inline void tSimultaneousControl::tDcmCtrlStat::writeClrStc3DcmReset(tBoolean fieldValue, nMDBG::tStatus2* s)
{
   writeRegister((u8(fieldValue) << 0x5) & ~0xdf,s);
}
inline tBoolean tSimultaneousControl::tDcmCtrlStat::readClrStc3DcmReset(nMDBG::tStatus2* s)
{
   u8 value = readRegister(s);
   return tBoolean((value & ~0xdf) >> 0x5);
}

inline void tSimultaneousControl::tDcmCtrlStat::writeStc3DcmResetStatus(tBoolean fieldValue, nMDBG::tStatus2* s)
{
   writeRegister((u8(fieldValue) << 0x6) & ~0xbf,s);
}
inline tBoolean tSimultaneousControl::tDcmCtrlStat::readStc3DcmResetStatus(nMDBG::tStatus2* s)
{
   u8 value = readRegister(s);
   return tBoolean((value & ~0xbf) >> 0x6);
}

inline void tSimultaneousControl::tDcmCtrlStat::writeStc3DcmIsLocked(tBoolean fieldValue, nMDBG::tStatus2* s)
{
   writeRegister((u8(fieldValue) << 0x7) & ~0x7f,s);
}
inline tBoolean tSimultaneousControl::tDcmCtrlStat::readStc3DcmIsLocked(nMDBG::tStatus2* s)
{
   u8 value = readRegister(s);
   return tBoolean((value & ~0x7f) >> 0x7);
}

inline tSimultaneousControl::tInterruptControl::tInterruptControl()
{
}

inline tSimultaneousControl::tInterruptControl::tRegisterMap* tSimultaneousControl::tInterruptControl::registerMap(void)
{
   return _regMap;
}

inline void tSimultaneousControl::tInterruptControl::setRegisterMap(tRegisterMap* pRegMap)
{
   _regMap = pRegMap;
}

inline void tSimultaneousControl::tInterruptControl::writeRegister(u8 fieldValue, nMDBG::tStatus2* s)
{
   if (s && s->isFatal()) return;
   tIOStrategy::write(_regMap->getBusSpaceReference(), kOffset + _regMap->getAddressOffset(s), fieldValue, s);
}

inline void tSimultaneousControl::tInterruptControl::writeAiFifoOverflowInterruptAck(u8 fieldValue, nMDBG::tStatus2* s)
{
   writeRegister((u8(fieldValue) << 0x2) & ~0xfb,s);
}
inline void tSimultaneousControl::tInterruptControl::writeAiFifoOverflowInterruptDisable(u8 fieldValue, nMDBG::tStatus2* s)
{
   writeRegister((u8(fieldValue) << 0x3) & ~0xf7,s);
}
inline void tSimultaneousControl::tInterruptControl::writeAiFifoOverflowInterruptEnable(u8 fieldValue, nMDBG::tStatus2* s)
{
   writeRegister((u8(fieldValue) << 0x4) & ~0xef,s);
}
inline void tSimultaneousControl::tInterruptControl::writeGlobalInterruptDisable(u8 fieldValue, nMDBG::tStatus2* s)
{
   writeRegister((u8(fieldValue) << 0x6) & ~0xbf,s);
}
inline void tSimultaneousControl::tInterruptControl::writeGlobalInterruptEnable(u8 fieldValue, nMDBG::tStatus2* s)
{
   writeRegister((u8(fieldValue) << 0x7) & ~0x7f,s);
}
inline tSimultaneousControl::tInterruptStatus::tInterruptStatus()
{
}

inline tSimultaneousControl::tInterruptStatus::tRegisterMap* tSimultaneousControl::tInterruptStatus::registerMap(void)
{
   return _regMap;
}

inline void tSimultaneousControl::tInterruptStatus::setRegisterMap(tRegisterMap* pRegMap)
{
   _regMap = pRegMap;
}

inline u8 tSimultaneousControl::tInterruptStatus::readRegister(nMDBG::tStatus2* s)
{
   u8 fieldValue;
   fieldValue = tIOStrategy::read(_regMap->getBusSpaceReference(), kOffset + _regMap->getAddressOffset(s), s);
   return fieldValue;
}

inline tBoolean tSimultaneousControl::tInterruptStatus::readAiFifoOverflowInterruptCondition(nMDBG::tStatus2* s)
{
   u8 value = readRegister(s);
   return tBoolean((value & ~0xfe) >> 0x0);
}

inline tBoolean tSimultaneousControl::tInterruptStatus::readAiFifoOverflowInterruptStatus(nMDBG::tStatus2* s)
{
   u8 value = readRegister(s);
   return tBoolean((value & ~0xfd) >> 0x1);
}

inline tBoolean tSimultaneousControl::tInterruptStatus::readAiFifoOverflowInterruptEnabled(nMDBG::tStatus2* s)
{
   u8 value = readRegister(s);
   return tBoolean((value & ~0xef) >> 0x4);
}

inline tBoolean tSimultaneousControl::tInterruptStatus::readGlobalInterruptCondition(nMDBG::tStatus2* s)
{
   u8 value = readRegister(s);
   return tBoolean((value & ~0xdf) >> 0x5);
}

inline tBoolean tSimultaneousControl::tInterruptStatus::readGlobalInterruptStatus(nMDBG::tStatus2* s)
{
   u8 value = readRegister(s);
   return tBoolean((value & ~0xbf) >> 0x6);
}

inline tBoolean tSimultaneousControl::tInterruptStatus::readGlobalInterruptEnabled(nMDBG::tStatus2* s)
{
   u8 value = readRegister(s);
   return tBoolean((value & ~0x7f) >> 0x7);
}

inline tSimultaneousControl::tSignatureYear::tSignatureYear()
{
   _softCopy = u8(0x0);
}

inline tSimultaneousControl::tSignatureYear::tRegisterMap* tSimultaneousControl::tSignatureYear::registerMap(void)
{
   return _regMap;
}

inline void tSimultaneousControl::tSignatureYear::setRegisterMap(tRegisterMap* pRegMap)
{
   _regMap = pRegMap;
}

inline tSimultaneousControl::tSignatureYear& tSimultaneousControl::tSignatureYear::setRegister(u8 fieldValue, nMDBG::tStatus2* s)
{
   if (s && s->isFatal()) return *this;
   _softCopy = fieldValue;
   return *this;
}

inline u8 tSimultaneousControl::tSignatureYear::getRegister(nMDBG::tStatus2*) const
{
   return _softCopy;
}

inline void tSimultaneousControl::tSignatureYear::refresh(nMDBG::tStatus2* s)
{
   _softCopy = tIOStrategy::read(_regMap->getBusSpaceReference(), kOffset + _regMap->getAddressOffset(s), s);
}

inline u8 tSimultaneousControl::tSignatureYear::readRegister(nMDBG::tStatus2* s)
{
   refresh(s);
   return _softCopy;
}

inline tSimultaneousControl::tSignatureYear& tSimultaneousControl::tSignatureYear::set(u8 fieldValue, nMDBG::tStatus2* s)
{
   if (s && s->isFatal()) return *this;
   u8 newValue;   newValue = (_softCopy & 0x0) | ((u8(fieldValue) << 0x0) & ~0x0);
   setRegister(newValue, s);
   return *this;
}

inline u8 tSimultaneousControl::tSignatureYear::get(nMDBG::tStatus2*) const
{
   return u8((_softCopy & ~0x0) >> 0x0);
}

inline u8 tSimultaneousControl::tSignatureYear::read(nMDBG::tStatus2* s)
{
   refresh(s);
   return get(s);
}

inline tSimultaneousControl::tSignatureMonth::tSignatureMonth()
{
   _softCopy = u8(0x0);
}

inline tSimultaneousControl::tSignatureMonth::tRegisterMap* tSimultaneousControl::tSignatureMonth::registerMap(void)
{
   return _regMap;
}

inline void tSimultaneousControl::tSignatureMonth::setRegisterMap(tRegisterMap* pRegMap)
{
   _regMap = pRegMap;
}

inline tSimultaneousControl::tSignatureMonth& tSimultaneousControl::tSignatureMonth::setRegister(u8 fieldValue, nMDBG::tStatus2* s)
{
   if (s && s->isFatal()) return *this;
   _softCopy = fieldValue;
   return *this;
}

inline u8 tSimultaneousControl::tSignatureMonth::getRegister(nMDBG::tStatus2*) const
{
   return _softCopy;
}

inline void tSimultaneousControl::tSignatureMonth::refresh(nMDBG::tStatus2* s)
{
   _softCopy = tIOStrategy::read(_regMap->getBusSpaceReference(), kOffset + _regMap->getAddressOffset(s), s);
}

inline u8 tSimultaneousControl::tSignatureMonth::readRegister(nMDBG::tStatus2* s)
{
   refresh(s);
   return _softCopy;
}

inline tSimultaneousControl::tSignatureMonth& tSimultaneousControl::tSignatureMonth::set(u8 fieldValue, nMDBG::tStatus2* s)
{
   if (s && s->isFatal()) return *this;
   u8 newValue;   newValue = (_softCopy & 0x0) | ((u8(fieldValue) << 0x0) & ~0x0);
   setRegister(newValue, s);
   return *this;
}

inline u8 tSimultaneousControl::tSignatureMonth::get(nMDBG::tStatus2*) const
{
   return u8((_softCopy & ~0x0) >> 0x0);
}

inline u8 tSimultaneousControl::tSignatureMonth::read(nMDBG::tStatus2* s)
{
   refresh(s);
   return get(s);
}

inline tSimultaneousControl::tSignatureDay::tSignatureDay()
{
   _softCopy = u8(0x0);
}

inline tSimultaneousControl::tSignatureDay::tRegisterMap* tSimultaneousControl::tSignatureDay::registerMap(void)
{
   return _regMap;
}

inline void tSimultaneousControl::tSignatureDay::setRegisterMap(tRegisterMap* pRegMap)
{
   _regMap = pRegMap;
}

inline tSimultaneousControl::tSignatureDay& tSimultaneousControl::tSignatureDay::setRegister(u8 fieldValue, nMDBG::tStatus2* s)
{
   if (s && s->isFatal()) return *this;
   _softCopy = fieldValue;
   return *this;
}

inline u8 tSimultaneousControl::tSignatureDay::getRegister(nMDBG::tStatus2*) const
{
   return _softCopy;
}

inline void tSimultaneousControl::tSignatureDay::refresh(nMDBG::tStatus2* s)
{
   _softCopy = tIOStrategy::read(_regMap->getBusSpaceReference(), kOffset + _regMap->getAddressOffset(s), s);
}

inline u8 tSimultaneousControl::tSignatureDay::readRegister(nMDBG::tStatus2* s)
{
   refresh(s);
   return _softCopy;
}

inline tSimultaneousControl::tSignatureDay& tSimultaneousControl::tSignatureDay::set(u8 fieldValue, nMDBG::tStatus2* s)
{
   if (s && s->isFatal()) return *this;
   u8 newValue;   newValue = (_softCopy & 0x0) | ((u8(fieldValue) << 0x0) & ~0x0);
   setRegister(newValue, s);
   return *this;
}

inline u8 tSimultaneousControl::tSignatureDay::get(nMDBG::tStatus2*) const
{
   return u8((_softCopy & ~0x0) >> 0x0);
}

inline u8 tSimultaneousControl::tSignatureDay::read(nMDBG::tStatus2* s)
{
   refresh(s);
   return get(s);
}

inline tSimultaneousControl::tSignatureHour::tSignatureHour()
{
   _softCopy = u8(0x0);
}

inline tSimultaneousControl::tSignatureHour::tRegisterMap* tSimultaneousControl::tSignatureHour::registerMap(void)
{
   return _regMap;
}

inline void tSimultaneousControl::tSignatureHour::setRegisterMap(tRegisterMap* pRegMap)
{
   _regMap = pRegMap;
}

inline tSimultaneousControl::tSignatureHour& tSimultaneousControl::tSignatureHour::setRegister(u8 fieldValue, nMDBG::tStatus2* s)
{
   if (s && s->isFatal()) return *this;
   _softCopy = fieldValue;
   return *this;
}

inline u8 tSimultaneousControl::tSignatureHour::getRegister(nMDBG::tStatus2*) const
{
   return _softCopy;
}

inline void tSimultaneousControl::tSignatureHour::refresh(nMDBG::tStatus2* s)
{
   _softCopy = tIOStrategy::read(_regMap->getBusSpaceReference(), kOffset + _regMap->getAddressOffset(s), s);
}

inline u8 tSimultaneousControl::tSignatureHour::readRegister(nMDBG::tStatus2* s)
{
   refresh(s);
   return _softCopy;
}

inline tSimultaneousControl::tSignatureHour& tSimultaneousControl::tSignatureHour::set(u8 fieldValue, nMDBG::tStatus2* s)
{
   if (s && s->isFatal()) return *this;
   u8 newValue;   newValue = (_softCopy & 0x0) | ((u8(fieldValue) << 0x0) & ~0x0);
   setRegister(newValue, s);
   return *this;
}

inline u8 tSimultaneousControl::tSignatureHour::get(nMDBG::tStatus2*) const
{
   return u8((_softCopy & ~0x0) >> 0x0);
}

inline u8 tSimultaneousControl::tSignatureHour::read(nMDBG::tStatus2* s)
{
   refresh(s);
   return get(s);
}

inline tSimultaneousControl::tScratch::tScratch()
{
   _softCopy = u8(0x0);
}

inline tSimultaneousControl::tScratch::tRegisterMap* tSimultaneousControl::tScratch::registerMap(void)
{
   return _regMap;
}

inline void tSimultaneousControl::tScratch::setRegisterMap(tRegisterMap* pRegMap)
{
   _regMap = pRegMap;
}

inline tBoolean tSimultaneousControl::tScratch::isDirty(nMDBG::tStatus2* s)
{
   return _regMap->isDirty((tSimultaneousControl::tId)kId, s);
}

inline void tSimultaneousControl::tScratch::markDirty(nMDBG::tStatus2* s)
{
   _regMap->markDirty((tSimultaneousControl::tId)kId, s);
}

inline void tSimultaneousControl::tScratch::markClean(nMDBG::tStatus2* s)
{
   _regMap->markClean((tSimultaneousControl::tId)kId, s);
}

inline tSimultaneousControl::tScratch& tSimultaneousControl::tScratch::setRegister(u8 fieldValue, nMDBG::tStatus2* s)
{
   if (s && s->isFatal()) return *this;
   if (_softCopy != fieldValue) {
      _softCopy = fieldValue;
      markDirty(s);
   }
   return *this;
}

inline u8 tSimultaneousControl::tScratch::getRegister(nMDBG::tStatus2*) const
{
   return _softCopy;
}

inline void tSimultaneousControl::tScratch::flush(nMDBG::tStatus2* s, tBoolean force)
{
   if (s && s->isFatal()) return;
   if (force || isDirty(s)) {
      tIOStrategy::write(_regMap->getBusSpaceReference(), kOffset + _regMap->getAddressOffset(s), _softCopy, s);
      _softCopy &= u8(0xff);
      _softCopy |= u8(0x0);
      markClean(s);
   }
}

inline void tSimultaneousControl::tScratch::writeRegister(u8 fieldValue, nMDBG::tStatus2* s, tBoolean force)
{
   if (s && s->isFatal()) return;
   force = force || (_softCopy != fieldValue);
   _softCopy = fieldValue;
   flush(s, force);
}

inline void tSimultaneousControl::tScratch::refresh(nMDBG::tStatus2* s)
{
   _softCopy = tIOStrategy::read(_regMap->getBusSpaceReference(), kOffset + _regMap->getAddressOffset(s), s);
}

inline u8 tSimultaneousControl::tScratch::readRegister(nMDBG::tStatus2* s)
{
   refresh(s);
   return _softCopy;
}

inline tSimultaneousControl::tScratch& tSimultaneousControl::tScratch::set(u8 fieldValue, nMDBG::tStatus2* s)
{
   if (s && s->isFatal()) return *this;
   u8 newValue;   newValue = (_softCopy & 0x0) | ((u8(fieldValue) << 0x0) & ~0x0);
   setRegister(newValue, s);
   return *this;
}

inline u8 tSimultaneousControl::tScratch::get(nMDBG::tStatus2*) const
{
   return u8((_softCopy & ~0x0) >> 0x0);
}

inline void tSimultaneousControl::tScratch::write(u8 fieldValue, nMDBG::tStatus2* s, tBoolean force)
{
   set(fieldValue, s);
   flush(s, force);
}
inline u8 tSimultaneousControl::tScratch::read(nMDBG::tStatus2* s)
{
   refresh(s);
   return get(s);
}

inline tSimultaneousControl::tTempSensorCtrlStat::tTempSensorCtrlStat()
{
}

inline tSimultaneousControl::tTempSensorCtrlStat::tRegisterMap* tSimultaneousControl::tTempSensorCtrlStat::registerMap(void)
{
   return _regMap;
}

inline void tSimultaneousControl::tTempSensorCtrlStat::setRegisterMap(tRegisterMap* pRegMap)
{
   _regMap = pRegMap;
}

inline void tSimultaneousControl::tTempSensorCtrlStat::writeRegister(u8 fieldValue, nMDBG::tStatus2* s)
{
   if (s && s->isFatal()) return;
   tIOStrategy::write(_regMap->getBusSpaceReference(), kOffset + _regMap->getAddressOffset(s), fieldValue, s);
}

inline u8 tSimultaneousControl::tTempSensorCtrlStat::readRegister(nMDBG::tStatus2* s)
{
   u8 fieldValue;
   fieldValue = tIOStrategy::read(_regMap->getBusSpaceReference(), kOffset + _regMap->getAddressOffset(s), s);
   return fieldValue;
}

inline void tSimultaneousControl::tTempSensorCtrlStat::writeTempStart(u8 fieldValue, nMDBG::tStatus2* s)
{
   writeRegister((u8(fieldValue) << 0x0) & ~0xfe,s);
}
inline u8 tSimultaneousControl::tTempSensorCtrlStat::readTempStart(nMDBG::tStatus2* s)
{
   u8 value = readRegister(s);
   return u8((value & ~0xfe) >> 0x0);
}

inline void tSimultaneousControl::tTempSensorCtrlStat::writeTempReady(u8 fieldValue, nMDBG::tStatus2* s)
{
   writeRegister((u8(fieldValue) << 0x1) & ~0xfd,s);
}
inline u8 tSimultaneousControl::tTempSensorCtrlStat::readTempReady(nMDBG::tStatus2* s)
{
   u8 value = readRegister(s);
   return u8((value & ~0xfd) >> 0x1);
}

inline tSimultaneousControl::tTempSensorDataHi::tTempSensorDataHi()
{
   _softCopy = u8(0x0);
}

inline tSimultaneousControl::tTempSensorDataHi::tRegisterMap* tSimultaneousControl::tTempSensorDataHi::registerMap(void)
{
   return _regMap;
}

inline void tSimultaneousControl::tTempSensorDataHi::setRegisterMap(tRegisterMap* pRegMap)
{
   _regMap = pRegMap;
}

inline tSimultaneousControl::tTempSensorDataHi& tSimultaneousControl::tTempSensorDataHi::setRegister(u8 fieldValue, nMDBG::tStatus2* s)
{
   if (s && s->isFatal()) return *this;
   _softCopy = fieldValue;
   return *this;
}

inline u8 tSimultaneousControl::tTempSensorDataHi::getRegister(nMDBG::tStatus2*) const
{
   return _softCopy;
}

inline void tSimultaneousControl::tTempSensorDataHi::refresh(nMDBG::tStatus2* s)
{
   _softCopy = tIOStrategy::read(_regMap->getBusSpaceReference(), kOffset + _regMap->getAddressOffset(s), s);
}

inline u8 tSimultaneousControl::tTempSensorDataHi::readRegister(nMDBG::tStatus2* s)
{
   refresh(s);
   return _softCopy;
}

inline tSimultaneousControl::tTempSensorDataHi& tSimultaneousControl::tTempSensorDataHi::setTempUpperByte(u8 fieldValue, nMDBG::tStatus2* s)
{
   if (s && s->isFatal()) return *this;
   u8 newValue;   newValue = (_softCopy & 0x0) | ((u8(fieldValue) << 0x0) & ~0x0);
   setRegister(newValue, s);
   return *this;
}

inline u8 tSimultaneousControl::tTempSensorDataHi::getTempUpperByte(nMDBG::tStatus2*) const
{
   return u8((_softCopy & ~0x0) >> 0x0);
}

inline u8 tSimultaneousControl::tTempSensorDataHi::readTempUpperByte(nMDBG::tStatus2* s)
{
   refresh(s);
   return getTempUpperByte(s);
}

inline tSimultaneousControl::tTempSensorDataLo::tTempSensorDataLo()
{
   _softCopy = u8(0x0);
}

inline tSimultaneousControl::tTempSensorDataLo::tRegisterMap* tSimultaneousControl::tTempSensorDataLo::registerMap(void)
{
   return _regMap;
}

inline void tSimultaneousControl::tTempSensorDataLo::setRegisterMap(tRegisterMap* pRegMap)
{
   _regMap = pRegMap;
}

inline tSimultaneousControl::tTempSensorDataLo& tSimultaneousControl::tTempSensorDataLo::setRegister(u8 fieldValue, nMDBG::tStatus2* s)
{
   if (s && s->isFatal()) return *this;
   _softCopy = fieldValue;
   return *this;
}

inline u8 tSimultaneousControl::tTempSensorDataLo::getRegister(nMDBG::tStatus2*) const
{
   return _softCopy;
}

inline void tSimultaneousControl::tTempSensorDataLo::refresh(nMDBG::tStatus2* s)
{
   _softCopy = tIOStrategy::read(_regMap->getBusSpaceReference(), kOffset + _regMap->getAddressOffset(s), s);
}

inline u8 tSimultaneousControl::tTempSensorDataLo::readRegister(nMDBG::tStatus2* s)
{
   refresh(s);
   return _softCopy;
}

inline tSimultaneousControl::tTempSensorDataLo& tSimultaneousControl::tTempSensorDataLo::setTempLowerByte(u8 fieldValue, nMDBG::tStatus2* s)
{
   if (s && s->isFatal()) return *this;
   u8 newValue;   newValue = (_softCopy & 0x0) | ((u8(fieldValue) << 0x0) & ~0x0);
   setRegister(newValue, s);
   return *this;
}

inline u8 tSimultaneousControl::tTempSensorDataLo::getTempLowerByte(nMDBG::tStatus2*) const
{
   return u8((_softCopy & ~0x0) >> 0x0);
}

inline u8 tSimultaneousControl::tTempSensorDataLo::readTempLowerByte(nMDBG::tStatus2* s)
{
   refresh(s);
   return getTempLowerByte(s);
}

#endif


// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// This file is autogenerated!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!

