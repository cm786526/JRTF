// Copyright 2011 National Instruments
// License: NATIONAL INSTRUMENTS SOFTWARE LICENSE AGREEMENT
//   Refer to "MHDDK License Agreement.pdf" in the root of this distribution.

// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// This file is autogenerated!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!

#ifndef ___tStreamCircuitRegMap_h___
#define ___tStreamCircuitRegMap_h___

// includes
#include "osiTypes.h"
#include "osiBus.h"
#include "tStreamCircuitRegMapValues.h"


#ifndef ___tStreamCircuitRegMapValues_h___
#include "tStreamCircuitRegMapValues.h"
#endif

#ifndef nNIMXRegisterMap120_mBuildFieldId

// Algorithm:
//    Move lowermost 5 bits (4 through 0) of field id to uppermost 5 bits (31
//          through 27)
//    Move bit 5 of field id to bit 26
//    Move bit 6 of field id to bit 25
//    OR in the register id (which is allowed the remaining bits)
//
// Why not move the lowermost 7 bits directly to the uppermost 7 bits? Because
// we originally moved only the lowermost 5, and for backwards compatibility,
// we can't change where those 5 bits end up.
//
// For future expansion purposes, the bits beyond the first 5 are put in reverse
// order in the resulting combined id.
#define nNIMXRegisterMap120_mBuildFieldId(fieldId, regId) \
   ( \
     ((fieldId) << 27) | \
     ((((fieldId) >> 5) & 0x1) << 26) | \
     ((((fieldId) >> 6) & 0x1) << 25) | \
     (regId) \
   )

#endif

#ifndef nNIMXRegisterMap120_mExtractFieldId

// Algorithm: (basically the reverse of mBuildFieldId)
//    Move uppermost 5 bits (31 through 27) to lowermost 5 bits (4 through 0)
//    Move 26th bit to bit 5 (right-shifting by (26 - 5) is like right-shifting
//          by 26 then left-shifting by 5, but it's more efficient)
//    Move 25th bit to bit 6
#define nNIMXRegisterMap120_mExtractFieldId(id) \
   (unsigned int) \
   ( \
     (((id) >> 27) & 0x1F) | \
     (((id) & (0x1 << 26)) >> (26 - 5)) | \
     (((id) & (0x1 << 25)) >> (25 - 6)) \
   )

#endif

class tStreamCircuitRegMap
{
public:
   //---------------------------------------------------------------------------
   // IO Strategies
   //---------------------------------------------------------------------------
   class tReg32IODirect32
   {
   public:
      inline void write(
         tBusSpaceReference addrSpace,
         u32 offset,
         u32 value,
         nMDBG::tStatus2* statusChain = NULL);

      inline u32 read(
         tBusSpaceReference addrSpace,
         u32 offset,
         nMDBG::tStatus2* statusChain = NULL);
   };

   //---------------------------------------------------------------------------
   // StreamControlStatusReg
   //---------------------------------------------------------------------------
   class tStreamControlStatusReg : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tStreamCircuitRegMap tRegisterMap;

      enum {
         kOffset = 0x800,
         kId     = 0
      };
      tStreamControlStatusReg();


      typedef enum {
         kRegisterId                          = 0,
         kCISTCR_EnableId                  = 1,
         kCISTCR_DisableId                 = 2,
         kCISTCR_ClearId                   = 3,
         kCISATCR_AccessIgnoredId          = 4,
         kDataTransferEnableId             = 6,
         kStreamCircuitResetId             = 7,
         kStreamCircuitResetCompleteId     = 8,
         kStreamCircuitResetNotifyId       = 9,
         kDoneFlagSetId                    = 11,
         kInvalidPacketFlagId              = 12,
         kInvalidPacketClearId             = 13,
         kFifoEmptyId                      = 16,
         kMaxFieldId                          = 16
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Register Accessors (Compile-time selectable)

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline void writeCISTCR_Enable(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readCISTCR_Enable(nMDBG::tStatus2* statusChain = NULL);

      inline void writeCISTCR_Disable(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readCISTCR_Disable(nMDBG::tStatus2* statusChain = NULL);

      inline void writeCISTCR_Clear(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readCISTCR_Clear(nMDBG::tStatus2* statusChain = NULL);

      inline void writeCISATCR_AccessIgnored(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readCISATCR_AccessIgnored(nMDBG::tStatus2* statusChain = NULL);

      inline void writeDataTransferEnable(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readDataTransferEnable(nMDBG::tStatus2* statusChain = NULL);

      inline void writeStreamCircuitReset(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readStreamCircuitReset(nMDBG::tStatus2* statusChain = NULL);

      inline void writeStreamCircuitResetComplete(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readStreamCircuitResetComplete(nMDBG::tStatus2* statusChain = NULL);

      inline void writeStreamCircuitResetNotify(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readStreamCircuitResetNotify(nMDBG::tStatus2* statusChain = NULL);

      inline void writeDoneFlagSet(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readDoneFlagSet(nMDBG::tStatus2* statusChain = NULL);

      inline void writeInvalidPacketFlag(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readInvalidPacketFlag(nMDBG::tStatus2* statusChain = NULL);

      inline void writeInvalidPacketClear(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readInvalidPacketClear(nMDBG::tStatus2* statusChain = NULL);

      inline void writeFifoEmpty(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      inline u32 readFifoEmpty(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      tRegisterMap* _regMap;

      // Usage guidelines
      tStreamControlStatusReg(const tStreamControlStatusReg&);
      tStreamControlStatusReg& operator=(const tStreamControlStatusReg&);

   };

   //---------------------------------------------------------------------------
   // StreamAdditiveTransferCountReg
   //---------------------------------------------------------------------------
   class tStreamAdditiveTransferCountReg : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tStreamCircuitRegMap tRegisterMap;

      enum {
         kOffset = 0x810,
         kId     = 1
      };
      tStreamAdditiveTransferCountReg();


      typedef enum {
         kRegisterId                          = 0,
         kStreamAdditiveTransferCountId    = 1,
         kMaxFieldId                          = 1
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Register Accessors (Compile-time selectable)

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);


      // Field Accessors (Compile-time selectable)
      inline void writeStreamAdditiveTransferCount(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      tRegisterMap* _regMap;

      // Usage guidelines
      tStreamAdditiveTransferCountReg(const tStreamAdditiveTransferCountReg&);
      tStreamAdditiveTransferCountReg& operator=(const tStreamAdditiveTransferCountReg&);

   };

   //---------------------------------------------------------------------------
   // StreamTransferCountReg
   //---------------------------------------------------------------------------
   class tStreamTransferCountReg : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tStreamCircuitRegMap tRegisterMap;

      enum {
         kOffset = 0x810,
         kId     = 2
      };
      tStreamTransferCountReg();


      typedef enum {
         kRegisterId                          = 0,
         kStreamTransferCountId            = 1,
         kMaxFieldId                          = 1
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Register Accessors (Compile-time selectable)

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline u32 readStreamTransferCount(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      tRegisterMap* _regMap;

      // Usage guidelines
      tStreamTransferCountReg(const tStreamTransferCountReg&);
      tStreamTransferCountReg& operator=(const tStreamTransferCountReg&);

   };

   //---------------------------------------------------------------------------
   // StreamFifoSizeReg
   //---------------------------------------------------------------------------
   class tStreamFifoSizeReg : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tStreamCircuitRegMap tRegisterMap;

      enum {
         kOffset = 0x814,
         kId     = 3
      };
      tStreamFifoSizeReg();


      typedef enum {
         kRegisterId                          = 0,
         kStreamFifoSizeId                 = 1,
         kMaxFieldId                          = 1
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Register Accessors (Compile-time selectable)
      inline tStreamFifoSizeReg& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void refresh(nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tStreamFifoSizeReg& setStreamFifoSize(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getStreamFifoSize(nMDBG::tStatus2* statusChain = NULL) const;

      inline u32 readStreamFifoSize(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tStreamFifoSizeReg(const tStreamFifoSizeReg&);
      tStreamFifoSizeReg& operator=(const tStreamFifoSizeReg&);

   };

   //---------------------------------------------------------------------------
   // StreamTransferLimitReg
   //---------------------------------------------------------------------------
   class tStreamTransferLimitReg : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tStreamCircuitRegMap tRegisterMap;

      enum {
         kOffset = 0x81c,
         kId     = 4
      };
      tStreamTransferLimitReg();


      typedef enum {
         kRegisterId                          = 0,
         kStreamMinPayloadSizeId           = 1,
         kStreamMaxPayloadSizeId           = 2,
         kMaxFieldId                          = 2
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Dirty Tracking
      inline tBoolean isDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markClean(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tStreamTransferLimitReg& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline void refresh(nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tStreamTransferLimitReg& setStreamMinPayloadSize(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getStreamMinPayloadSize(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeStreamMinPayloadSize(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u32 readStreamMinPayloadSize(nMDBG::tStatus2* statusChain = NULL);

      inline tStreamTransferLimitReg& setStreamMaxPayloadSize(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getStreamMaxPayloadSize(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeStreamMaxPayloadSize(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u32 readStreamMaxPayloadSize(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tStreamTransferLimitReg(const tStreamTransferLimitReg&);
      tStreamTransferLimitReg& operator=(const tStreamTransferLimitReg&);

   };

   //---------------------------------------------------------------------------
   // StreamEvictionReg
   //---------------------------------------------------------------------------
   class tStreamEvictionReg : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tStreamCircuitRegMap tRegisterMap;

      enum {
         kOffset = 0x820,
         kId     = 5
      };
      tStreamEvictionReg();


      typedef enum {
         kRegisterId                          = 0,
         kEvictionTimeId                   = 1,
         kDisableEvictionId                = 3,
         kMaxFieldId                          = 3
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Dirty Tracking
      inline tBoolean isDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markClean(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tStreamEvictionReg& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline void refresh(nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tStreamEvictionReg& setEvictionTime(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getEvictionTime(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeEvictionTime(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u32 readEvictionTime(nMDBG::tStatus2* statusChain = NULL);

      inline tStreamEvictionReg& setDisableEviction(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getDisableEviction(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeDisableEviction(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u32 readDisableEviction(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tStreamEvictionReg(const tStreamEvictionReg&);
      tStreamEvictionReg& operator=(const tStreamEvictionReg&);

   };

   //---------------------------------------------------------------------------
   // StreamTransactionLimitReg
   //---------------------------------------------------------------------------
   class tStreamTransactionLimitReg : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tStreamCircuitRegMap tRegisterMap;

      enum {
         kOffset = 0x824,
         kId     = 6
      };
      tStreamTransactionLimitReg();


      typedef enum {
         kRegisterId                          = 0,
         kTransactionLimitId               = 1,
         kMaxTransactionLimitId            = 2,
         kMaxFieldId                          = 2
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Dirty Tracking
      inline tBoolean isDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markClean(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tStreamTransactionLimitReg& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline void refresh(nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tStreamTransactionLimitReg& setTransactionLimit(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getTransactionLimit(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeTransactionLimit(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u32 readTransactionLimit(nMDBG::tStatus2* statusChain = NULL);

      inline tStreamTransactionLimitReg& setMaxTransactionLimit(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getMaxTransactionLimit(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeMaxTransactionLimit(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u32 readMaxTransactionLimit(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tStreamTransactionLimitReg(const tStreamTransactionLimitReg&);
      tStreamTransactionLimitReg& operator=(const tStreamTransactionLimitReg&);

   };

   //---------------------------------------------------------------------------
   // DMAChannel
   //---------------------------------------------------------------------------
   class tDMAChannel : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tStreamCircuitRegMap tRegisterMap;

      const u32 kOffset;
      const u32 kId;

      tDMAChannel(u32 offset, u32 id);
      tDMAChannel();
      void initialize(u32 offset, u32 id);


      typedef enum {
         kRegisterId                          = 0,
         kDMAChannelNumberId               = 2,
         kMaxFieldId                          = 2
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Dirty Tracking
      inline tBoolean isDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markClean(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tDMAChannel& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline void refresh(nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tDMAChannel& setDMAChannelNumber(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getDMAChannelNumber(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeDMAChannelNumber(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kFalse);

      inline u32 readDMAChannelNumber(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tDMAChannel(const tDMAChannel&);
      tDMAChannel& operator=(const tDMAChannel&);

   };

   //----------------------------------------
   // Register Array Sizes
   //----------------------------------------
   enum {
      kDMAChannelArraySize = 1
   };

   //---------------------------------------------------------------------------
   // StreamControlStatusReg
   //---------------------------------------------------------------------------
   tStreamControlStatusReg StreamControlStatusReg;

   //---------------------------------------------------------------------------
   // StreamAdditiveTransferCountReg
   //---------------------------------------------------------------------------
   tStreamAdditiveTransferCountReg StreamAdditiveTransferCountReg;

   //---------------------------------------------------------------------------
   // StreamTransferCountReg
   //---------------------------------------------------------------------------
   tStreamTransferCountReg StreamTransferCountReg;

   //---------------------------------------------------------------------------
   // StreamFifoSizeReg
   //---------------------------------------------------------------------------
   tStreamFifoSizeReg StreamFifoSizeReg;

   //---------------------------------------------------------------------------
   // StreamTransferLimitReg
   //---------------------------------------------------------------------------
   tStreamTransferLimitReg StreamTransferLimitReg;

   //---------------------------------------------------------------------------
   // StreamEvictionReg
   //---------------------------------------------------------------------------
   tStreamEvictionReg StreamEvictionReg;

   //---------------------------------------------------------------------------
   // StreamTransactionLimitReg
   //---------------------------------------------------------------------------
   tStreamTransactionLimitReg StreamTransactionLimitReg;

   //---------------------------------------------------------------------------
   // DMAChannel
   //---------------------------------------------------------------------------
   tDMAChannel DMAChannel[kDMAChannelArraySize];

   //---------------------------------------------------------------------------
   // Register Groups
   //---------------------------------------------------------------------------

   //----------------------------------------
   // Register/Field Ids
   //----------------------------------------
   typedef enum {
      kStreamControlStatusRegId         = 0,
      kCISTCR_EnableId                  = nNIMXRegisterMap120_mBuildFieldId(tStreamControlStatusReg::kCISTCR_EnableId, kStreamControlStatusRegId),
      kCISTCR_DisableId                 = nNIMXRegisterMap120_mBuildFieldId(tStreamControlStatusReg::kCISTCR_DisableId, kStreamControlStatusRegId),
      kCISTCR_ClearId                   = nNIMXRegisterMap120_mBuildFieldId(tStreamControlStatusReg::kCISTCR_ClearId, kStreamControlStatusRegId),
      kCISATCR_AccessIgnoredId          = nNIMXRegisterMap120_mBuildFieldId(tStreamControlStatusReg::kCISATCR_AccessIgnoredId, kStreamControlStatusRegId),
      kDataTransferEnableId             = nNIMXRegisterMap120_mBuildFieldId(tStreamControlStatusReg::kDataTransferEnableId, kStreamControlStatusRegId),
      kStreamCircuitResetId             = nNIMXRegisterMap120_mBuildFieldId(tStreamControlStatusReg::kStreamCircuitResetId, kStreamControlStatusRegId),
      kStreamCircuitResetCompleteId     = nNIMXRegisterMap120_mBuildFieldId(tStreamControlStatusReg::kStreamCircuitResetCompleteId, kStreamControlStatusRegId),
      kStreamCircuitResetNotifyId       = nNIMXRegisterMap120_mBuildFieldId(tStreamControlStatusReg::kStreamCircuitResetNotifyId, kStreamControlStatusRegId),
      kDoneFlagSetId                    = nNIMXRegisterMap120_mBuildFieldId(tStreamControlStatusReg::kDoneFlagSetId, kStreamControlStatusRegId),
      kInvalidPacketFlagId              = nNIMXRegisterMap120_mBuildFieldId(tStreamControlStatusReg::kInvalidPacketFlagId, kStreamControlStatusRegId),
      kInvalidPacketClearId             = nNIMXRegisterMap120_mBuildFieldId(tStreamControlStatusReg::kInvalidPacketClearId, kStreamControlStatusRegId),
      kFifoEmptyId                      = nNIMXRegisterMap120_mBuildFieldId(tStreamControlStatusReg::kFifoEmptyId, kStreamControlStatusRegId),

      kStreamAdditiveTransferCountRegId   = 1,
      kStreamAdditiveTransferCountId    = nNIMXRegisterMap120_mBuildFieldId(tStreamAdditiveTransferCountReg::kStreamAdditiveTransferCountId, kStreamAdditiveTransferCountRegId),

      kStreamTransferCountRegId         = 2,
      kStreamTransferCountId            = nNIMXRegisterMap120_mBuildFieldId(tStreamTransferCountReg::kStreamTransferCountId, kStreamTransferCountRegId),

      kStreamFifoSizeRegId              = 3,
      kStreamFifoSizeId                 = nNIMXRegisterMap120_mBuildFieldId(tStreamFifoSizeReg::kStreamFifoSizeId, kStreamFifoSizeRegId),

      kStreamTransferLimitRegId         = 4,
      kStreamMinPayloadSizeId           = nNIMXRegisterMap120_mBuildFieldId(tStreamTransferLimitReg::kStreamMinPayloadSizeId, kStreamTransferLimitRegId),
      kStreamMaxPayloadSizeId           = nNIMXRegisterMap120_mBuildFieldId(tStreamTransferLimitReg::kStreamMaxPayloadSizeId, kStreamTransferLimitRegId),

      kStreamEvictionRegId              = 5,
      kEvictionTimeId                   = nNIMXRegisterMap120_mBuildFieldId(tStreamEvictionReg::kEvictionTimeId, kStreamEvictionRegId),
      kDisableEvictionId                = nNIMXRegisterMap120_mBuildFieldId(tStreamEvictionReg::kDisableEvictionId, kStreamEvictionRegId),

      kStreamTransactionLimitRegId      = 6,
      kTransactionLimitId               = nNIMXRegisterMap120_mBuildFieldId(tStreamTransactionLimitReg::kTransactionLimitId, kStreamTransactionLimitRegId),
      kMaxTransactionLimitId            = nNIMXRegisterMap120_mBuildFieldId(tStreamTransactionLimitReg::kMaxTransactionLimitId, kStreamTransactionLimitRegId),

      kDMAChannel0Id                    = 7,
      kDMAChannel0DMAChannelNumberId    = nNIMXRegisterMap120_mBuildFieldId(tDMAChannel::kDMAChannelNumberId, kDMAChannel0Id),


      kMaxRegisterId = 7

   } tId;

   tStreamCircuitRegMap(tBusSpaceReference addrSpace, nMDBG::tStatus2* statusChain = NULL);
   tStreamCircuitRegMap();
   void initialize(tBusSpaceReference addrSpace, u32 addressOffset, nMDBG::tStatus2* statusChain = NULL);
   void reset(nMDBG::tStatus2* statusChain = NULL);
   virtual ~tStreamCircuitRegMap();

   inline tBusSpaceReference getBusSpaceReference(void) const;

   inline void setAddressOffset(u32 value, nMDBG::tStatus2* statusChain = NULL);
   inline u32  getAddressOffset(nMDBG::tStatus2* statusChain = NULL);
   inline tBoolean isDirty(tId id, nMDBG::tStatus2* statusChain = NULL);
   inline void markDirty(tId id, nMDBG::tStatus2* statusChain = NULL);
   inline void markClean(tId id, nMDBG::tStatus2* statusChain = NULL);

   inline void markDirty(nMDBG::tStatus2* statusChain = NULL);
   inline void markClean(nMDBG::tStatus2* statusChain = NULL);

private:
   void _initialize(nMDBG::tStatus2* statusChain = NULL);
   tBusSpaceReference _addrSpace;
   u32 _addressOffset;
   u8 _dirtyVector[8];

};

#ifndef ___tStreamCircuitRegMap_ipp___
#ifndef ___tStreamCircuitRegMap_h_no_inline___
#include "tStreamCircuitRegMap.ipp"
#endif

#endif

#endif


// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// This file is autogenerated!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!

